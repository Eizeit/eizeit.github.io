<!DOCTYPE html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]--><!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]--><!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]--><!--[if gt IE 8]><!--><html class="no-js" lang="en">
<!--<![endif]-->

<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
<!--[if IE]><meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'><![endif]-->
<meta name="viewport" content="width=device-width,initial-scale=1">

<!-- Begin Jekyll SEO tag v2.6.1 -->
<title>【汇编与接口】 8086指令集 | 为者常成 行者常至</title>
<meta name="generator" content="Jekyll v4.1.1">
<meta property="og:title" content="【汇编与接口】 8086指令集">
<meta name="author" content="suniven(sun)">
<meta property="og:locale" content="en">
<meta name="description" content="8086指令系统">
<meta property="og:description" content="8086指令系统">
<link rel="canonical" href="https://suniven.github.io/blog/2019/12/15/assembly-instruction/">
<meta property="og:url" content="https://suniven.github.io/blog/2019/12/15/assembly-instruction/">
<meta property="og:site_name" content="为者常成 行者常至">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2019-12-15T00:00:00+08:00">
<script type="application/ld+json">
{"url":"https://suniven.github.io/blog/2019/12/15/assembly-instruction/","headline":"【汇编与接口】 8086指令集","dateModified":"2019-12-15T00:00:00+08:00","datePublished":"2019-12-15T00:00:00+08:00","author":{"@type":"Person","name":"suniven(sun)"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://suniven.github.io/blog/2019/12/15/assembly-instruction/"},"description":"8086指令系统","@type":"BlogPosting","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

<meta name="keywords" content="汇编与接口,8086指令集">





<link type="application/atom+xml" rel="alternate" href="https://suniven.github.io/feed.xml" title="为者常成 行者常至">
    <link href="/assets/stylesheets/blog.css" rel="stylesheet" type="text/css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/modernizr/2.8.3/modernizr.min.js"></script>
<script>window.Modernizr || document.write('<script src="/assets/javascripts/modernizr-2.8.3.min.js"><\/script>')</script>

<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script>
    window.jQuery || document.write('<script src="/assets/javascripts/jquery-3.3.1.min.js"><\/script>')
</script>

<script src="//cdnjs.cloudflare.com/ajax/libs/pace/1.0.2/pace.min.js"></script>
<script>
    window.Pace || document.write('<script src="/assets/javascripts/pace.min.js"><\/script>')
</script>

    
    
    <link rel="shortcut icon" type="image/x-icon" href="/assets/favicon.ico">
    
<script src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]]}});</script>
</head>

<body>
    

    <!--[if IE]>
    <p class="site-notice">You are using an outdated browser. Please <a href="http://browsehappy.com/" target="_blank">upgrade your browser</a> or <a href="http://www.google.com/chromeframe/?redirect=true" target="_blank">activate Google Chrome Frame</a> to improve your experience.</p>
<![endif]-->
<noscript>
    <p class="site-notice">This site requires JavaScript. Here are the instructions <a href="http://www.enable-javascript.com/" target="_blank">how to enable JavaScript in your web browser</a>.</p>
</noscript>

    <div class="nav-wrapper overlay-wrapper">
    <div class="nav-form overlay-form">
        <span class="overlay-header menu">Menu</span>
        <a class="btn-close">Close</a>
        <div class="results">
            <ul>
                <li><a href="/blog/categories/">Categories</a></li>
                <li><a href="/blog/tags/">Tags</a></li>
                <li><a href="/">About</a></li>
            </ul>
        </div>
    </div>
</div>

<div class="search-wrapper overlay-wrapper">
    <div class="search-form overlay-form">
        <input type="text" class="overlay-header search-field" placeholder="Search...">
        <a class="btn-close">Close</a>
        <ul class="results"></ul>
    </div>
</div>


    <div id="page" class="hentry">
        <header class="the-header">
    <div class="unit-head">
        <div class="unit-inner unit-head-inner">
            <nav class="nav-global">
                <ul>
                    <li class="logo nav-link">
                        <button class="btn-menu" title="Menu"></button>
                        <a href="/blog/">为者常成 行者常至</a>
                        <!--[if !IE]> -->
                        <button class="btn-search" title="Search"></button>
                        <!-- <![endif]-->
                    </li>
                    <li class="nav-link"><a title="Categories" href="/blog/categories/">Categories</a></li>
                    <li class="nav-link"><a title="Tags" href="/blog/tags/">Tags</a></li>
                    <!--[if !IE]> -->
                    <li class="nav-link"><a title="Search" class="btn-search" href="#">Search</a></li>
                    <!-- <![endif]-->
                </ul>
            </nav>
        </div>
    </div>
    <!--script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"-->
    
</header>


        <div class="body animated fadeInDown" role="main">
            <div class="unit-body">
                <div class="unit-inner unit-body-inner">
                    <div class="entry-content">
                        <article class="unit-article layout-post">
    <div class="unit-inner unit-article-inner">
        <div itemscope itemtype="http://schema.org/Article" class="content">
            <header>
                <div class="unit-head">
                    <div class="unit-inner unit-head-inner">
                        <h1 class="entry-title" itemprop="name">【汇编与接口】 8086指令集</h1>
                    </div>
                </div>
            </header>
            <div class="bd article-content">
                <div class="entry-content">
                    <div class="meta">
                        <p class="date-publish">
                            Published:
                            <time itemprop="datePublished" class="date-pub updated" title="2019-12-15T00:00:00+08:00" datetime="2019-12-15T00:00:00+08:00">December 15, 2019 </time>
                            by
                            <a class="author" href="/" rel="author" title="Show Author">
                                <span itemprop="author" itemscope itemtype="http://schema.org/Person">
                                    <span itemprop="name">suniven(sun)</span>
                                </span>
                            </a>
                            
                                <a class="license-icon" rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank" title="Show License">
                                    <img alt="Creative Commons Licence" style="border-width:0" src="/assets/images/theme/cc-by-sa.png" height="16" width="80">
                                </a>
                            
                            
                        </p>
                        <ul class="list-category list-linear">
                            <li class="list-head">Categories: </li>
                             
     
        <li>
            <a href="/blog/categories/#%E6%B1%87%E7%BC%96%E4%B8%8E%E6%8E%A5%E5%8F%A3" title="汇编与接口">
            汇编与接口 <span>4</span></a>
        </li>
    



                        </ul>
                        <ul class="list-tag list-linear">
                            <li class="list-head">Tags: </li>
                             
    
        
        <li>
            <a href="/blog/tags/#8086%E6%8C%87%E4%BB%A4%E9%9B%86" title="8086指令集">8086指令集 <span>1</span></a>
        </li>
    
        
        <li>
            <a href="/blog/tags/#%E6%B1%87%E7%BC%96%E4%B8%8E%E6%8E%A5%E5%8F%A3" title="汇编与接口">汇编与接口 <span>4</span></a>
        </li>
    




                        </ul>
                    </div>
                    <div itemprop="articleBody">
                        <ul class="toc" id="markdown-toc">
  <li>
<a href="#heading-31-8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F" id="markdown-toc-heading-31-8086指令系统">3.1 8086指令系统</a>    <ul>
      <li><a href="#heading-311-%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F" id="markdown-toc-heading-311-寻址方式">3.1.1 寻址方式</a></li>
      <li><a href="#heading-312-%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81%E7%B1%BB%E6%8C%87%E4%BB%A4" id="markdown-toc-heading-312-数据传送类指令">3.1.2 数据传送类指令</a></li>
      <li><a href="#heading-313-%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%B1%BB%E6%8C%87%E4%BB%A4" id="markdown-toc-heading-313-位操作类指令">3.1.3 位操作类指令</a></li>
      <li><a href="#heading-314-%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%B1%BB%E6%8C%87%E4%BB%A4" id="markdown-toc-heading-314-算术运算类指令">3.1.4 算术运算类指令</a></li>
      <li><a href="#heading-315-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E7%B1%BB%E6%8C%87%E4%BB%A4" id="markdown-toc-heading-315-字符串操作类指令">3.1.5 字符串操作类指令</a></li>
      <li><a href="#heading-316-%E6%8E%A7%E5%88%B6%E8%BD%AC%E7%A7%BB%E7%B1%BB%E6%8C%87%E4%BB%A4" id="markdown-toc-heading-316-控制转移类指令">3.1.6 控制转移类指令</a></li>
    </ul>
  </li>
  <li><a href="#heading-32-8086%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95" id="markdown-toc-heading-32-8086汇编语言的基本语法">3.2 8086汇编语言的基本语法</a></li>
  <li><a href="#heading-33-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80" id="markdown-toc-heading-33-汇编语言程序设计基础">3.3 汇编语言程序设计基础</a></li>
  <li><a href="#heading-%E7%BB%83%E4%B9%A0" id="markdown-toc-heading-练习">练习</a></li>
</ul>

<h2 id="heading-31-8086指令系统">3.1 8086指令系统</h2>

<h3 id="heading-311-寻址方式">3.1.1 寻址方式</h3>

<p>指令的寻址方式就是指令中操作数的表示方式，8086的寻址方式有立即寻址、寄存器寻址、存储器寻址、串操作寻址、外设I/O端口寻址、程序转移操作寻址</p>

<ul>
  <li>
    <p>与数据有关的寻址方式</p>

    <ol>
      <li>
        <p>立即寻址</p>

        <p>指令直接给出操作数的数值</p>

        <p><strong>立即数只能作为源操作数</strong>，若十六进制以字母开头，要在前面加0，如<strong>0FFH</strong></p>

        <p>操作位数由<strong>目的操作数</strong>决定</p>

        <p>eg. <code class="language-plaintext highlighter-rouge">MOV AX,0FFFH</code></p>
      </li>
      <li>
        <p>寄存器寻址</p>

        <p>操作数存放在寄存器中，地址码为寄存器的符号</p>

        <p>由于寄存器在微处理器内部，所有操作都在内部进行，<strong>不执行访问内存的周期，执行速度最快</strong></p>

        <p>可用于源/目的操作数</p>

        <p>eg. <code class="language-plaintext highlighter-rouge">MOV DS,AX</code>、<code class="language-plaintext highlighter-rouge">MOV AL,31H</code></p>
      </li>
      <li>
        <p>存储器寻址</p>

        <p>操作数存储在主存中，BIU根据EU传送来的偏移地址（操作数的有效地址EA）算出物理地址后执行存取该操作数的总线周期</p>

        <ul>
          <li>
            <p>直接寻址</p>

            <p>指令直接给出操作数的偏移地址即EA，eg. <code class="language-plaintext highlighter-rouge">MOV AX,[2002H]</code>，<code class="language-plaintext highlighter-rouge">INC BYTE PTR[05A2H]</code></p>

            <p>操作数的地址也可以用符号变量表示（之前定义在数据段中的变量）</p>

            <p>默认段地址为DS中的地址，可通过<strong>段跨越前缀</strong>进行更改，eg. <code class="language-plaintext highlighter-rouge">MOV AX, ES:VALUE</code></p>

            <p><strong><em>规定8086的双操作数指令至少有一个操作数采用寄存器寻址或立即寻址，即两个操作数不能同时采用与存储器有关的寻址方式</em></strong></p>
          </li>
          <li>
            <p>寄存器间接寻址</p>

            <p>操作数的EA在<strong>BX或SI/DI/BP</strong>中，eg. <code class="language-plaintext highlighter-rouge">MOV AX,[BX]</code></p>

            <p><strong>BX/SI/DI，段地址由DS指明</strong></p>

            <p><strong>BP，段地址由SS指明</strong></p>

            <p>可通过段跨越前缀更改</p>
          </li>
          <li>
            <p>寄存器相对寻址</p>

            <p>操作数的EA为寄存器的内容和一个<strong>带符号</strong>的8位/16位的位移量之和</p>

            <p><strong>只有BX/BP/SI/DI可用于寄存器相对寻址</strong></p>

            <p><strong>BX/SI/DI，段地址由DS指明</strong></p>

            <p><strong>BP段地址由SS指明</strong></p>

            <p>可通过段跨越前缀更改</p>

            <p>eg. <code class="language-plaintext highlighter-rouge">MOV AX,[SI+06H]</code>、<code class="language-plaintext highlighter-rouge">MOV AX,COUNT[BX] ;COUNT为常量/变量</code>、<code class="language-plaintext highlighter-rouge">MOV AX,[COUNT+BX] ;COUNT为常量</code>、<code class="language-plaintext highlighter-rouge">MOV DL,ES:STRING[SI]</code></p>
          </li>
          <li>
            <p>基址变址寻址</p>

            <p>操作数的EA为基址寄存器（BX/BP）的内容与变址寄存器（SI/DI）的和</p>

            <p>eg. <code class="language-plaintext highlighter-rouge">MOV AX,[BX+SI]</code>、<code class="language-plaintext highlighter-rouge">MOV AX,[BX][SI]</code></p>

            <p><strong>BX，段地址由DS指明</strong></p>

            <p><strong>BP，段地址由SS指明</strong></p>

            <p>可添加段跨越前缀更改</p>
          </li>
          <li>
            <p>相对基址变址寻址</p>

            <p>操作数的EA为基址寄存器（BX/BP）、变址寄存器（SI/DI）的内容以及一个<strong>带符号</strong>的8位/16位偏移量的和</p>

            <p><strong>BX，段地址由DS指明</strong></p>

            <p><strong>BP，段地址由SS指明</strong></p>

            <p>可添加段跨越前缀更改</p>

            <p>eg. <code class="language-plaintext highlighter-rouge">MOV AX,[BX+DI+08H]</code>、<strong><code class="language-plaintext highlighter-rouge">MOV AX,MASK[BX][SI]</code></strong>、<code class="language-plaintext highlighter-rouge">MOV,[MASK+BX+SI]</code></p>
          </li>
        </ul>
      </li>
    </ol>
  </li>
  <li>
    <p>与转移地址有关的寻址方式（程序转移寻址）</p>
  </li>
</ul>

<h3 id="heading-312-数据传送类指令">3.1.2 数据传送类指令</h3>

<ul>
  <li>
    <p>MOV DST, SRC（字/字节操作，不影响标志位）</p>

    <p><strong>注意：</strong></p>

    <ul>
      <li>
        <p>目的操作数不能是立即数</p>
      </li>
      <li>
        <p>两个操作数的寻址方式不能同时为存储器寻址</p>
      </li>
      <li>
        <p>两个操作数位数必须一致</p>

        <p>eg. <code class="language-plaintext highlighter-rouge">MOV BYTE PTR[BX],255</code>是对的，<code class="language-plaintext highlighter-rouge">MOV [BX],255</code>是错的</p>
      </li>
      <li>
        <p>CS不能作为目的操作数</p>
      </li>
      <li>
        <p>源和目的不能同时为段寄存器</p>
      </li>
      <li>
        <p>立即数不能直接送段寄存器，一般要以AX为中介</p>

        <div class="language-nasm highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="nf">MOV</span>    <span class="nb">AX</span><span class="p">,</span><span class="mh">2000H</span>
<span class="nf">MOV</span>    <span class="nb">DS</span><span class="p">,</span> <span class="nb">AX</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<hr>

<p>堆栈操作指令</p>

<ul>
  <li>
    <p>PUSH  SRC（<strong>字操作</strong>，不影响标志位）</p>

    <p>首先将SP减2，然后将SRC的低字节存入(SP)，高字节存入(SP+1)</p>

    <p><strong>注意：</strong></p>

    <ul>
      <li>
        <p>不能用立即寻址（操作数不能是立即数）</p>
      </li>
      <li>
        <p>必须是字操作</p>
      </li>
    </ul>
  </li>
  <li>
    <p>POP    DST（<strong>字操作</strong>，不影响标志位）</p>

    <p>首先将(SP)中的字节数据存入DST的低八位，(SP+1)的字节数据存入DST的高八位，然后将SP加2</p>

    <p><strong>注意：</strong></p>

    <ul>
      <li>
        <p>不能用立即寻址（操作数不能是立即数）</p>
      </li>
      <li>
        <p>必须是字操作</p>
      </li>
      <li>
        <p>不能使用CS寄存器</p>
      </li>
    </ul>
  </li>
</ul>

<hr>

<p>地址传送指令</p>

<ul>
  <li>
    <p>LEA  REG, SRC（字操作，不影响标志位）</p>

    <p>将SRC的<strong>有效地址</strong>存入指定寄存器</p>

    <ul>
      <li>必须用存储器寻址</li>
    </ul>
  </li>
  <li>
    <p>LDS  REG, SRC（字操作，不影响标志位）</p>

    <p>将SRC指明的<strong>字</strong>存储单元的内容送REG，将地址为SRC+2的<strong>字</strong>存储单元的内容送DS</p>

    <ul>
      <li>必须用存储器寻址</li>
    </ul>
  </li>
  <li>
    <p>LES  REG, SRC（字操作，不影响标志位）</p>

    <p>将SRC指明的<strong>字</strong>存储单元的内容送REG，将地址为SRC+2的<strong>字</strong>存储单元的内容送ES</p>

    <ul>
      <li>必须用存储器寻址</li>
    </ul>
  </li>
</ul>

<hr>

<p>零地址指令</p>

<ul>
  <li>
    <p>LAHF（Load AH with Flags，不影响标志位，隐含操作数为FR的低八位）</p>

    <p>将FR的低八位送AH</p>
  </li>
  <li>
    <p>SAHF（Store AH into Flags，影响标志位)</p>

    <p>将AH的内容送FR的低八位</p>
  </li>
  <li>
    <p>PUSHF（Push Flags，不影响标志位）</p>
  </li>
  <li>
    <p>POPF  （Pop Flags，影响标志位）</p>
  </li>
</ul>

<hr>

<ul>
  <li>
    <p>XCHG  DST,SRC（字/字节操作，不影响标志位）</p>

    <p>交换DST和SRT的数据</p>

    <p><strong>注意：</strong></p>

    <ul>
      <li>
        <p>两操作数均不能为立即数</p>
      </li>
      <li>
        <p>两操作数均不能用段寄存器</p>
      </li>
      <li>
        <p>两操作数不能同时采用与存储器有关的寻址方式</p>
      </li>
    </ul>

    <p>eg. <code class="language-plaintext highlighter-rouge">MOV AX,VAR</code></p>
  </li>
</ul>

<hr>

<p>换码指令</p>

<ul>
  <li>
    <p>XLAT（字节操作，不影响标志位）</p>

    <p>将地址为[BX]+[AL]（AL高位补零）的内存单元当中的字节数据送至AL</p>

    <p><img src="https://suniven.github.io/assets/images/md/assembly/XLAT.png" style="zoom:67%;"></p>
  </li>
</ul>

<h3 id="heading-313-位操作类指令">3.1.3 位操作类指令</h3>

<p>位操作运算指令分为逻辑运算指令和移位指令<br>
<strong><em>要注意每一条位操作指令如何影响标志位</em></strong></p>

<ul>
  <li>
    <p>AND/OR/XOR  DST, SRC（字、字节操作）</p>

    <p>将DST和SRT指明的操作数安位与/或/非，结果存在DST</p>

    <p><strong>注意：</strong></p>

    <ul>
      <li>
        <p>DST不能是立即数</p>
      </li>
      <li>
        <p><strong>对标志位的影响</strong>：CF=OF=0，SF、ZF、PF看结果，AF不确定</p>
      </li>
    </ul>

    <p>eg. ASCII码大小写互换：第6位取反，其余位不变（和0异或不变，和1异或相当于取反），<code class="language-plaintext highlighter-rouge">XOR AL,00100000B</code>               [注]：这里期末考用到了</p>
  </li>
  <li>
    <p>TEST DST,SRC（字/字节操作）</p>

    <p>将DST指明的操作数与SRC指明的操作数按位与，只做运算，不存结果，即只影响FR</p>

    <p><strong>对标志位的影响</strong>：CF=OF=0，SF、ZF、PF看结果，AF不确定</p>
  </li>
  <li>
    <p>NOT OPR（字/字节操作）</p>

    <p>对OPR指明的操作数按位取反，结果仍存OPR</p>

    <ul>
      <li>
        <p>不能是立即数</p>
      </li>
      <li>
        <p><strong>不影响任何标志位</strong></p>
      </li>
    </ul>
  </li>
</ul>

<hr>

<p>移位指令</p>

<p>（个人实验供参考）<strong>关于移位大于1次时对OF位的影响</strong>：与PPT上说的不一样，事实上根据实验得到结论</p>

<blockquote>
  <p>指令SHL对OF的影响：若<strong>移位完成后的符号位与未移位时的符号位</strong>相同，则OF为0，否则为1</p>

  <p>指令SHR/ROL/ROR/RCL/RCR对OF的影响：若<strong>移位完成后的符号位与最后一次移位完成之前的符号位</strong>相同，则OF为0，否则为1</p>
</blockquote>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="nf">.MODEL</span> <span class="nv">SMALL</span>
        <span class="nf">.DATA</span>
        <span class="nf">.CODE</span>
<span class="nl">START:</span>  <span class="nf">MOV</span>			<span class="nb">AL</span><span class="p">,</span><span class="mb">10101010b</span>
        <span class="nf">MOV</span>			<span class="nb">CL</span><span class="p">,</span><span class="mi">2</span>
        <span class="c1">;SHL        AL,CL</span>
        <span class="c1">;SHR        AL,CL</span>
        <span class="c1">;ROL        AL,CL</span>
        <span class="c1">;ROR        AL,CL</span>
        <span class="c1">;RCL        AL,CL</span>
        <span class="c1">;RCR        AL,CL</span>
<span class="nl">OVER:</span>   <span class="nf">MOV</span>     	<span class="nb">AX</span><span class="p">,</span> <span class="mh">4C00H</span>
        <span class="nf">INT</span>     	<span class="mh">21H</span>
        <span class="nf">END</span>        	<span class="nv">START</span>
</code></pre></div></div>

<hr>

<p>逻辑移位指令</p>

<ul>
  <li>
    <p>SHL  OPR,1/CL（字/字节操作）</p>

    <p>将OPR指明的操作数逻辑左移，空位补零，移出来的位进CF</p>

    <ul>
      <li>
        <p>OPR不能是立即寻址</p>
      </li>
      <li>
        <p>SF/ZF/PF根据结果设置，AF不确定</p>

        <p><strong>OF</strong>：事实上根据测试，不是只在移位次数为1时影响；而是若移位后的符号位与未移位时的符号位不同，则OF=1，否则OF=0</p>
      </li>
    </ul>
  </li>
  <li>
    <p>SHR OPR,1/CL（字/字节操作）</p>

    <p>将OPR指明的操作数逻辑右移，空位补零，移出来的位进CF</p>

    <ul>
      <li>
        <p>OPR不能是立即寻址</p>
      </li>
      <li>
        <p>SF/ZF/PF根据结果设置，AF不确定</p>

        <p>OF：最后一次移位后的符号位与最后一次的前一次移位后的符号位不同，OF=1，事实上只有移位次数为1的时候才有可能改变，因为大于一次时高位都补零了</p>
      </li>
    </ul>
  </li>
</ul>

<hr>

<p>算术移位指令</p>

<ul>
  <li>
    <p>SAL  OPR,1/CL（字/字节操作）</p>

    <p>将OPR指明的操作数算数左移，低位补零，移出去的位进CF</p>

    <ul>
      <li>
        <p>OPR不能是立即寻址</p>
      </li>
      <li>
        <p>SF/ZF/PF根据结果设置，AF不确定</p>

        <p>OF：若移位完成后的符号位与最后一次移位完成之前的符号位相同，则OF为0，否则为1</p>
      </li>
    </ul>
  </li>
  <li>
    <p>SAR  OPR,1/CL（字/字节操作）</p>

    <p>将OPR指明的操作数算数右移，高位补符号位，移出去的位进CF</p>

    <ul>
      <li>
        <p>OPR不能是立即寻址</p>
      </li>
      <li>
        <p>SF/ZF/PF根据结果设置，AF不确定</p>

        <p>OF：最后一次移位后的符号位与最后一次的前一次移位后的符号位不同，OF=1，事实上只有移位次数为1的时候才有可能改变，因为大于一次时高位一直补符号位了</p>
      </li>
    </ul>
  </li>
</ul>

<hr>

<p>不带进位的循环移位指令</p>

<ul>
  <li>
    <p>ROL  OPR,1/CL（字/字节操作）</p>

    <p>将OPR指明的操组数循环左移，低位空出的位用高位移出的位补，同时移出的位进入CF</p>

    <ul>
      <li>
        <p>不能是立即寻址</p>
      </li>
      <li>
        <p><strong>不影响SF/ZF/PF/AF</strong></p>

        <p>OF：若移位完成后的符号位与最后一次移位完成之前的符号位相同，则OF为0，否则为1</p>
      </li>
    </ul>
  </li>
  <li>
    <p>ROR  OPR,1/CL（字/字节操作）</p>

    <p>将OPR指明的操组数循环右移，高位空出的位用低位移出的位补，同时移出的位进入CF</p>

    <ul>
      <li>
        <p>不能是立即寻址</p>
      </li>
      <li>
        <p><strong>不影响SF/ZF/PF/AF</strong></p>

        <p>OF：若移位完成后的符号位与最后一次移位完成之前的符号位相同，则OF为0，否则为1</p>
      </li>
    </ul>
  </li>
</ul>

<hr>

<p>带进位循环移位指令</p>

<ul>
  <li>
    <p>RCL  OPR,1/CL（字/字节操作）</p>

    <p>将OPR指明的操作数连同CF一起循环左移（CF在左边）</p>

    <ul>
      <li>
        <p>不能是立即寻址</p>
      </li>
      <li>
        <p><strong>不影响SF/ZF/PF/AF</strong></p>

        <p>OF：若移位完成后的符号位与最后一次移位完成之前的符号位相同，则OF为0，否则为1</p>
      </li>
    </ul>
  </li>
  <li>
    <p>RCR  OPR,1.CL（字/字节操作）</p>

    <p>将OPR指明的操作数连同CF一起循环右移（CF在右边）</p>

    <ul>
      <li>
        <p>不能是立即寻址</p>
      </li>
      <li>
        <p><strong>不影响SF/ZF/PF/AF</strong></p>

        <p>OF：若移位完成后的符号位与最后一次移位完成之前的符号位相同，则OF为0，否则为1</p>
      </li>
    </ul>
  </li>
</ul>

<h3 id="heading-314-算术运算类指令">3.1.4 算术运算类指令</h3>

<p>算术运算的操作数一定是<strong>定点</strong>无/带符号整数<br>
双操作数指令至少有一个操作数在寄存器中/立即寻址<br>
单操作数不允许立即寻址<br>
<strong><em>要注意对标志位的影响</em></strong></p>

<ul>
  <li>
    <p>ADD  DST,SRC（字/字节操作）</p>

    <p>将DST和SRT指明的操作数相加，结果保存在DST</p>

    <ul>
      <li>
        <p>SF/ZF/PF/AF看运行情况</p>
      </li>
      <li>
        <p>若两个操作数符号相同，但结果的符号与操作数的符号相反，则产生溢出，OF=1，否则OF=0</p>
      </li>
      <li>
        <p>若最高位产生进位，则CF=1，否则CF=0，<strong>CF可以表示无符号数的溢出</strong></p>
      </li>
    </ul>
  </li>
  <li>
    <p>SUB  DST,SRC（字/字节操作）</p>

    <p>DST指明的操作数减SRC指明的操作数，结果保存在DST</p>

    <ul>
      <li>
        <p>SF/ZF/PF/AF看运行情况</p>
      </li>
      <li>
        <p>若两个操作数符号相反，但结果的符号与减数（SRC）的符号相反，则产生溢出，OF=1，否则OF=0</p>
      </li>
      <li>
        <p>（无符号数）若被减数小于减数，则CF=1，否则CF=0</p>
      </li>
    </ul>
  </li>
  <li>
    <p>ADC  DST,SRC（字/字节操作）</p>

    <p>将DST与SRC指明的操作数以及当前CF的值相加，结果保存在DST</p>

    <ul>
      <li>
        <p>SF/ZF/PF/AF看运行情况</p>
      </li>
      <li>
        <p>若两个操作数符号相同，但结果的符号与操作数的符号相反，则产生溢出，OF=1，否则OF=0</p>
      </li>
      <li>
        <p>若最高位产生进位，则CF=1，否则CF=0</p>
      </li>
    </ul>

    <p>eg. 32位数加法，目的操作数存放在DX（高）和AX（低）；源操作数存放在BX（高）、CX（低）</p>

    <div class="language-nasm highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="nf">ADD</span>    <span class="nb">AX</span><span class="p">,</span> <span class="nb">CX</span>
<span class="nf">ADC</span>    <span class="nb">DX</span><span class="p">,</span> <span class="nb">BX</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>SBB  DST,SRC（字/字节操作）</p>

    <p>DST指明的操作数减SRC指明的操作数，再减去当前CF的值，结果存DST</p>

    <ul>
      <li>
        <p>SF/ZF/PF/AF看运行情况</p>
      </li>
      <li>
        <p>若两个操作数符号相反，但结果的符号与减数（SRC）的符号相反，则产生溢出，OF=1，否则OF=0</p>
      </li>
      <li>
        <p>（无符号数）若被减数小于减数，则CF=1，否则CF=0</p>
      </li>
    </ul>

    <p>eg. 32位数减法，目的操作数存放在DX（高）和AX（低）中；源操作数为立即数80004491H</p>

    <div class="language-nasm highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="nf">SUB</span>    <span class="nb">AX</span><span class="p">,</span><span class="mh">4491H</span>
<span class="nf">SBB</span>    <span class="nb">DX</span><span class="p">,</span><span class="mh">8000H</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>INC  OPR</p>

    <p>OPR指明的操作数+1后存于OPR</p>

    <ul>
      <li>
        <p>根据结果影响OF/SF/ZF/PF/AF</p>
      </li>
      <li>
        <p><strong>不影响CF</strong></p>
      </li>
    </ul>
  </li>
  <li>
    <p>DEC  OPR</p>

    <p>OPR指明的操组数-1后存于OPR</p>

    <ul>
      <li>
        <p>根据结果影响OF/SF/ZF/PF/AF</p>
      </li>
      <li>
        <p><strong>不影响CF</strong></p>
      </li>
    </ul>
  </li>
  <li>
    <p>CMP  DST,SRC（字/字节操作）</p>

    <p>DST指明的操作数减SRC指明的操作数，<strong>只做运算，不存结果</strong>，即只改变符号位，通常后面跟条件转移指令</p>

    <ul>
      <li>
        <p>SF/ZF/PF/AF看运行情况</p>
      </li>
      <li>
        <p>若两个操作数符号相反，但结果的符号与减数（SRC）的符号相反，则产生溢出，OF=1，否则OF=0</p>
      </li>
      <li>
        <p>（无符号数）若被减数小于减数，则CF=1，否则CF=0</p>
      </li>
    </ul>
  </li>
  <li>
    <p>NEG  OPR（字/字节运算）<em>尚存疑？</em></p>

    <p>对OPR指明的操作数求补，即按位取反后加1，结果存OPR</p>

    <ul>
      <li>
        <p><strong>相当于求相反数</strong></p>
      </li>
      <li>
        <p>根据运算结果影响CF/OF/ZF/SF/PF/AF</p>
      </li>
      <li>
        <p><strong>当且仅当操作数为0时CF=1</strong>，否则CF=0</p>
      </li>
      <li>
        <p><strong>当且仅当字节运算时对-128求补或字运算时对-32768求补时OF=1</strong>，否则OF=0</p>
      </li>
    </ul>

    <blockquote>
      <p>附：一个求负数补码的简便方法</p>

      <p>找到二进制表示形式下的最右边的1，对该位左边的所有位（除去符号位）按位取反</p>

      <p>eg. -1的二进制表示为10000001B，按如上操作后变为11111111B，即0FFH，为-1的补码</p>
    </blockquote>
  </li>
  <li>
    <p>MUL  SRC（字/字节操作）</p>

    <p>若SRC指明的操作数为8位，则将其与AL中的数相乘，结果存于AX；若SRC指明的操作数为16位，则将其与AX中的数相乘，结果的高16位存于DX，低16位存于AX</p>

    <ul>
      <li>
        <p>所有操作数都是<strong>无符号数</strong></p>
      </li>
      <li>
        <p>若乘积的高半部分位0，则CF=OF=0；否则CF=OF=1；反映乘法是否超过原有的位宽</p>
      </li>
      <li>
        <p>其余标志位无定义（不确定0/1）</p>
      </li>
    </ul>
  </li>
  <li>
    <p>IMUL  SRC（字/字节操作）</p>

    <p>若SRC指明的操作数为8位，则将其与AL中的数相乘，结果存于AX；若SRC指明的操作数为16位，则将其与AX中的数相乘，结果的高16位存于DX，低16位存于AX</p>

    <ul>
      <li>
        <p>所有操作数都是<strong>带符号数</strong></p>
      </li>
      <li>
        <p>若乘积的高半部分位0，则CF=OF=0；否则CF=OF=1；反映乘法是否超过原有的位宽</p>
      </li>
      <li>
        <p>其余标志位无定义（不确定0/1）</p>
      </li>
    </ul>
  </li>
  <li>
    <p>DIV  SRC（字/字节操作）</p>

    <p>若SRC为8位，则用AX中的数除以SRC指明的数，商存AL，余数存AH；若SRC为16位，则用DX（高16位）和AX（低16位）组成的32位无符号整数除以SRC指明的数，商存AX，余数存DX</p>

    <ul>
      <li>
        <p>所有操作数都是<strong>无符号整数</strong></p>
      </li>
      <li>
        <p>所有标志位均不确定</p>
      </li>
      <li>
        <p>若位宽不足以容纳商（商溢出），将自动转入0型中断处理程序，此时得到的商和余数均不确定</p>
      </li>
    </ul>
  </li>
  <li>
    <p>IDIV  SRC（字/字节操作）</p>

    <p>若SRC为8位，则用AX中的数除以SRC指明的数，商存AL，余数存AH；若SRC为16位，则用DX（高16位）和AX（低16位）组成的32位无符号整数除以SRC指明的数，商存AX，余数存DX</p>

    <ul>
      <li>
        <p>所有操作数都是<strong>带符号整数</strong></p>
      </li>
      <li>
        <p>所有标志位均不确定</p>
      </li>
      <li>
        <p>商的符号根据代数除法规则确定，余数的符号同被除数</p>
      </li>
      <li>
        <p>若位宽不足以容纳商（商溢出），将自动转入0型中断处理程序，此时得到的商和余数均不确定</p>
      </li>
    </ul>
  </li>
  <li>
    <p>CBW  （convert byte to word）</p>

    <p><strong>隐含操作数AL</strong>，若AL最高位为0，则令AH=00H，若AL最高位为1，则令AH=0FFH</p>

    <ul>
      <li>
        <p><strong>不影响标志位</strong></p>
      </li>
      <li>
        <p>符号扩展指令用于将被除数调整为合适的位宽</p>
      </li>
    </ul>
  </li>
  <li>
    <p>CWD  （convert word to double word）</p>

    <p><strong>隐含操作数AX</strong>，若AX最高位为0，则令DX=0000H，若AX最高位为1，则令DX=0FFFFH</p>

    <ul>
      <li>
        <p><strong>不影响标志位</strong></p>
      </li>
      <li>
        <p>符号扩展指令用于将被除数调整为合适的位宽</p>
      </li>
    </ul>
  </li>
  <li>
    <p>DAA（十进制调整指令）</p>

    <p><strong>隐含操作数AL</strong>，对AL中的压缩BCD码进行修正：</p>

    <ol>
      <li>
        <p>若AL的低4位在A~F之间或AF=1，则将AL的值加06H，结果存AL并将AF置1</p>
      </li>
      <li>
        <p>若AL的高4位在A~F之间或CF=1，则将AL的值加60H，结果存AL并将XF置1</p>
        <ul>
          <li>
<strong>必须跟在ADD或ADC指令之后</strong>（AL为目的操作数）</li>
        </ul>
      </li>
    </ol>

    <ul>
      <li>对OF无定义，根据结果影响所有其余标志位</li>
    </ul>

    <p>eg. 计算两个压缩BCD码28与68之和</p>

    <div class="language-nasm highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="nf">MOV</span>    <span class="nb">AL</span><span class="p">,</span> <span class="mb">00101000B</span>
<span class="nf">ADD</span>    <span class="nb">AL</span><span class="p">,</span> <span class="mb">01101000B</span>
<span class="nf">DAA</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>DAS（十进制调整指令）</p>

    <p><strong>隐含操作数AL</strong>，对AL中的压缩BCD码进行修正：</p>

    <ol>
      <li>
        <p>若AL的低4位在A~F之间或AF=1，则将AL的值减06H，结果存AL并将AF置1</p>
      </li>
      <li>
        <p>若AL的高4位在A~F之间或CF=1，则将AL的值减60H，结果存AL并将XF置1</p>
        <ul>
          <li>
<strong>必须跟在SUB或ASBB指令之后</strong>（AL为目的操作数）</li>
        </ul>
      </li>
    </ol>

    <ul>
      <li>对OF无定义，根据结果影响所有其余标志位</li>
    </ul>

    <p>eg. 计算两个压缩BCD码86与97之差</p>

    <div class="language-nasm highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="nf">MOV</span>    <span class="nb">AL</span><span class="p">,</span><span class="mb">10000110B</span>
<span class="nf">SUB</span>    <span class="nb">AL</span><span class="p">,</span><span class="mb">10010111B</span>
<span class="nf">DAS</span>
<span class="c1">; 86+(-97)</span>
<span class="c1">; 0EFH-06H-60H=89H=10001001B即BCD码的-5</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>AAA（ASCII调整指令）</p>

    <p><strong>隐含操作数AL</strong>，对AL中的非压缩BCD码（或十进制数的ASCII码）进行修正：</p>

    <p><img src="https://suniven.github.io/assets/images/md/assembly/AAA.png" style="zoom:80%;"></p>

    <ul>
      <li>
        <p><strong>必须跟在ADD或ADC指令之后</strong>（AL为目的操作数）</p>
      </li>
      <li>
        <p>影响AF/CF，对其余标志位无定义</p>
      </li>
    </ul>

    <p>eg. 已知(AX)=0535H，(BL)=39H，分析指令</p>

    <div class="language-nasm highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="nf">ADD</span>    <span class="nb">AL</span><span class="p">,</span><span class="nb">BL</span>
<span class="nf">AAA</span>
</code></pre></div>    </div>

    <p>分析：</p>

    <p>结果(AX)=0604H，<em>？？意义？？</em>不是很懂这个指令</p>
  </li>
  <li>
    <p>AAS（ASCII调整指令）</p>

    <p><strong>隐含操作数AL</strong>，对AL中的非压缩BCD码（或十进制数的ASCII码）进行修正：</p>

    <p><img src="image%5C3%5CAAS.png" alt=""></p>

    <ul>
      <li>
        <p><strong>必须跟在SUB或SBB指令之后</strong>（AL为目的操作数）</p>
      </li>
      <li>
        <p>影响AF/CF，对其余标志位无定义</p>
      </li>
    </ul>
  </li>
  <li>
    <p>AAM（ASCII调整指令）</p>

    <p><strong>隐含操作数AX</strong>，对AL中的<strong>非压缩BCD码</strong>修正：</p>

    <p>AL中的内容除以10，余数存AL，商存AH</p>

    <ul>
      <li>
        <p><strong>必须跟在MUL指令之后</strong>，两个操作数为非压缩BCD码（<strong>高四位均为0</strong>）</p>
      </li>
      <li>
        <p>根据AL中结果设置SF/ZF/PF，其余标志位无定义</p>

        <p>eg. 已知(AL)=07H，(BL)=09H，分析指令</p>

        <div class="language-nasm highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="nf">MUL</span>    <span class="nb">BL</span>
<span class="nf">AAM</span>
</code></pre></div>        </div>

        <p>分析：</p>
      </li>
    </ul>
  </li>
  <li>
    <p>AAD（ASCII调整指令）</p>

    <p><strong>隐含操作数AX</strong>，对AX中的<strong>非压缩BCD码</strong>修正：</p>

    <p>(AH)*10+(AL)结果存AH，然后将AH清零</p>

    <ul>
      <li>
<strong>必须在DIV指令之前</strong>，被除数存于AX，为非压缩BCD码（AH存十位，AL存各位且AH、AL高4位均为0）</li>
      <li>根据AL中结果设置SF/ZF/PF，其余标志位无定义</li>
    </ul>

    <p>eg. 编程实现53/3</p>
  </li>
</ul>

<h3 id="heading-315-字符串操作类指令">3.1.5 字符串操作类指令</h3>

<p>包括串传送、串比较、串扫描、从串取、存入串<br>
一条串操作指令仅能完成1字节/字的操作，需要配合重复前缀指令才能实现对整个串的操作 <br>
分别用SI和DI作为源串和目的串的指针，源串默认在数据段，但可以通过段跨越前缀修改，<strong>目的串必须在附加段</strong><br>
每次处理完当前指向的字符后要修改段指针，修改方向由DF决定，DF=0时，DI/SI增加，DF=1时，DI/SI减小   <br>
<strong>DF标志位的清零和置1由指令CLD和STD完成</strong></p>

<ul>
  <li>
    <p>REP  MOVS/LODS/STOS</p>

    <ol>
      <li>
        <p>若CX为零则结束，否则转2</p>
      </li>
      <li>
        <p>CX=CX-1</p>
      </li>
      <li>
        <p>执行串操作指令，转1</p>
        <ul>
          <li>不影响标志位</li>
        </ul>
      </li>
    </ol>
  </li>
  <li>
    <p>MOVS  DST, SRC（字/字节操作）</p>

    <p>MOVS/MOVSW</p>

    <p>将SRC指向的字节（字）存储单元的内容送至ES:DI指向的字节（字）存储单元；然后根据DF的值将SI和DI加/减1/2</p>

    <ul>
      <li>
        <p>第一种形式由操作数指明字/字节操作</p>
      </li>
      <li>
        <p>第二种形式默认[DS:SI]送[ES:DI]</p>
      </li>
      <li>
        <p><strong>别忘了设置DF</strong></p>

        <p><em>思考：DF何时取0，何时取1？</em></p>

        <p>当源串与目的串存储空间有重合时，若源串在前，DF=1；若源串在后，DF=0</p>
      </li>
      <li>
        <p>不影响状态位</p>
      </li>
    </ul>
  </li>
  <li>
    <p>STOS  DST</p>

    <p>STOSB/STOSW</p>

    <p>将AL（AX）的值传送至ES:DI指向的字节（字）存储单元，然后根据DF的值将DI增加/减少1/2</p>

    <ul>
      <li>
        <p>第一种形式由操作数指明字/字节操作</p>
      </li>
      <li>
        <p>常用于缓冲区初始化</p>
      </li>
      <li>
        <p>不影响标志位</p>
      </li>
    </ul>
  </li>
  <li>
    <p>LODS  SRC</p>

    <p>LODSB/LODSW</p>

    <p>将SRC指向的字节（字）存储单元送至AL（AX），然后根据DF的值将SI增加/减少1/2</p>

    <ul>
      <li>
        <p>第一种形式由操作数指明字/字节操作</p>
      </li>
      <li>
        <p>不影响标志位</p>
      </li>
      <li>
        <p>一般不与REP联用</p>
      </li>
    </ul>
  </li>
  <li>
    <p>REPE/REPZ  CMPS/SCAS</p>

    <ol>
      <li>
        <p>若CX不为0且ZF=1则转2，否则结束</p>
      </li>
      <li>
        <p>CX=CX-1</p>
      </li>
      <li>
        <p>执行串操作指令，转1</p>
        <ul>
          <li>本身不影响标志位，影响标志位的是其后的串操作</li>
        </ul>
      </li>
    </ol>
  </li>
  <li>
    <p>CMPS  SRC, DST</p>

    <p>CMPSB/CMPSW</p>

    <p>用SRC指向的字节（字）存储单元的内容减去ES:DI指向的字节（字）存储单元的内容，根据结果设置标志位，然后根据DF的值将SI和DI增加/减少1/2</p>

    <ul>
      <li>
        <p>对符号位的影响同SUB指令</p>
      </li>
      <li>
        <p>第一种形式由操作数指明字/字节操作</p>
      </li>
      <li>
        <p>第二种形式默认[DS:SI]-[ES:DI]</p>
      </li>
    </ul>
  </li>
  <li>
    <p>REPNZ/REPNE  CMPS/SCAS</p>

    <ol>
      <li>
        <p>若CX不为0且ZF=0则转2，否则结束</p>
      </li>
      <li>
        <p>CX=CX-1</p>
      </li>
      <li>
        <p>执行串操作指令，转1</p>
        <ul>
          <li>指令本身不影响标志位，影响标志位的是串操作指令</li>
        </ul>
      </li>
    </ol>
  </li>
  <li>
    <p>SCAS  DST</p>

    <p>SCASB/SCASW</p>

    <p>用AL（AX）中的内容减去ES:DI指向的字节（字）存储单元的内容，根据结果设置标志位，然后根据DF的值将DI增加/减少1/2</p>

    <ul>
      <li>
        <p>对符号位影响同SUB指令</p>
      </li>
      <li>
        <p>第一种形式由操作数指明字/字节操作</p>
      </li>
    </ul>

    <p>eg. 比较两个等长的字符串是否相同，相同用0表示，不同用-1表示，结果存入result字节单元</p>

    <div class="language-nasm highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="err">    </span><span class="nf">LEA</span>    <span class="nb">SI</span><span class="p">,</span><span class="nv">STR1</span>
<span class="err">    </span><span class="nf">LEA</span>    <span class="nb">DI</span><span class="p">,</span><span class="nv">STR2</span>
<span class="err">    </span><span class="nf">MOV</span>    <span class="nb">CX</span><span class="p">,</span><span class="nv">LEN</span>    <span class="c1">;LEN是字符串长度</span>
<span class="err">    </span><span class="nf">CLD</span>              <span class="c1">;DF=0</span>
    <span class="nf">REPZ</span>   <span class="nv">CMPSB</span>
    <span class="nf">XOR</span>    <span class="nb">AL</span><span class="p">,</span><span class="nb">AL</span>
    <span class="nf">JNZ</span>    <span class="nv">RE</span>        <span class="c1">;不为零则相等</span>
<span class="nl">NE:</span> <span class="nf">DEC</span>    <span class="nb">AL</span>
<span class="nl">RE:</span> <span class="nf">MOV</span>    <span class="nv">RESULT</span><span class="p">,</span><span class="nb">AL</span>   
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="heading-316-控制转移类指令">3.1.6 控制转移类指令</h3>

<p>根据功能划分：包括无条件转移、条件转移、循环、子程序调用及返回、中断及返回<br>
根据目标地址与本指令是否在同一代码段划分：段内转移、段间转移。段内转移范围在-128~127之间，段内转移仅需目标的有效地址（CS）不变；段间转移需要确定目标的有效地址和段地址并改变IP和CS的值<br>
寻址方式：</p>

<ol>
  <li>
    <p>相对寻址：用于段内转移，目标地址的有效地址为IP的当前值与指令中给出的8位或16位位移量之<strong>和</strong></p>
  </li>
  <li>
    <p>段内寄存器寻址：段内转移的目标的有效地址为某16位寄存器的内容</p>
  </li>
  <li>
    <p>段内间接寻址：段内转移的目标的有效地址为某字存储单元的内容</p>
  </li>
  <li>
    <p>段间直接寻址：指令中直接给出目标的段地址和有效地址代替CS和IP的内容实现转移</p>
  </li>
  <li>
    <p>段间间接寻址：目标地址为存储器中连续两个字单元的内容（<strong>低地址为有效地址，高地址为段地址</strong>）</p>
  </li>
</ol>

<p><strong>注意：</strong>所有的<strong>条件</strong>转移指令只能使用相对寻址的8位位移量，<strong>也就是都是段内转移</strong>，指令本身不影响标志位</p>

<ul>
  <li>
    <p>JMP（无条件转移指令）</p>

    <div class="language-nasm highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="c1">; 段内相对转移</span>
<span class="nf">JMP</span>    <span class="nv">PROG</span>    <span class="c1">; 16位</span>
<span class="nf">JMP</span>    <span class="nv">SHORT</span> <span class="nv">PROG</span>    <span class="c1">; 8位</span>
<span class="c1">; 段内寄存器/间接转移</span>
<span class="nf">JMP</span>    <span class="nb">BX</span>
<span class="nf">JMP</span>    <span class="kt">WORD</span> <span class="nv">PTR</span> <span class="p">[</span><span class="nb">BX</span><span class="o">+</span><span class="nb">SI</span><span class="p">]</span>
<span class="c1">; 段间直接转移</span>
<span class="nf">JMP</span>    <span class="nv">FAR</span> <span class="nv">PTR</span> <span class="nv">PROC</span>    <span class="c1">; 4字节</span>
<span class="c1">; 段间间接转移</span>
<span class="nf">JMP</span>    <span class="kt">DWORD</span> <span class="nv">PTR</span> <span class="p">[</span><span class="nb">DI</span> <span class="o">+</span> <span class="nv">BRCHTABLE</span><span class="p">]</span>
</code></pre></div>    </div>

    <ul>
      <li>不影响标志位</li>
    </ul>
  </li>
  <li>
    <p>条件转移指令</p>

    <ul>
      <li>
        <p>JZ/JE    JNZ/JNE</p>

        <p>JZ：ZF为1时跳转，否则不跳转；JNZ反之</p>
      </li>
      <li>
        <p>JS    JNS</p>

        <p>JS：SF为1时跳转，否则不跳转；JNS反之</p>
      </li>
      <li>
        <p>JO    JNO</p>

        <p>JO：OF为1时跳转，否则不跳转；JNO反之</p>
      </li>
      <li>
        <p>JP/JPE    JNP/JPO</p>

        <p>JP：PF为1时跳转，否则不跳转；JNP反之</p>
      </li>
      <li>
        <p>JC/JB/JNAE    JNC/JNB/JAE</p>

        <p>JC：CF为1时跳转，否则不跳转；JNC反之</p>
      </li>
      <li>
        <p>JA/JNBE    JNA/JBE</p>

        <p>JA：CF=ZF=0则跳转，否则不跳转；JNA反之</p>

        <p>其实JA就是高于则跳转，JNBE就是不是低于或等于也就是高于，一个意思</p>
      </li>
      <li>
        <p>JL/JNGE    JNL/JGE</p>

        <p>JL：$OF \oplus SF = 1$ 则跳转，否则不跳转；JNL反之</p>

        <p>jump if less 小于则转移</p>
      </li>
      <li>
        <p>JG/JNLE    JNG/JLE</p>

        <p>JG：$OF \oplus SF=0$ 且ZF为0则跳转，否则不跳转；JNG反之</p>

        <p>jump if greater 大于则转移</p>
      </li>
    </ul>

    <p><strong>JB/JBE/JNB/JNBE/JA/JAE/JNA/JNAE用于无符号数比较</strong></p>

    <p><strong>JL/JLE/JNL/JNLE/JG/JGE/JNG/JNGE用于带符号数比较</strong></p>

    <ul>
      <li>
        <p>JCXZ（jump if cx=zero）</p>

        <p>CX=0则跳转，否则不转</p>
      </li>
    </ul>
  </li>
  <li>
    <p>循环指令</p>

    <ul>
      <li>
        <p>LOOP OPR</p>

        <p>CX减1存CX，若CX非0，则转移至标号OPR处执行，否则按照代码顺序执行下一条指令</p>

        <ul>
          <li>
            <p>属于“直到型循环”</p>
          </li>
          <li>
            <p>只能使用相对寻址的8位位移量</p>
          </li>
          <li>
            <p>不影响标志位</p>
          </li>
        </ul>
      </li>
      <li>
        <p>LOOPZ/LOOPE</p>

        <p>LOOPNZ/LOOPNE</p>

        <p>CX减1存CX，若CX非零且ZF=1(0)，则转移至标号OPR处执行，否则按照代码顺序执行下一条指令</p>

        <ul>
          <li>
            <p>只能用相对寻址的8位位移量</p>
          </li>
          <li>
            <p>不影响标志位</p>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>子程序调用指令</p>

    <p>CALL DST</p>

    <p>DST：子程序入口地址</p>

    <ul>
      <li>
        <p>段内调用：当前IP值进栈（保护断点），然后将DST指明的偏移地址送IP</p>
      </li>
      <li>
        <p>段间调用：当前CS值入栈，当前IP值入栈（保护断点，注意顺序），然后将DST指明的段地址送CS，偏移地址送IP</p>
      </li>
    </ul>
  </li>
  <li>
    <p>子程序返回指令</p>

    <p>作为子程序的最后一条指令，返回主程序CALL指令后的下一条指令继续执行</p>

    <ul>
      <li>
        <p>RET/RET  N</p>

        <p>段内返回，出栈一个字送IP（恢复断点）</p>

        <p>若带一个立即数N，则在上述操作完成后额外出栈N/2个字</p>
      </li>
      <li>
        <p>RETF/RETF  N</p>

        <p>段间返回，出栈两个字，第一个字送IP，第二个字送CS（恢复断点，注意顺序）</p>

        <p>若带一个立即数N，则在上述操作完成后额外出栈N/2个字</p>
      </li>
    </ul>

    <p>不影响标志位</p>
  </li>
  <li>
    <p>中断指令INT</p>

    <p>INT  TYPE</p>

    <p>TYPE为0~255之间的常量</p>

    <ol>
      <li>
        <p>当前标志寄存器FLAGS入栈</p>
      </li>
      <li>
        <p>当前CS、IP值入栈（注意顺序）（保护断点）</p>
      </li>
      <li>
        <p>物理地址为 $TYPE \times 4$ 的字存储单元的内容送IP，$TYPE\times 4+2$ 的字存储单元的内容送CS（寻找中断服务程序入口地址）</p>
      </li>
      <li>
        <p>将<strong>IF和TF清零</strong>（关中断）</p>

        <p>注：参见中断向量表</p>

        <p><img src="https://suniven.github.io/assets/images/md/assembly/int_table.png" style="zoom: 25%;">
       - INT指令不影响除IF和TF之外的标志位</p>
      </li>
    </ol>

    <blockquote>
      <p>关于IP和CS的入栈/出栈顺序：</p>

      <p>可以这么记，栈是向下生长的（地址由大到小），在栈中，保存段地址的地址总是大于保存段内偏移地址的地址</p>
    </blockquote>
  </li>
  <li>
    <p>中断返回指令IRET</p>

    <p>IRET<br>
出栈第一个字送IP；出栈第二个字送CS；出栈第三个字送FLAGS</p>
  </li>
  <li>
    <p>系统功能调用</p>

    <p>以21H为总入口，再配以具体功能号（AH），常用的有：</p>

    <ul>
      <li>
        <p>01H：从键盘输入一个字符并回显至屏幕</p>
      </li>
      <li>
        <p>02H：显示一个字符至屏幕（字符放在DL）</p>
      </li>
      <li>
        <p>09H：显示字符串至屏幕</p>
      </li>
      <li>
        <p>0AH：从键盘输入字符串到缓冲区</p>
      </li>
      <li>
        <p>4CH：带返回码结束</p>
      </li>
    </ul>
  </li>
  <li>
    <p>中断指令INTO（溢出中断服务）<br>
若OF=0，继续执行下一条指令<br>
若OF=1：</p>

    <ol>
      <li>
        <p>FLAGS入栈</p>
      </li>
      <li>
        <p>CS、IP入栈</p>
      </li>
      <li>
        <p>物理地址为10H的字存储单元的内容送IP，物理地址为12H的字存储单元的内容送CS（类型为4的中断）</p>
      </li>
      <li>
        <p>IF和TF清零</p>
        <ul>
          <li>INTO不影响除IF和TF以外的标志位</li>
        </ul>
      </li>
    </ol>
  </li>
  <li>
    <p>标志操作指令（不影响其余标志位）</p>

    <ul>
      <li>
        <p>CLC，将CF清零</p>
      </li>
      <li>
        <p>CMC，将CF取反</p>
      </li>
      <li>
        <p>STC，将CF置1</p>
      </li>
      <li>
        <p>CLD，将DF清零</p>
      </li>
      <li>
        <p>STD，将DF置1</p>
      </li>
      <li>
        <p>CLI，将IF清零</p>
      </li>
      <li>
        <p>STI，将IF置1</p>

        <p><strong>开中断，8259A编程中，调用某中断后若想中断嵌套，必须在中断处理程序开头加上STI</strong></p>
      </li>
    </ul>

    <p><strong>对于其他标志位无相应的清零或置1指令</strong></p>
  </li>
  <li>
    <p>无操作指令NOP（不影响标志位）</p>
  </li>
  <li>
    <p>停机指令HLT<br>
使处理机处于停机状态，以等待一次外部中断或RESET信号的到来，中断处理结束后继续执行后续指令</p>
  </li>
  <li>
    <p>等待指令WAIT<br>
等待 $\overline{TEST}$ 信号有效，每五个时钟周期测试一次，有效后顺序执行下一条指令</p>
  </li>
  <li>
    <p>交权指令ESC<br>
ESC  OPCODE, SRC<br>
与WAIT指令一同用于与协处理器配合</p>
  </li>
  <li>
    <p>总线封锁前缀指令LOCK<br>
可以添加在任何指令之前，在该条指令执行期间保持CPU对总线的控制权，其他处理器不能从CPU抢占总线</p>
  </li>
</ul>

<h2 id="heading-32-8086汇编语言的基本语法">3.2 8086汇编语言的基本语法</h2>

<ul>
  <li>
    <p>框架（简略模式）</p>

    <div class="language-nasm highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>        <span class="c1">;采用简化版的段定义伪指令，下一个段的开始即表示上一个段的结束</span>
        <span class="nf">.model</span> <span class="nv">small</span>
        <span class="nf">.stack</span>    <span class="p">[</span><span class="err">常量</span><span class="p">(</span><span class="err">大小为常量个字节</span><span class="p">)</span><span class="err">默认</span><span class="mi">1</span><span class="nv">KB</span><span class="p">]</span>
        <span class="nf">.data</span>
<span class="c1">; ...定义的数据</span>
<span class="c1">; [变量名]    DB    操作数列表</span>
<span class="c1">; DB(define word)</span>
<span class="c1">; DD(define double word)</span>
<span class="c1">; DQ</span>
<span class="c1">; DT</span>
<span class="c1">; PORTA    EQU    20H  符号常量也可用=定义</span>
<span class="c1">; PTR 类型属性操作符 转换类型    类型 PTR 变量名/含变量名的表达式</span>
        <span class="nf">.code</span>    <span class="p">[</span><span class="err">段名</span><span class="p">]</span>
<span class="nl">start:</span>  <span class="nf">mov</span>    <span class="nb">ax</span><span class="p">,</span> <span class="err">@</span><span class="nv">data</span>     <span class="c1">; @data表示代码段名</span>
        <span class="nf">mov</span>    <span class="nb">ds</span><span class="p">,</span> <span class="nb">ax</span>        <span class="c1">; 装载数据段</span>
          
        <span class="c1">; ....一些操作</span>
          
        <span class="nf">mov</span>    <span class="nb">ax</span><span class="p">,</span><span class="mh">4c00h</span>
        <span class="nf">int</span>    <span class="mh">21h</span>           <span class="c1">; 调用21号中断结束汇编</span>
      <span class="nf">end</span>    <span class="nv">start</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>框架（非简略模式）</p>

    <div class="language-nasm highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="nf">SSTACK</span>	<span class="ow">SEG</span><span class="nv">MEN</span>	<span class="nv">STACK</span>
		<span class="kd">DB</span>	<span class="mi">200</span> <span class="nv">DUP</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="nf">SSTACK</span>	<span class="nv">ENDS</span>        
<span class="nf">DATA</span>	<span class="ow">SEG</span><span class="nv">MENT</span>
<span class="c1">; ORG 3000H    ; ORG规定起始地址</span>
<span class="c1">; ARY     DB    100,98,-1,-2,-4,7,0,100,32,1</span>
<span class="c1">; ARRY  DQ DUP(?)    ; DUP复制操作符,?表示只分配存储空间</span>
<span class="nf">DATA</span>	<span class="nv">ENDS</span>
<span class="nf">CODE</span>    <span class="ow">SEG</span><span class="nv">MENT</span>
        <span class="nf">ASSUME</span>     <span class="nb">CS</span><span class="p">:</span><span class="nv">CODE</span><span class="p">,</span><span class="nb">DS</span><span class="p">:</span><span class="nv">DATA</span><span class="p">,</span><span class="nb">SS</span><span class="p">:</span><span class="nb">SS</span><span class="nv">TACK</span>
<span class="nl">START:</span>  <span class="nf">MOV</span>     <span class="nb">AX</span><span class="p">,</span><span class="nv">DATA</span>
        <span class="nf">MOV</span>     <span class="nb">DS</span><span class="p">,</span><span class="nb">AX</span>
        <span class="nf">MOV</span>     <span class="nb">AX</span><span class="p">,</span><span class="nv">STACK</span>
        <span class="nf">MOV</span>     <span class="nb">SS</span><span class="p">,</span><span class="nb">AX</span>
        <span class="c1">; CS不需要送段寄存器</span>
        <span class="c1">; ...一些操作</span>
        <span class="nf">MOV</span>    <span class="nb">AX</span><span class="p">,</span><span class="mh">4C00H</span>
        <span class="nf">INT</span>    <span class="mh">21H</span>           <span class="c1">; 调用21号中断结束汇编</span>
<span class="nf">CODE</span>    <span class="nv">ENDS</span>
        <span class="nf">END</span>      <span class="nv">START</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>标识符的属性</p>

    <ul>
      <li>
        <p>段属性<br>
标号的段属性必在CS寄存器中</p>
      </li>
      <li>
        <p>偏移属性（16位无符号数）</p>
      </li>
      <li>
        <p>类型属性</p>

        <ul>
          <li>
            <p>标号：NEAR/FAR</p>
          </li>
          <li>
            <p>变量名：BYTE/WORD/DWORD/QWORD/TBYTE</p>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>常量</p>

    <ul>
      <li>
        <p>常数</p>
      </li>
      <li>
        <p>字符</p>
      </li>
      <li>
        <p>字符串（可以在单引号里也可以在双引号里）</p>
      </li>
      <li>
        <p>符号常量<br>
标识符  EQU/=  常量或常量表达式 <strong>该语句不占内存</strong></p>

        <p>$：当前行的偏移地址</p>
      </li>
    </ul>
  </li>
  <li>
    <p>变量</p>

    <ul>
      <li>
        <p>DB/DW/DD/DQ/DT</p>
      </li>
      <li>
        <p>类型转换：<br>
类型  PTR  变量名/含变量名的表达式</p>

        <p><code class="language-plaintext highlighter-rouge">JMP WORD PTR [BX]</code></p>
      </li>
    </ul>
  </li>
  <li>
    <p>运算符（操作符）</p>

    <ul>
      <li>
        <p>算术运算符：“+” “-” “*” “/” 和MOD</p>
      </li>
      <li>
        <p>逻辑运算符：AND/OR/XOR/NOT/SHL/SHR</p>
      </li>
      <li>
        <p>关系运算符：EQ/NE/LT/GT/LE/GE</p>
      </li>
      <li>
        <p>属性运算符：PTR/SHORT/THIS/HIGH/LOW/TYPE/LENGTH/SIZE</p>
      </li>
      <li>
        <p>地址运算符：“[]” 、“$”、 “:”、 OFFSET、SEG</p>
      </li>
    </ul>

    <p>运算符出现在<strong>操作数项内部</strong>，运算在<strong>汇编时完成</strong></p>
  </li>
</ul>

<h2 id="heading-33-汇编语言程序设计基础">3.3 汇编语言程序设计基础</h2>

<p>理论不多说了，还是要编</p>

<ul>
  <li>
    <p>顺序结构程序设计</p>
  </li>
  <li>
    <p>分支结构程序设计</p>

    <p><strong>注意跳过不该执行的分支</strong></p>

    <ul>
      <li>
        <p>eg. 显示2位压缩BCD码的值（0-99），不输出前导0，并设待显示字节数据已用DB伪指令存至变量BCD中</p>

        <div class="language-nasm highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>	  <span class="c1">; 核心部分</span>
      <span class="nf">mov</span>    <span class="nb">dl</span><span class="p">,</span> <span class="nv">bcd</span>
      <span class="nf">test</span>   <span class="nb">dl</span><span class="p">,</span> <span class="mh">0F0H</span>    <span class="c1">; 按位与看看是一位数还是两位数</span>
      <span class="nf">jz</span>     <span class="nv">one</span>
<span class="nl">two:</span>  <span class="nf">mov</span>    <span class="nb">cl</span><span class="p">,</span> <span class="mi">4</span>
      <span class="nf">shr</span>    <span class="nb">dl</span><span class="p">,</span> <span class="nb">cl</span>      <span class="c1">; 把BCD码的十位移到ASCII的低4位</span>
      <span class="nf">add</span>    <span class="nb">dl</span><span class="p">,</span> <span class="mh">30h</span>
      <span class="nf">mov</span>    <span class="nb">ah</span><span class="p">,</span> <span class="mh">02h</span>
      <span class="nf">int</span>    <span class="mh">21h</span>
      <span class="nf">mov</span>    <span class="nb">dl</span><span class="p">,</span> <span class="nv">bcd</span>
      <span class="nf">and</span>    <span class="nb">dl</span><span class="p">,</span> <span class="mh">0fh</span>
      <span class="nf">add</span>    <span class="nb">dl</span><span class="p">,</span> <span class="mh">30h</span>
<span class="nl">one:</span>  <span class="nf">mov</span>    <span class="nb">ah</span><span class="p">,</span> <span class="mh">02h</span>
      <span class="nf">int</span>    <span class="mh">21h</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>多分支结构<br>
<strong>跳跃表法</strong><br>
eg. 根据BX的低四位哪一位为1（由低到高）在屏幕上显示1、2、4、8</p>

        <div class="language-nasm highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>        <span class="nf">.model</span> <span class="nv">small</span>
        <span class="nf">.data</span>
<span class="no">var</span><span class="kd">     equ</span>        <span class="nv">?</span>    <span class="c1">; 测试数据</span>
<span class="nf">tab</span>     <span class="nv">dw</span>         <span class="nv">foo1</span><span class="p">,</span> <span class="nv">foo2</span><span class="p">,</span> <span class="nv">foo3</span><span class="p">,</span> <span class="nv">foo4</span>    <span class="c1">; ***</span>
        <span class="nf">.code</span>
<span class="nl">start:</span>  <span class="nf">mov</span>        <span class="nb">ax</span><span class="p">,</span> <span class="err">@</span><span class="nv">data</span>
        <span class="nf">mov</span>        <span class="nb">ds</span><span class="p">,</span> <span class="nb">ax</span>
        <span class="nf">mov</span>        <span class="nb">bx</span><span class="p">,</span> <span class="nv">var</span>
        <span class="nf">xor</span>        <span class="nb">si</span><span class="p">,</span> <span class="nb">si</span>
<span class="nl">find:</span>   <span class="nf">shr</span>        <span class="nb">bx</span><span class="p">,</span> <span class="mi">1</span>
        <span class="nf">jnc</span>        <span class="nv">no</span>
        <span class="nf">mov</span>        <span class="nb">ah</span><span class="p">,</span> <span class="mh">02h</span>
        <span class="nf">jmp</span>        <span class="nv">tab</span><span class="p">[</span><span class="nb">si</span><span class="p">]</span>
<span class="nl">no:</span>     <span class="nf">add</span>        <span class="nb">si</span><span class="p">,</span> <span class="mi">2</span>
        <span class="nf">jmp</span>        <span class="nv">find</span>
<span class="nl">foo1:</span>   <span class="nf">mov</span>        <span class="nb">dl</span><span class="p">,</span><span class="s">'1'</span>
        <span class="nf">jmp</span>        <span class="nv">over</span>
<span class="nl">foo2:</span>   <span class="nf">mov</span>        <span class="nb">dl</span><span class="p">,</span><span class="s">'2'</span>
        <span class="nf">jmp</span>        <span class="nv">over</span>
<span class="nl">foo3:</span>   <span class="nf">mov</span>        <span class="nb">dl</span><span class="p">,</span><span class="s">'4'</span>
        <span class="nf">jmp</span>        <span class="nv">over</span>
<span class="nl">foo4:</span>   <span class="nf">mov</span>        <span class="nb">dl</span><span class="p">,</span><span class="s">'8'</span>
        <span class="nf">jmp</span>        <span class="nv">over</span>
<span class="nl">over:</span>   <span class="nf">int</span>        <span class="mh">21h</span>
        <span class="nf">mov</span>        <span class="nb">ax</span><span class="p">,</span><span class="mh">4c00h</span>
        <span class="nf">int</span>        <span class="mh">21h</span>
        <span class="nf">end</span>        <span class="nv">start</span>
</code></pre></div>        </div>

        <p><strong>DW标识符</strong>是将该标识符（标号、变量名、etc…）对应的段内偏移地址存入一个字单元，类似的，<strong>可用DD将某标识符的偏移地址和段地址存入两个相邻的字单元（双字，偏移地址放在低地址单元，段地址放在高地址单元</strong></p>
      </li>
    </ul>
  </li>
  <li>
    <p>循环结构</p>

    <ul>
      <li>
        <p>计数控制</p>
      </li>
      <li>
        <p>条件控制（无条件转移指令、条件转移指令）</p>

        <p>eg. 输入若干学生姓名，直接按回车则结束，将其中最大者（按字典序）输出。</p>

        <div class="language-nasm highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>		<span class="nf">.model</span>  <span class="nv">small</span>
        <span class="nf">.data</span>
<span class="nf">maxlen</span>	<span class="nv">db</span>      <span class="mh">11h</span>				<span class="c1">;一个学生姓名的最大长度+1（回车）</span>
<span class="nf">actlen</span>	<span class="nv">db</span>      <span class="nv">?</span>      			<span class="c1">;实际输入的字符个数</span>
<span class="nf">nmbuf</span>	<span class="nv">db</span>      <span class="mh">11h</span> <span class="nv">dup</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>		<span class="c1">;namebuffer</span>
<span class="nf">rslt</span>	<span class="nv">db</span>      <span class="s">'Result: '</span>		<span class="c1">;</span>
<span class="nf">longnm</span>	<span class="nv">db</span>		<span class="mh">0dh</span><span class="p">,</span> <span class="mh">0ah</span><span class="p">,</span> <span class="s">'$'</span>	<span class="c1">;初始化，一开始肯定比'a'小就对了</span>
        <span class="kd">db</span>		<span class="mh">10h</span> <span class="nv">dup</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>		<span class="c1">;最大的名字</span>
<span class="nf">crlf</span>	<span class="nv">db</span>		<span class="mh">0dh</span><span class="p">,</span> <span class="mh">0ah</span><span class="p">,</span> <span class="s">'$'</span>	<span class="c1">;回车换行</span>
        <span class="nf">.code</span>
<span class="nl">start:</span>  <span class="nf">mov</span>		<span class="nb">ax</span><span class="p">,</span> <span class="err">@</span><span class="nv">data</span>
        <span class="nf">mov</span>		<span class="nb">ds</span><span class="p">,</span> <span class="nb">ax</span>
        <span class="nf">mov</span>     <span class="nb">es</span><span class="p">,</span> <span class="nb">ax</span>
        <span class="nf">cld</span>
<span class="nl">next:</span>   <span class="nf">lea</span>     <span class="nb">si</span><span class="p">,</span> <span class="nv">nmbuf</span>
        <span class="nf">lea</span>		<span class="nb">di</span><span class="p">,</span> <span class="nv">longnm</span>
        <span class="nf">lea</span>		<span class="nb">dx</span><span class="p">,</span> <span class="nv">maxlen</span>		<span class="c1">;把最大可输入字符数存到缓冲区第一个字节单元</span>
        <span class="nf">mov</span>		<span class="nb">ah</span><span class="p">,</span> <span class="mh">0ah</span>			<span class="c1">;输入姓名</span>
        <span class="nf">int</span>		<span class="mh">21h</span>
    
        <span class="nf">lea</span>     <span class="nb">dx</span><span class="p">,</span> <span class="nv">crlf</span>        <span class="c1">;输出回车换行</span>
        <span class="nf">dec</span> 	<span class="nb">ah</span>              <span class="c1">;09H号，输出字符串</span>
        <span class="nf">int</span>   	<span class="mh">21h</span>
    
        <span class="nf">mov</span>  	<span class="nb">cl</span><span class="p">,</span> <span class="nv">actlen</span>
        <span class="nf">xor</span>    	<span class="nb">ch</span><span class="p">,</span> <span class="nb">ch</span>
        <span class="nf">jcxz</span>	<span class="nv">otpt</span>            <span class="c1">;若CX=0则跳转，CX=0即只键入了一个回车，结束</span>
    
        <span class="nf">repe</span>    <span class="nv">cmpsb</span>           <span class="c1">;比较nmbuf和longnm的大小 SI-DI</span>
        <span class="nf">jng</span>     <span class="nv">next</span>            <span class="c1">;/js</span>
        <span class="nf">lea</span>   	<span class="nb">si</span><span class="p">,</span> <span class="nv">nmbuf</span>       <span class="c1">;更新当前的最大名字</span>
        <span class="nf">lea</span>  	<span class="nb">di</span><span class="p">,</span> <span class="nv">longnm</span>
        <span class="nf">mov</span>   	<span class="nb">cl</span><span class="p">,</span> <span class="nv">actlen</span>
        <span class="nf">rep</span>		<span class="nv">movsb</span>
    
        <span class="nf">mov</span>		<span class="kt">byte</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">di</span><span class="p">],</span> <span class="mh">0dh</span>        <span class="c1">;回车换行结束</span>
        <span class="nf">mov</span>		<span class="kt">byte</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">di</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="mh">0ah</span>
        <span class="nf">mov</span>		<span class="kt">byte</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">di</span><span class="o">+</span><span class="mi">2</span><span class="p">],</span> <span class="s">'$'</span>
    
        <span class="nf">jmp</span>     <span class="nv">next</span>
<span class="nl">otpt:</span>   <span class="nf">mov</span>     <span class="nb">dx</span><span class="p">,</span> <span class="nv">offset</span> <span class="nv">rslt</span>	<span class="c1">;因为rslf后面存的就是结果，结果里才有'$'所以一直输出到结束</span>
         <span class="nf">int</span>        <span class="mh">21h</span>
         <span class="nf">mov</span>        <span class="nb">ax</span><span class="p">,</span> <span class="mh">4c00h</span>
         <span class="nf">int</span>        <span class="mh">21h</span>
         <span class="nf">end</span>        <span class="nv">start</span>
</code></pre></div>        </div>

        <ul>
          <li>
            <p>双重循环</p>

            <p>eg. 改进的冒泡排序</p>

            <div class="language-nasm highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>        <span class="c1">;改进的冒泡排序,递增</span>
        <span class="nf">.model</span> <span class="nv">small</span>
        <span class="nf">.data</span>
<span class="no">COUNT</span><span class="kd">   EQU</span>		<span class="mi">11</span>
<span class="nf">FLAG</span>    <span class="nv">DB</span>		<span class="mi">1</span>
        <span class="nf">.CODE</span>
<span class="nl">START:</span>  <span class="nf">MOV</span>        <span class="nb">AX</span><span class="p">,</span><span class="err">@</span><span class="nv">DATA</span>
        <span class="nf">MOV</span>        <span class="nb">DS</span><span class="p">,</span><span class="nb">AX</span>
        <span class="nf">MOV</span>        <span class="nb">DI</span><span class="p">,</span><span class="mh">3000H</span>
        <span class="nf">MOV</span>        <span class="nb">CX</span><span class="p">,</span><span class="nv">COUNT</span>    
        <span class="nf">DEC</span>        <span class="nb">CX</span>           <span class="c1">;外层循环次数</span>
<span class="nl">OLP:</span>    <span class="nf">MOV</span>        <span class="nb">DX</span><span class="p">,</span><span class="nb">CX</span>        <span class="c1">;暂存外层循环</span>
        <span class="nf">CMP</span>        <span class="nv">FLAG</span><span class="p">,</span><span class="mi">0</span>       <span class="c1">;如果上一轮没有进行交换</span>
        <span class="nf">JE</span>         <span class="nv">OVER</span>         <span class="c1">;提前结束[优化]</span>
        <span class="nf">MOV</span>        <span class="nv">FLAG</span><span class="p">,</span><span class="mi">0</span>
        <span class="nf">MOV</span>        <span class="nb">DI</span><span class="p">,</span><span class="mh">3000H</span>
    
<span class="nl">ILP:</span>    <span class="nf">MOV</span>        <span class="nb">AL</span><span class="p">,[</span><span class="nb">DI</span><span class="p">]</span>
        <span class="nf">CMP</span>        <span class="nb">AL</span><span class="p">,[</span><span class="nb">DI</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>    <span class="c1">;ax-[DI+1]</span>
        <span class="nf">JB</span>         <span class="nv">STEP</span>         <span class="c1">;小于则直接比较下一组</span>
        <span class="nf">XCHG</span>       <span class="nb">AL</span><span class="p">,[</span><span class="nb">DI</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>    <span class="c1">;大于则交换</span>
        <span class="nf">MOV</span>        <span class="p">[</span><span class="nb">DI</span><span class="p">],</span><span class="nb">AL</span>
        <span class="nf">MOV</span>        <span class="nv">FLAG</span><span class="p">,</span><span class="mi">1</span>       <span class="c1">;一轮中发生交换将FLAG置1        </span>
<span class="nl">STEP:</span>   <span class="nf">INC</span>        <span class="nb">DI</span>
        <span class="nf">LOOP</span>       <span class="nv">ILP</span>
        <span class="nf">MOV</span>        <span class="nb">CX</span><span class="p">,</span><span class="nb">DX</span>        <span class="c1">;恢复CX继续计数</span>
        <span class="nf">LOOP</span>       <span class="nv">OLP</span>
    
<span class="nl">OVER:</span>   <span class="nf">MOV</span>        <span class="nb">AX</span><span class="p">,</span><span class="mh">4C00H</span>
        <span class="nf">INT</span>        <span class="mi">21</span>
<span class="nf">END</span>     <span class="nv">START</span>
    
</code></pre></div>            </div>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>子程序结构</p>

    <p>格式：</p>

    <div class="language-nasm highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="err">过程名</span>    <span class="nf">PROC</span>    <span class="p">[</span><span class="err">属性</span><span class="p">]</span>
      <span class="err">…</span>         <span class="c1">;子程序主体部分</span>
  <span class="err">过程名</span>    <span class="nf">ENDP</span>
</code></pre></div>    </div>

    <p>属性为NEAR/FAR</p>

    <p>eg. N的阶乘</p>

    <div class="language-nasm highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>          	<span class="c1">;N的阶乘</span>
<span class="nf">STACK</span>   <span class="ow">SEG</span><span class="nv">MENT</span> <span class="nv">STACK</span>
		<span class="kd">DB</span> <span class="mi">200</span> <span class="nv">DUP</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="nf">STACK</span>   <span class="nv">ENDS</span>
<span class="nf">DATA</span>	<span class="ow">SEG</span><span class="nv">MENT</span>
		<span class="nf">N</span>         <span class="nv">DW</span> <span class="mi">7</span>
		<span class="nf">RESULT</span>    <span class="nv">DW</span> <span class="nv">?</span>
<span class="nf">DATA</span>    <span class="nv">ENDS</span>
<span class="nf">CODE</span>    <span class="ow">SEG</span><span class="nv">MENT</span>
  		<span class="nf">ASSUME</span>     <span class="nb">CS</span><span class="p">:</span><span class="nv">CODE</span><span class="p">,</span><span class="nb">SS</span><span class="p">:</span><span class="nv">STACK</span><span class="p">,</span><span class="nb">DS</span><span class="p">:</span><span class="nv">DATA</span>
<span class="nl">START:</span>	<span class="nf">MOV</span>		<span class="nb">AX</span><span class="p">,</span><span class="nv">DATA</span>
        <span class="nf">MOV</span>     <span class="nb">DS</span><span class="p">,</span><span class="nb">AX</span>
        <span class="nf">MOV</span>     <span class="nb">AX</span><span class="p">,</span><span class="nv">N</span>
        <span class="nf">MOV</span>     <span class="nb">DX</span><span class="p">,</span><span class="mi">1</span>
        <span class="nf">CALL</span>    <span class="nv">FACT</span>
        <span class="nf">MOV</span>     <span class="nv">RESULT</span><span class="p">,</span><span class="nb">DX</span>
        <span class="nf">MOV</span>     <span class="nb">AX</span><span class="p">,</span><span class="mh">4C00H</span>
        <span class="nf">INT</span>     <span class="mh">21H</span>
          
<span class="nf">FACT</span>    <span class="nv">PROC</span>
        <span class="nf">CMP</span>     <span class="nb">AX</span><span class="p">,</span><span class="mi">0</span>
        <span class="nf">JNE</span>     <span class="nv">STEP</span>        <span class="c1">;没结束</span>
        <span class="nf">MOV</span>     <span class="nb">DX</span><span class="p">,</span><span class="mi">1</span>
        <span class="nf">RET</span>
  
<span class="nl">STEP:</span>   <span class="nf">PUSH</span>    <span class="nb">AX</span>
        <span class="nf">DEC</span>     <span class="nb">AX</span>
        <span class="nf">CALL</span>    <span class="nv">FACT</span>        <span class="c1">;递归调用</span>
        <span class="nf">POP</span>     <span class="nb">AX</span>
        <span class="nf">MUL</span>     <span class="nb">DX</span>
        <span class="nf">MOV</span>     <span class="nb">DX</span><span class="p">,</span><span class="nb">AX</span>
        <span class="nf">RET</span>
<span class="nf">FACT</span>    <span class="nv">ENDP</span>
  
<span class="nf">CODE</span>    <span class="nv">ENDS</span>
		<span class="nf">END</span>      <span class="nv">START</span>
</code></pre></div>    </div>

    <ul>
      <li>
        <p>子程序的参数传递——寄存器传参<br>
适用于参数较少的时候</p>
      </li>
      <li>
        <p>子程序的参数传递——<strong>地址表传参</strong><br>
适用于参数较多的情况</p>

        <p>eg. 计算数组的累加和</p>

        <div class="language-nasm highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>        <span class="nf">.model</span> <span class="nv">small</span>
        <span class="nf">.data</span>
<span class="nf">ary</span>     <span class="nv">dw</span>        <span class="mi">10</span> <span class="nv">dup</span><span class="p">(</span><span class="nv">?</span><span class="p">)</span>
<span class="nf">cnt</span>     <span class="nv">dw</span>        <span class="mi">10</span>
<span class="nf">sum</span>     <span class="nv">dw</span>        <span class="nv">?</span>
<span class="nf">tbl</span>     <span class="nv">dw</span>        <span class="mi">3</span> <span class="nv">dup</span><span class="p">(</span><span class="nv">?</span><span class="p">)</span>
        <span class="nf">.code</span>    
<span class="nf">main</span>    <span class="nv">proc</span>    <span class="nv">far</span>
<span class="nl">begin:</span>  <span class="nf">mov</span>     <span class="nb">ax</span><span class="p">,</span> <span class="err">@</span><span class="nv">data</span>
        <span class="nf">mov</span>     <span class="nb">ds</span><span class="p">,</span> <span class="nb">ax</span>
        <span class="nf">mov</span>     <span class="nv">tbl</span><span class="p">,</span> <span class="nv">offset</span> <span class="nv">ary</span>
        <span class="nf">mov</span>     <span class="nv">tbl</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="nv">offset</span> <span class="nv">cnt</span>
        <span class="nf">mov</span>     <span class="nv">tbl</span><span class="o">+</span><span class="mi">4</span><span class="p">,</span> <span class="nv">offset</span> <span class="nv">sum</span>
        <span class="nf">mov</span>     <span class="nb">bx</span><span class="p">,</span> <span class="nv">offset</span> <span class="nv">tbl</span>
        <span class="nf">call</span>    <span class="nv">addtab</span>
        <span class="nf">mov</span>     <span class="nb">ax</span><span class="p">,</span> <span class="mh">4c00h</span>
        <span class="nf">int</span>     <span class="mh">21h</span>
<span class="nf">main</span>    <span class="nv">endp</span>
<span class="nf">addtab</span>  <span class="nv">proc</span>	<span class="nv">near</span>
        <span class="nf">push</span>	<span class="nb">ax</span>
        <span class="nf">push</span>	<span class="nb">cx</span>
        <span class="nf">push</span>	<span class="nb">si</span>
        <span class="nf">push</span>    <span class="nb">di</span>
        <span class="nf">mov</span>    	<span class="nb">si</span><span class="p">,</span> <span class="p">[</span><span class="nb">bx</span><span class="p">]</span>        <span class="c1">;数组首地址</span>
        <span class="nf">mov</span>   	<span class="nb">di</span><span class="p">,</span> <span class="p">[</span><span class="nb">bx</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>      <span class="c1">;数组元素个数</span>
        <span class="nf">mov</span>     <span class="nb">cx</span><span class="p">,</span> <span class="p">[</span><span class="nb">di</span><span class="p">]</span>        <span class="c1">;数组元素个数送CX</span>
        <span class="nf">mov</span>     <span class="nb">di</span><span class="p">,</span> <span class="p">[</span><span class="nb">bx</span><span class="o">+</span><span class="mi">4</span><span class="p">]</span>      <span class="c1">;sum</span>
        <span class="nf">xor</span>     <span class="nb">ax</span><span class="p">,</span> <span class="nb">ax</span>          <span class="c1">;ax存每次相加后的结果</span>
<span class="nl">next:</span>   <span class="nf">add</span>     <span class="nb">ax</span><span class="p">,</span> <span class="p">[</span><span class="nb">si</span><span class="p">]</span>
        <span class="nf">add</span>     <span class="nb">si</span><span class="p">,</span> <span class="mi">2</span>
        <span class="nf">loop</span>    <span class="nv">next</span>
        <span class="nf">mov</span>     <span class="p">[</span><span class="nb">di</span><span class="p">],</span> <span class="nb">ax</span>        <span class="c1">;结果送sum</span>
        <span class="nf">pop</span>     <span class="nb">di</span>
        <span class="nf">pop</span>     <span class="nb">si</span>
        <span class="nf">pop</span>     <span class="nb">cx</span>
        <span class="nf">pop</span>     <span class="nb">ax</span>
        <span class="nf">ret</span>
<span class="nf">addtab</span>  <span class="nv">endp</span>
        <span class="nf">end</span>   	<span class="nv">begin</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>子程序的参数传递——<strong>堆栈传参</strong><br>
适用于子程序有嵌套、递归调用的情况，主程序将参数压栈，子程序将参数弹栈。使用堆栈传参要注意对栈的管理，最好可以画个图。</p>

        <p>eg. 数组累加</p>

        <div class="language-nasm highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>        <span class="nf">.model</span> <span class="nv">small</span>
        <span class="nf">.data</span>
<span class="nf">ary</span>     <span class="nv">dw</span>        <span class="mi">10</span> <span class="nv">dup</span><span class="p">(</span><span class="nv">?</span><span class="p">)</span>
<span class="nf">cnt</span>     <span class="nv">dw</span>        <span class="mi">10</span>
<span class="nf">sum</span>     <span class="nv">dw</span>        <span class="nv">?</span>
        <span class="nf">.stack</span>
        <span class="kd">dw</span>        <span class="mi">100</span> <span class="nv">dup</span><span class="p">(</span><span class="nv">?</span><span class="p">)</span>
<span class="nf">btm</span>     <span class="nv">dw</span>        <span class="nv">?</span>                <span class="c1">;栈是向下生长的</span>
        <span class="nf">.code</span>    
<span class="nf">main</span>    <span class="nv">proc</span>	<span class="nv">far</span>
<span class="nl">begin:</span>  <span class="nf">mov</span>     <span class="nb">ax</span><span class="p">,</span> <span class="err">@</span><span class="nv">data</span>
        <span class="nf">mov</span>     <span class="nb">ds</span><span class="p">,</span> <span class="nb">ax</span>
        <span class="nf">mov</span>     <span class="nb">sp</span><span class="p">,</span> <span class="nv">offset</span> <span class="nv">btm</span>    <span class="c1">;栈顶指针，当前指向栈底</span>
        <span class="nf">mov</span>     <span class="nb">bx</span><span class="p">,</span> <span class="nv">offset</span> <span class="nv">ary</span>    <span class="c1">;数组首地址</span>
        <span class="nf">push</span>    <span class="nb">bx</span>
        <span class="nf">mov</span>     <span class="nb">bx</span><span class="p">,</span> <span class="nv">offset</span> <span class="nv">cnt</span>    <span class="c1">;数组元素个数</span>
        <span class="nf">push</span>    <span class="nb">bx</span>
        <span class="nf">mov</span>     <span class="nb">bx</span><span class="p">,</span> <span class="nv">offset</span> <span class="nv">sum</span>    <span class="c1">;数组元素和</span>
        <span class="nf">push</span>    <span class="nb">bx</span>
        <span class="nf">call</span>    <span class="nv">addstk</span>
        <span class="nf">mov</span>     <span class="nb">ax</span><span class="p">,</span> <span class="mh">4c00h</span>
        <span class="nf">int</span>     <span class="mh">21h</span>
<span class="nf">main</span>    <span class="nv">endp</span>
<span class="nf">addstk</span>  <span class="nv">proc</span>    <span class="nv">near</span>
        <span class="nf">push</span>    <span class="nb">bp</span>
        <span class="nf">mov</span>        <span class="nb">bp</span><span class="p">,</span> <span class="nb">sp</span>
        <span class="nf">push</span>    <span class="nb">ax</span>
        <span class="nf">push</span>    <span class="nb">cx</span>
        <span class="nf">push</span>    <span class="nb">si</span>
        <span class="nf">push</span>    <span class="nb">di</span>
        <span class="nf">mov</span>     <span class="nb">si</span><span class="p">,</span> <span class="p">[</span><span class="nb">bp</span><span class="o">+</span><span class="mi">8</span><span class="p">]</span>  <span class="c1">;&amp;ary</span>
        <span class="nf">mov</span>     <span class="nb">di</span><span class="p">,</span> <span class="p">[</span><span class="nb">bp</span><span class="o">+</span><span class="mi">6</span><span class="p">]</span>  <span class="c1">;&amp;cnt</span>
        <span class="nf">mov</span>     <span class="nb">cx</span><span class="p">,</span> <span class="p">[</span><span class="nb">di</span><span class="p">]</span>    <span class="c1">;数组元素个数</span>
        <span class="nf">mov</span>     <span class="nb">di</span><span class="p">,</span> <span class="p">[</span><span class="nb">bp</span><span class="o">+</span><span class="mi">4</span><span class="p">]</span>	<span class="c1">;&amp;sum</span>
        <span class="nf">xor</span>     <span class="nb">ax</span><span class="p">,</span> <span class="nb">ax</span>
<span class="nl">next:</span>   <span class="nf">add</span>     <span class="nb">ax</span><span class="p">,</span> <span class="p">[</span><span class="nb">si</span><span class="p">]</span>
        <span class="nf">add</span>     <span class="nb">si</span><span class="p">,</span> <span class="mi">2</span>
        <span class="nf">loop</span>    <span class="nv">next</span>
        <span class="nf">mov</span>     <span class="p">[</span><span class="nb">di</span><span class="p">],</span> <span class="nb">ax</span>
        <span class="nf">pop</span>     <span class="nb">di</span>
        <span class="nf">pop</span>     <span class="nb">si</span>
        <span class="nf">pop</span>     <span class="nb">cx</span>
        <span class="nf">pop</span>     <span class="nb">ax</span>
        <span class="nf">pop</span>     <span class="nb">bp</span>
        <span class="nf">ret</span>     <span class="mi">6</span>        	<span class="c1">;额外弹出3个字（丢弃不再需要的参数）</span>
<span class="nf">addstk</span>  <span class="nv">endp</span>
        <span class="nf">end</span>     <span class="nv">begin</span>
</code></pre></div>        </div>

        <p><img src="https://suniven.github.io/assets/images/md/assembly/s_para1.JPG" style="zoom: 10%;"></p>

        <p><strong>BP的专门用途正是堆栈传参</strong>，BP寄存器默认与SS段寄存器配合</p>

        <p>递归式累加代码：</p>

        <div class="language-nasm highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="c1">; 元素个数用堆栈传递，累加和用AX传递</span>
        <span class="nf">.model</span>    <span class="nv">small</span>
        <span class="nf">.data</span>
<span class="nf">ary</span>     <span class="nv">dw</span>        <span class="mi">10</span> <span class="nv">dup</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="nf">cnt</span>     <span class="nv">dw</span>        <span class="mi">10</span>
<span class="nf">sum</span>     <span class="nv">dw</span>        <span class="nv">?</span>
        <span class="nf">.stack</span>
        <span class="kd">dw</span>    <span class="mi">100</span> <span class="nv">dup</span><span class="p">(</span><span class="nv">?</span><span class="p">)</span>
<span class="nf">btm</span>     <span class="nv">dw</span>    <span class="nv">?</span>
        <span class="nf">.code</span>
<span class="nf">main</span>    <span class="nv">proc</span>	<span class="nv">far</span>
<span class="nl">begin:</span>  <span class="nf">mov</span>   	<span class="nb">ax</span><span class="p">,</span> <span class="err">@</span><span class="nv">data</span>
        <span class="nf">mov</span> 	<span class="nb">ds</span><span class="p">,</span> <span class="nb">ax</span>
        <span class="nf">mov</span>		<span class="nb">sp</span><span class="p">,</span> <span class="nv">offset</span> <span class="nv">btm</span>        <span class="c1">;栈顶指针，初始指向栈底</span>
        <span class="nf">push</span>    <span class="nv">cnt</span>
        <span class="nf">mov</span>     <span class="nb">bx</span><span class="p">,</span> <span class="nv">offset</span> <span class="nv">ary</span>
        <span class="nf">push</span>    <span class="nb">bx</span>
        <span class="nf">xor</span>     <span class="nb">ax</span><span class="p">,</span> <span class="nb">ax</span>
        <span class="nf">call</span>    <span class="nv">addrec</span>
        <span class="nf">mov</span>		<span class="nv">sum</span><span class="p">,</span> <span class="nb">ax</span>
        <span class="nf">mov</span>     <span class="nb">ax</span><span class="p">,</span> <span class="mh">4c00h</span>
        <span class="nf">int</span>     <span class="mh">21h</span>
<span class="nf">main</span>    <span class="nv">endp</span>
<span class="nf">addrec</span>  <span class="nv">proc</span>    <span class="nv">near</span>
        <span class="nf">push</span>    <span class="nb">bp</span>
        <span class="nf">mov</span>     <span class="nb">bp</span><span class="p">,</span> <span class="nb">sp</span>
        <span class="nf">push</span>    <span class="nb">bx</span>
        <span class="nf">mov</span>     <span class="nb">bx</span><span class="p">,</span> <span class="p">[</span><span class="nb">bp</span><span class="o">+</span><span class="mi">6</span><span class="p">]</span>        <span class="c1">;cnt</span>
        <span class="nf">test</span>    <span class="nb">bx</span><span class="p">,</span> <span class="nb">bx</span>            <span class="c1">;cnt=0?</span>
        <span class="nf">jz</span>      <span class="nv">back</span>
<span class="nl">recur:</span>  <span class="nf">dec</span>     <span class="nb">bx</span>
        <span class="nf">push</span>    <span class="nb">bx</span>
        <span class="nf">mov</span>     <span class="nb">bx</span><span class="p">,</span> <span class="p">[</span><span class="nb">bp</span><span class="o">+</span><span class="mi">4</span><span class="p">]</span>
        <span class="nf">add</span>     <span class="nb">bx</span><span class="p">,</span> <span class="mi">2</span>
        <span class="nf">push</span>    <span class="nb">bx</span>
        <span class="nf">call</span>    <span class="nv">addrec</span>
        <span class="nf">mov</span>     <span class="nb">bx</span><span class="p">,</span> <span class="p">[</span><span class="nb">bp</span><span class="o">+</span><span class="mi">4</span><span class="p">]</span>
        <span class="nf">add</span>     <span class="nb">ax</span><span class="p">,</span> <span class="p">[</span><span class="nb">bx</span><span class="p">]</span>
<span class="nl">back:</span>   <span class="nf">pop</span>     <span class="nb">bx</span>
        <span class="nf">pop</span>     <span class="nb">bp</span>
        <span class="nf">ret</span>     <span class="mi">4</span>
        <span class="nf">end</span>     <span class="nv">begin</span>
</code></pre></div>        </div>

        <p>当CNT=2时堆栈的变化如下图：（借此了解一下栈帧）</p>
      </li>
    </ul>

    <p><img src="https://suniven.github.io/assets/images/md/assembly/s_para2.JPG" style="zoom: 20%;"></p>

    <ul>
      <li>
        <p>子程序参数传递——<strong>结构化参数</strong></p>

        <p>格式：</p>

        <p>结构名    STRUC<br>
… …<br>
结构名    ENDS</p>

        <p>结构变量名    结构名    &lt;预赋值说明（给出各字段的值，用逗号分隔，不填表示缺省）&gt;</p>

        <p><img src="https://suniven.github.io/assets/images/md/assembly/struct_para.png" style="zoom:80%;"></p>
      </li>
    </ul>
  </li>
  <li>
    <p>宏定义</p>

    <ul>
      <li>
        <p>格式：<br>
宏名 MACRO [形参列表]<br>
 …     ; 宏定义体<br>
ENDM</p>
      </li>
      <li>
        <p>宏名必须以字母开头，形参可缺省，也可有多个形参（逗号分隔）</p>
      </li>
      <li>
        <p>宏定义中出现标号时，必须用LOCAL伪指令将其声明为局部标号，否则多次宏调用将出现重复标号问题</p>

        <p><strong>注意</strong>：LOCAL伪指令只能用于宏定义体内部，必须是MACRO伪指令后的第一条语句，在MARCO和LOCAL之间不能有注释</p>

        <div class="language-nasm highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>        <span class="c1">; 将ASCII码转化为真值</span>
        <span class="nf">ASCTOH</span>    <span class="nv">MACRO</span>
                <span class="nf">LOCAL</span>    <span class="nv">ASCTOH1</span><span class="p">,</span> <span class="nv">ASCTOH2</span>
                <span class="nf">CMP</span>        <span class="nb">AL</span><span class="p">,</span> <span class="err">‘</span><span class="mi">9</span><span class="err">’</span>
                <span class="nf">JBE</span>        <span class="nv">ASCTOH1</span>
                <span class="nf">CMP</span>        <span class="nb">AL</span><span class="p">,</span> <span class="err">‘</span><span class="nv">a</span><span class="err">’</span>
                <span class="nf">JB</span>        <span class="nv">ASCTOH2</span>
                <span class="nf">SUB</span>        <span class="nb">AL</span><span class="p">,</span> <span class="mh">20H</span>
        <span class="nl">ASCTOH2:</span>    
                <span class="nf">SUB</span>        <span class="nb">AL</span><span class="p">,</span> <span class="mi">7</span>
        <span class="nl">ASCTOH1:</span>    
                <span class="nf">SUB</span>        <span class="nb">AL</span><span class="p">,</span> <span class="mh">30H</span>
                <span class="nf">ENDM</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>
    <p>宏调用与宏展开</p>

    <ul>
      <li>
        <p>宏调用</p>

        <p>格式：<code class="language-plaintext highlighter-rouge">宏名 [实参列表]</code></p>

        <p>宏调用也称宏指令，对汇编语言源程序进行汇编时，汇编程序将对每一个宏调用作宏展开</p>
      </li>
      <li>
        <p>宏展开</p>

        <p>即以宏定义体替换宏名，并将宏定义提中出现的形参用与之位置相同的实参替换</p>
      </li>
      <li>
        <p>宏指令名可以与指令或伪指令的助记符相同，<strong>宏的优先级最高</strong><br>
可以用PURGE伪指令取消宏定义以恢复指令的原始含义，如 <code class="language-plaintext highlighter-rouge">PURGE ADD</code></p>

        <p>eg. 显示一个字符的宏定义</p>

        <div class="language-nasm highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="nf">DISPCH</span>  <span class="nv">MACRO</span>    <span class="nb">CH</span><span class="nv">AR</span>
        <span class="nf">MOV</span>        <span class="nb">AH</span><span class="p">,</span> <span class="mi">2</span>
        <span class="nf">MOV</span>        <span class="nb">DL</span><span class="p">,</span> <span class="nb">CH</span><span class="nv">AR</span>
        <span class="nf">INT</span>        <span class="mh">21H</span>
        <span class="nf">ENDM</span>
        <span class="c1">; 宏调用</span>
        <span class="nf">DISPCH</span>    <span class="err">‘</span><span class="nv">Y</span><span class="err">’</span>
        <span class="nf">DISPCH</span>    <span class="nb">BL</span>
        <span class="nf">DISPCH</span>    <span class="kt">BYTE</span><span class="nv">_VAR</span>
</code></pre></div>        </div>

        <p>eg. <strong>实参作为指令操作码助记符的一部分</strong></p>

        <blockquote>
          <p>宏展开时，'&amp;' 前后的符号将合并</p>
        </blockquote>

        <div class="language-nasm highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>    <span class="nf">LEAP</span>     <span class="nv">MACRO</span>    <span class="nv">COND</span><span class="p">,</span> <span class="nv">LAB</span>
    <span class="nf">J</span><span class="o">&amp;</span><span class="nv">COND</span>   <span class="nv">LAB</span>
    <span class="nf">ENDM</span>
    <span class="c1">;宏调用</span>
    <span class="nf">LEAP</span>     <span class="nv">Z</span><span class="p">,</span> <span class="nv">THERE</span>
    <span class="nf">LEAP</span>     <span class="nv">NC</span><span class="p">,</span> <span class="nv">HERE</span>
    <span class="c1">;宏展开</span>
    <span class="nf">JZ</span>       <span class="nv">THERE</span>
    <span class="nf">JNC</span>      <span class="nv">HERE</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>
    <p>重复汇编</p>

    <p>格式：</p>

    <div class="language-nasm highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>          <span class="nf">REPT</span>    <span class="err">表达式</span>
          <span class="nf">...</span>        <span class="c1">;重复块</span>
          <span class="nf">ENDM</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>宏与子程序对比</p>

    <ul>
      <li>宏是文本替换，子程序是流程转移</li>
      <li>宏展开发生在程序执行之前的汇编阶段，程序执行时已经没有宏了；子程序则是在程序执行时才被执行</li>
      <li>宏的速度更快，函数的空间更小</li>
      <li>程序较短且要求执行较快时适合采用宏实现；程序段较长时适合采用子程序</li>
    </ul>
  </li>
  <li>
    <p>条件汇编</p>

    <p>汇编程序根据条件决定是否对某一段源代码进行汇编</p>

    <div class="language-nasm highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>          <span class="nf">IFXX</span>    <span class="err">参数</span>
              <span class="err">…</span>    <span class="c1">;参数满足条件则汇编此块</span>
          <span class="err">[</span><span class="nf">ELSE</span><span class="p">]</span>
              <span class="err">…</span>    <span class="c1">;参数不满足条件则汇编此块</span>
          <span class="nf">ENDIF</span>
</code></pre></div>    </div>

    <ul>
      <li>
        <p>IF 表达式：计算表达式的值，若结果不为零则满足条件</p>
      </li>
      <li>
        <p>IFE 表达式：计算表达式的值，若结果为零则满足条件</p>
      </li>
      <li>
        <p>IFDEF 符号：若符号已在程序中定义，或者已经用EXTERN伪指令声明为外部符号，则满足条件</p>
      </li>
      <li>
        <p>IFNDEF 符号：若符号未在程序中定义且未用EXTERN伪指令声明为外部符号，则满足条件</p>
      </li>
      <li>
        <p>IFB ：若自变量为空则满足条件自变量&gt;</p>
      </li>
      <li>
        <p>IFNB ：若自变量非空则满足条件自变量&gt;</p>

        <p>eg. GOTO L, X, REL</p>

        <div class="language-nasm highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>    <span class="c1">;宏定义</span>
<span class="nf">GOTO</span>    <span class="nv">MACRO</span>    <span class="nv">L</span><span class="p">,</span> <span class="nv">X</span><span class="p">,</span> <span class="nv">REL</span>
    	<span class="nf">IFB</span>    <span class="o">&lt;</span><span class="nv">REL</span><span class="o">&gt;</span>
    	<span class="nf">JMP</span>    <span class="nv">L</span>
    	<span class="nf">ELSE</span>
    	<span class="nf">MOV</span>    <span class="nb">CX</span><span class="p">,</span> <span class="nv">X</span>
<span class="nl">L:</span>      <span class="nf">DEC</span>    <span class="nb">CX</span>
    	<span class="nf">ADD</span>    <span class="nv">X</span><span class="p">,</span> <span class="nb">CX</span>
    	<span class="nf">AND</span>    <span class="nb">CX</span><span class="p">,</span> <span class="nb">CX</span>
    	<span class="nf">J</span><span class="o">&amp;</span><span class="nv">REL</span>    <span class="nv">L</span>
    	<span class="nf">ENDIF</span>
    	<span class="nf">ENDM</span>
    	<span class="c1">;宏调用</span>
    	<span class="err">…</span>
    	<span class="nf">SUM</span>    <span class="nv">DW</span>    <span class="mi">100</span>
   	 	<span class="err">…</span>
    	<span class="nf">GOTO</span>    <span class="nv">NEXT</span><span class="p">,</span> <span class="nv">SUM</span><span class="p">,</span> <span class="nv">NZ</span>
    	<span class="nf">GOTO</span>    <span class="nv">EXIT</span>
   		 <span class="err">…</span>
    	<span class="c1">;宏展开</span>
    	<span class="nf">MOV</span>    <span class="nb">CX</span><span class="p">,</span> <span class="nv">SUM</span>
<span class="nl">NEXT:</span>   <span class="nf">DEC</span>    <span class="nb">CX</span>
    	<span class="nf">ADD</span>    <span class="nv">SUM</span><span class="p">,</span> <span class="nb">CX</span>
    	<span class="nf">AND</span>    <span class="nb">CX</span><span class="p">,</span> <span class="nb">CX</span>
    	<span class="nf">JNZ</span>    <span class="nv">NEXT</span>
    	<span class="nf">JMP</span>    <span class="nv">EXIT</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<hr>

<h2 id="heading-练习">练习</h2>

<ol>
  <li>
    <p>如何将AX寄存器清零</p>
  </li>
  <li>
    <p>比较REP指令与LOOP指令：循环类型、影响标志位？</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">MOV  BX,OFFEST  LIST</code>与<code class="language-plaintext highlighter-rouge">LEA  BX, LIST</code>的区别？</p>

    <p>OFFSET属于运算符，在汇编时完成，属于立即寻址<br>
 LEA则是在程序运行时执行，属于直接寻址</p>
  </li>
  <li>
    <p>下面的代码完成了什么操作？如果直接执行<code class="language-plaintext highlighter-rouge">mov ax, dvar</code>会怎么样？</p>

    <div class="language-nasm highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="nf">.MODEL</span> <span class="nv">SMALL</span>
        <span class="nf">.DATA</span>
<span class="nf">dvar</span>    <span class="nv">dd</span>    <span class="mh">12347777h</span><span class="p">,</span> <span class="mh">87651111h</span><span class="p">,</span> <span class="nv">?</span>
        <span class="nf">.CODE</span>
<span class="nl">START:</span>  <span class="nf">mov</span>        <span class="nb">ax</span><span class="p">,</span><span class="err">@</span><span class="nv">data</span>
        <span class="nf">mov</span>        <span class="nb">ds</span><span class="p">,</span><span class="nb">ax</span>
        <span class="nf">mov</span>        <span class="nb">ax</span><span class="p">,</span> <span class="kt">word</span> <span class="nv">ptr</span> <span class="nv">dvar</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>    <span class="c1">;ax=7777h</span>
        <span class="nf">mov</span>        <span class="nb">dx</span><span class="p">,</span> <span class="kt">word</span> <span class="nv">ptr</span> <span class="nv">dvar</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>    <span class="c1">;dx=1234h</span>
        <span class="nf">add</span>        <span class="nb">ax</span><span class="p">,</span> <span class="kt">word</span> <span class="nv">ptr</span> <span class="nv">dvar</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>    <span class="c1">;ax=8888h</span>
        <span class="nf">adc</span>        <span class="nb">dx</span><span class="p">,</span> <span class="kt">word</span> <span class="nv">ptr</span> <span class="nv">dvar</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>    <span class="c1">;dx=9999h</span>
        <span class="nf">mov</span>        <span class="kt">word</span> <span class="nv">ptr</span> <span class="nv">dvar</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span> <span class="nb">ax</span>    <span class="c1">;dvar[8]=88h dvar[9]=88h</span>
        <span class="nf">mov</span>        <span class="kt">word</span> <span class="nv">ptr</span> <span class="nv">dvar</span><span class="p">[</span><span class="mi">10</span><span class="p">],</span> <span class="nb">dx</span>   <span class="c1">;dvar[10]=99h dvar[11]=99h</span>
        <span class="nf">mov</span>        <span class="nb">ax</span><span class="p">,</span> <span class="nv">dvar</span>                <span class="c1">;ax=7777h(warning)</span>
<span class="nl">OVER:</span>   <span class="nf">MOV</span>        <span class="nb">AX</span><span class="p">,</span> <span class="mh">4C00H</span>
        <span class="nf">INT</span>        <span class="mh">21H</span>
        <span class="nf">END</span>        <span class="nv">START</span>
</code></pre></div>    </div>

    <p>小端存储，它是这样存的：</p>

    <table>
      <thead>
        <tr>
          <th style="text-align: center">
<p> </p>
</th>
          <th style="text-align: center">
<p> </p>
</th>
          <th style="text-align: center">
<p>高地址</p>
</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td style="text-align: center">
<p> </p>
</td>
          <td style="text-align: center">
<p> </p>
</td>
          <td style="text-align: center">
<p> </p>
</td>
        </tr>
        <tr>
          <td style="text-align: center">
<p> </p>
</td>
          <td style="text-align: center">
<p> </p>
</td>
          <td style="text-align: center">
<p> </p>
</td>
        </tr>
        <tr>
          <td style="text-align: center">
<p> </p>
</td>
          <td style="text-align: center">
<p> </p>
</td>
          <td style="text-align: center">
<p> </p>
</td>
        </tr>
        <tr>
          <td style="text-align: center">
<p>87H</p>
</td>
          <td style="text-align: center">
<p>dvar[7]</p>
</td>
          <td style="text-align: center">
<p> </p>
</td>
        </tr>
        <tr>
          <td style="text-align: center">
<p>65H</p>
</td>
          <td style="text-align: center">
<p>dvar[6]</p>
</td>
          <td style="text-align: center">
<p> </p>
</td>
        </tr>
        <tr>
          <td style="text-align: center">
<p>11H</p>
</td>
          <td style="text-align: center">
<p>dvar[5]</p>
</td>
          <td style="text-align: center">
<p> </p>
</td>
        </tr>
        <tr>
          <td style="text-align: center">
<p>11H</p>
</td>
          <td style="text-align: center">
<p>dvar[4]</p>
</td>
          <td style="text-align: center">
<p> </p>
</td>
        </tr>
        <tr>
          <td style="text-align: center">
<p>12H</p>
</td>
          <td style="text-align: center">
<p>dvar[3]</p>
</td>
          <td style="text-align: center">
<p> </p>
</td>
        </tr>
        <tr>
          <td style="text-align: center">
<p>34H</p>
</td>
          <td style="text-align: center">
<p>dvar[2]</p>
</td>
          <td style="text-align: center">
<p> </p>
</td>
        </tr>
        <tr>
          <td style="text-align: center">
<p>77H</p>
</td>
          <td style="text-align: center">
<p>dvar[1]</p>
</td>
          <td style="text-align: center">
<p> </p>
</td>
        </tr>
        <tr>
          <td style="text-align: center">
<p>77H</p>
</td>
          <td style="text-align: center">
<p>dvar[0]</p>
</td>
          <td style="text-align: center">
<p>低地址</p>
</td>
        </tr>
      </tbody>
    </table>
  </li>
</ol>

                    </div>
                </div>
            </div>
            <footer class="unit-foot">
                <div class="unit-inner unit-foot-inner">
                    <div class="post-buttons">
                        <a class="internal gotop" href="#page" title="Back to Top">Back to Top</a>
                        
                    </div>
                    <nav class="pagination">
                        
                            <a class="internal" rel="prev" href="/blog/2019/12/14/assembly-8086/" title=" '【汇编与接口】 8086CPU结构'"> ← 【汇编与接口】 8086CPU结构</a>
                        
                        
                            <a class="internal" rel="next" href="/blog/2019/12/19/assembly-commonly-used/" title="Next Post '【汇编与接口】 常用知识汇总'">【汇编与接口】 常用知识汇总 → </a>
                        
                    </nav>
                </div>
            </footer>
            <div class="misc-content">
                
            </div>
        </div>
    </div>
</article>

                    </div>
                </div>
            </div>
        </div>
        <footer class="the-footer">
    <div class="unit-foot">
        <div class="unit-inner unit-foot-inner">
            <div class="misc vcard">
                <div class="about">
                    <h4><a href="/">About</a></h4>
                    
                        <p>时间带走一切 读书带走时间</p>
                    
                    <p><small>Theme <a href="https://github.com/yizeng/jekyll-theme-simple-texture" target="_blank">Simple Texture</a> , powered by <a href="https://jekyllrb.com/" target="_blank">Jekyll</a>.</small></p>
                </div>
                <div class="social-links">
                    
                        <a class="ico-gmail" href="mailto:hitsyw2017@163.com" rel="me" target="_blank" title="email"></a>
                    
                    <a class="ico-rss" href="/feed.xml" rel="me" target="_blank" title="feed"></a>
                    
                        
                    
                        
                            <a class="ico-github" href="https://github.com/suniven" rel="me" target="_blank" title="github"></a>
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                </div>
            </div>
        </div>
    </div>
    <a href="#" class="internal back-to-top">Back to Top</a>
</footer>

    </div>

    <script>
$(document).ready(function () {
    var offset = 50,
        duration = 500,
        width = 960;
    $(window).scroll(function () {
        if ($(window).width() > width) {
            if ($(this).scrollTop() > offset) {
                $('footer').css('top', '20px');
                $('footer .back-to-top').fadeIn(duration);
            } else {
                $('footer').css('top', 'auto');
                $('footer .back-to-top').fadeOut(duration);
            }
        }
    });
    $(window).resize(function () {
        if ($(window).width() < width) {
            $('footer').css('top', 'auto');
            $('footer .back-to-top').fadeOut(duration);
        }
        if ($(window).width() >= width && $(this).scrollTop() > offset) {
            $('footer').css('top', '20px');
            $('footer .back-to-top').fadeIn(duration);
        }
    });

    $('footer .back-to-top, .gotop').on('click', function (event) {
        event.preventDefault();
        $('html, body').animate({
            scrollTop: 0
        }, duration);
        return false;
    });

    $('.show-hidden').on('click', function () {
        $(this).parent().next().toggleClass("hidden");
        $(this).toggleClass("hidden");
    });
});
</script>

<!-- Show menu overlay + Jekyll Simple Search option -->
<script src="/assets/javascripts/jekyll-search.jquery.js"></script>
<script>
$(document).ready(function () {
    $('.search-field').simpleJekyllSearch({
      jsonFile: '/search.json',
      template: '<li><a href="{url}">{title} <span class="entry-date"><time datetime="{date}">{shortdate}</time></span></a></li>',
      searchResults: '.search-wrapper .results',
      searchResultsTitle: '<h4>Search results</h4>',
      noResults: '<p>Oh shucks<br/><small>Nothing found :(</small></p>'
    });
});

(function ($, window, undefined) {
    var closeOverlay = function () {
        $('.nav-wrapper, .search-wrapper').removeAttr('style');
        $(".nav-form, .search-form").removeClass('active');
        $("body").removeClass('nav-overlay search-overlay');
    };

    $('.nav-global .btn-search').on('click', function () {
        $('.search-wrapper').css({display: "block"});
        $(".search-form").addClass('active');
        $(".search-form").find('input').focus();
        $("body").addClass('search-overlay');
    });

    $('.nav-global .btn-menu').on('click', function () {
        $('.nav-wrapper').css({display: "block"});
        $(".nav-form").addClass('active');
        $(".nav-form .search-field").prop('disabled', true);
        $("body").addClass('nav-overlay');
    });

    $('.nav-wrapper .btn-close, .search-wrapper .btn-close').on('click', function () {
        closeOverlay();
    });

    $(document).on('keyup', function (e) {
        if (e.keyCode === 27) {
            closeOverlay();
        }
    });
})(jQuery, window);
</script>

<script src="//cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/jquery.fancybox.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/helpers/jquery.fancybox-buttons.min.js"></script>
<script src="/assets/javascripts/unveil/jquery.unveil.min.js"></script>

<script>
    window.jQuery.fancybox || document.write('<script src="/assets/javascripts/fancybox/jquery.fancybox.pack.js?v=2.1.4"><\/script>')
    window.jQuery.fancybox.helpers.buttons || document.write('<script src="/assets/javascripts/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"><\/script>')
</script>

<script>
    $("head").append('<link rel="stylesheet" href="/assets/javascripts/fancybox/jquery.fancybox.css?v=2.1.4" type="text/css" />');
    $("head").append('<link rel="stylesheet" href="/assets/javascripts/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" />');
    $(".post-image").fancybox({
        prevEffect: 'none',
        nextEffect: 'none',
        closeBtn: true,
        helpers: {
            title: {
                type: 'float'
            }
        }
    });
    $(document).ready(function () {
        $(".post-image > img").unveil(450);
    });
</script>

</body>

</html>
