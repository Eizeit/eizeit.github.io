<!DOCTYPE html>
<html>
  <head>
  <title>【数据结构/算法】 KMP算法（第四章、串） – 今天又刷了什么水题 – 为者常成，行者常至</title>

      <meta charset="utf-8" />
    <meta content='text/html; charset=utf-8' http-equiv='Content-Type'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0'>

    
    <meta name="description" content="因为KMP每次用的时候都要看一遍，还是没有透彻理解，所以这里记录一下。数据结构统考中一般只以选择题形式出现，考查Next数组的计算，会手推即可。

相关概念


  
    前缀

    除了最后一个字符以外，该字符串的所有头部子串
  
  
    后缀

    除了第一个字符以外，该字符串的所有尾部子串
  
  
    部分匹配值

    部分匹配值是一个字符串的前缀和后缀的最长的共有元素的长度，即最长公共前后缀的长度。

    

    如：字符串 “$ ABCDABD $”

    
      ”$ A $” ：前缀后缀都为空集，部分匹配值为 $ 0 $
      ”$ AB $” ：前缀为 $ \lbrace A \rbrace $ ，后缀为 $ \lbrace B \rbrace $ ，部分匹配值为 $ 0 $
      ”$ ABC $” ：前缀为 $ \lbrace A,AB \rbrace $ ，后缀为 $ \lbrace BC,B \rbrace $ ，部分匹配值为 $ 0 $
      ”$ ABCD $” ：前缀为 $ \lbrace A,AB,ABC \rbrace $ ，后缀为 $ \lbrace BCD,BC,B \rbrace $ ，部分匹配值为 $ 0 $
      ”$ ABCDA $” ：前缀为 $ \lbrace A,AB,ABC,ABCD \rbrace $ ，后缀为 $ \lbrace BCDA,CDA,DA,A \rbrace $ ，部分匹配值为 $ 1 $
      ”$ ABCDAB $” ：前缀为 $ \lbrace A,AB,ABC,ABCD,ABCDA \rbrace $ ，后缀为 $ \lbrace BCDAB,CDAB,DAB,AB,B \rbrace$ ，部分匹配值为 $ 2 $
      ”$ ABCDABD $” ：前缀为 $ \lbrace A,AB,ABC,ABCD,ABCDA,ABCDAB \rbrace $ ，后缀为 $ \lbrace BCDABD,CDABD,DAB,AB,B \rbrace $ ，部分匹配值为 $ 0 $
    

    

    虽然部分匹配值是相对于一个串的概念，为了后面方便计算，这里将各个部分匹配值记为每一位字符的部分匹配值，列成表格如下：

    
      
        
           
          A
          B
          C
          D
          A
          B
          D
        
      
      
        
          部分匹配值
          0
          0
          0
          0
          1
          2
          0
        
      
    

    

    部分匹配值的意义在于，当模式串的第 $i$ 个字符与主串不匹配时，咱们已经知道模式串前 $(i-1)$ 个字符的信息，KMP算法就是利用这个已知的信息避免主串的工作指针回退，只改变模式串的工作指针，从而提高算法效率，KMP算法的时间复杂度是 $O(m+n)$ 。

    模式串的第 $i$ 个字符不匹配时，根据最后一个匹配的字符（第 $(i-1)$ 个字符）的部分匹配值可以算出模式串向后移动的位数：

    记第 $i$ 个字符对应的部分匹配值为 $f(i)$ ，移动位数为 $move$，则有

\[move = (i-1)- f(i-1)\]

    即 移动位数=已匹配的字符数-最后一个匹配的字符对应的部分匹配值

    发生不匹配时，模式串向后移动move位后与主串的当前位继续比较。

    

    关于部分匹配值，可以这么理解，模式字符串向后移动的时候保留多少位已经匹配过的字符，显然如果部分匹配值为0，就直接把模式字符串的头移动到不匹配的地方然后继续匹配就行，不用保留任何字符。如果部分匹配值为1，说明模式字符串最后一个字符和第一个字符相同，下一轮比较的时候保留一位，把模式字符串的第一个字符和这一位对齐后，因为这一位已经相等了，就可以跳过这一位了，直接从后一位继续比较。部分匹配值为其余值时同理。
  


Next数组的含义

前面为了便于理解，前面一直在说模式字符串怎么怎么移动，但是在实际程序中，模式字符串在内存里是不会动的，咱们改变的只是它的工作指针。

KMP算法的高效之处就在于比较过程中，主串的工作指针 i （i指向主串的第 $i$ 个字符）一直 i++ （匹配）或不变（不匹配），不会发生BF中的回溯情况，模式字符串的工作指针 j （j指向主串的第 $j$ 个字符）根据当前位的比较结果进行 j++ （匹配）或跳转 j=next[j] （不匹配）。Next数组就是指示模式字符串的工作指针在不匹配时如何进行跳转的数组。

next[j]=k的含义：

模式串中第 $j$ 个字符与主串中第 $i$ 个字符不匹配时，模式串的工作指针需要跳转到的位置，和主串的第 $i$ 个字符继续比较。



从前面可以知道：


  当模式串的第 $1$ 个字符不匹配时，进行操作j=next[1]=0，然后进入下一轮循环，判断j==0后对应的操作是主串的工作指针++、模式串的工作指针++，这样就指向第 $1$ 位，然后进入下一轮循环和主串的当前位比较。将 next[1] 赋值为0是KMP迭代的基础，表示头一个字符就不匹配的情况。这里结合最后的应用代码的KMP函数就比较好理解了。
  当模式串的第 $j(j \ge 2)$ 个字符不匹配时，对应的操作是主串工作指针不变，模式串的工作指针跳转到第 next[j] 个字符处，然后继续比较。这里 next[j] 显然就是前 $(j-1)$ 个字符组成的字符串的最长公共前后缀的长度 $+1$ 。同时易得 next[2]=1 ，因为单个字符的部分匹配值为 $0$ ， $0+1=1$ ，没有公共前后缀的时候 next[j] 也为 $1$ 。




记 $ f(j) = $ 前 $(j-1)$ 个字符的最大公共前后缀长度，字符串下标从 $1$ 开始计算，则有：

\[\begin{equation}
next[j]=\left\{
\begin{array}{rcl}
0 &amp; &amp; {j = 1}\\
f(j) &amp; &amp; {j \ge 2}
\end{array} \right.
\end{equation}\]

求 Next 数组的方法

考试的时候直接比划比划就出来了，还是比较简单的，408统考的话应该不会考代码。

KMP算法的时间复杂度是 $O(m+n)$。（主串长度n，模式串长度m）

下面上代码（下标从 0 开始，只要理解了原理不管从 0 开始还是从 1 开始都很好理解）

/*
next的计算思想如前所述
不过这里字符串数组下标从0开始计算
上面的讲述以及严奶奶教材里是从1开始的，所以本代码的next公式为：
next[j]=
        max{k|j之前的串的最长共同前后缀的长度} //因为从0开始算，直接取最长的长度即可，不用+1
        -1，j=0  表示j=0时候，j之前肯定是空串。
*/
void get_next(SString T,int next[])
{
    int j=0,k=-1;   // j=0时k=-1，表示j之前不存在最长的前后缀串，即next[0]=-1
    next[0]=-1; // 这种情况下表示一开始就匹配不上，对应上面讲的第一种情况，对应操作是i后移，j指向模式串头
    while(j&lt;strlen(T))  // 这段是精华啊精华
    {
        // T[0]...T[j]的next值都求完了
        // 如果上一轮刚得到next值，这里的k是T[j]的next值，即前j个的字符组成的串的最长公共前后缀长度
        if(k==-1||T[j]==T[k]) // T[j]==T[k]的意思就是，因为要求next[j+1]，那么考查的是前j+1个字符，T[j]就是第j+1个字符，那么显然T[k]是前j个字符组成的串的最长公共前后缀的那个前缀的后面一个字符，T[j]是那个后缀的后一个字符，如果这俩相等，那么next[j+1]=k+1
        {
            next[++j]=++k;  // j++,k++,next[j]=k;
            // 在next[j]=k的情况下,如果T[j]==T[k],则next[j+1]=k+1
            // 或者k=-1时，next[j+1]=0，表示j&gt;0时候不存在相同的最长前后缀串，++k后k=0
        }
        else k=next[k]; // 如果T[j]!=T[k]，k跳转到next[k]继续循环匹配。
                        // 这里的思想是用前缀T[0]...T[k](看成模式串)与后缀T[j-k+1]...T[j](看成主串)进行模式匹配，将前缀向右迭代滑动直到找到某个更短的前缀满足T[0]...T[k']==T[j-k'+1]...T[j]
    }
}


求 Next 数组改进版算法

考虑下面这种情况：

S = "aaabaaabaaabaaabaaab"

P = "aaaab"

改进前：next[j]=-1 0 1 2 3（下标从0开始），S[3]与P[3]不匹配时，按照之前的next值，下一次S[3]和P[2]比较，不匹配，下下次s[3]和P[1]比较，不匹配，后面还要再比较2次，而这几次S[3]一直都是和’a’比较，显然咱们第一次就知道S[3]和’a’不等，这样重复的比较是没有意义的。

出现这种现象的原因就是：若有P[j]=P[next[j]]，即模式串当前失配字符与模式串根据next数组找到的下一个要被匹配的字符相同，那么显然会继续失配，由此提出KMP算法的改进版本。

如果出现上面的情况，则一直将next[j]修正为next[next[j]]，直到两者不相等，通常将此种改进版的next数组更名为nextval。

优化后：nextval[j]=-1 -1 -1 -1 3

改进版求next数组代码如下：

// 计算next值的优化算法，下标从0开始计算
void get_nextval(SString T,int next[])
{
    int j=0, k=-1;  // 
    next[0]=-1; // 表示一开始就匹配不上，是迭代计算next值的基础
    while(j&lt;strlen(T))
    {
        if(k==-1||T[j]==T[k])
        {
            j++,k++;
            if(T[j]!=T[k])
                next[j]=k;
            else
                next[j]=next[k];
        }
        else
            k=next[k];  //如果T[j]!=T[k]，k跳转到next[k]继续循环匹配
    }
}

KMP完整版应用代码（改进版本）

#include&lt;iostream&gt;
#include&lt;string.h&gt;
using namespace std;

typedef char SString[255];//定义字符串类型SString

void get_nextval(SString T,int next[])
{
    int j=0, k=-1;  // 
    next[0]=-1; // 表示一开始就匹配不上，是迭代计算next值的基础
    while(j&lt;strlen(T))
    {
        if(k==-1||T[j]==T[k])
        {
            j++,k++;
            if(T[j]!=T[k])
                next[j]=k;
            else
                next[j]=next[k];
        }
        else
            k=next[k];  //如果T[j]!=T[k]，k跳转到next[k]继续循环匹配
    }
}

int KMP(SString A,SString B,int Pos)
{
    int i=Pos,j=0;
    int next[strlen(B)];  // 定义next数组
    get_nextval(B,next);  // 改进版计算next数组的值
    for(int m=0;m&lt;strlen(B);m++)
        cout&lt;&lt;next[m]&lt;&lt;" ";
    while(i&lt;strlen(A)&amp;&amp;j&lt;strlen(B))
    {
        if(j==-1||A[i]==B[j])
        {
            i++,j++;
        }
        else
            j=next[j];
    }
    if(j==strlen(B))
        return i-j;
    else
        return -1;
}

int main()
{
    SString S,T;
    cout&lt;&lt;"Input mainstring S:";
    cin&gt;&gt;S;
    cout&lt;&lt;"Intput substring T:";
    cin&gt;&gt;T;
    cout&lt;&lt;"The match position = "&lt;&lt;KMP(S,T,0)&lt;&lt;endl;
    return 0;
}


KMP算法较之BF算法的优势


  KMP算法的时间复杂度为$O(m+n)$，BF算法的时间复杂度为$O(m*n)$
  KMP算法中主串的工作指针不需要回溯
  KMP算法只需要考虑模式串
  KMP算法中主串指针不需回溯意味着对于规模较大的外存中的字符串的匹配操作可以分段进行，先读入一部分到内存然后完成匹配后写回外存，可以保证发生不匹配时不需要将之前写回外存的部分再次读入，减少了I/O操作，提高了效率。

" />
    <meta property="og:description" content="因为KMP每次用的时候都要看一遍，还是没有透彻理解，所以这里记录一下。数据结构统考中一般只以选择题形式出现，考查Next数组的计算，会手推即可。

相关概念


  
    前缀

    除了最后一个字符以外，该字符串的所有头部子串
  
  
    后缀

    除了第一个字符以外，该字符串的所有尾部子串
  
  
    部分匹配值

    部分匹配值是一个字符串的前缀和后缀的最长的共有元素的长度，即最长公共前后缀的长度。

    

    如：字符串 “$ ABCDABD $”

    
      ”$ A $” ：前缀后缀都为空集，部分匹配值为 $ 0 $
      ”$ AB $” ：前缀为 $ \lbrace A \rbrace $ ，后缀为 $ \lbrace B \rbrace $ ，部分匹配值为 $ 0 $
      ”$ ABC $” ：前缀为 $ \lbrace A,AB \rbrace $ ，后缀为 $ \lbrace BC,B \rbrace $ ，部分匹配值为 $ 0 $
      ”$ ABCD $” ：前缀为 $ \lbrace A,AB,ABC \rbrace $ ，后缀为 $ \lbrace BCD,BC,B \rbrace $ ，部分匹配值为 $ 0 $
      ”$ ABCDA $” ：前缀为 $ \lbrace A,AB,ABC,ABCD \rbrace $ ，后缀为 $ \lbrace BCDA,CDA,DA,A \rbrace $ ，部分匹配值为 $ 1 $
      ”$ ABCDAB $” ：前缀为 $ \lbrace A,AB,ABC,ABCD,ABCDA \rbrace $ ，后缀为 $ \lbrace BCDAB,CDAB,DAB,AB,B \rbrace$ ，部分匹配值为 $ 2 $
      ”$ ABCDABD $” ：前缀为 $ \lbrace A,AB,ABC,ABCD,ABCDA,ABCDAB \rbrace $ ，后缀为 $ \lbrace BCDABD,CDABD,DAB,AB,B \rbrace $ ，部分匹配值为 $ 0 $
    

    

    虽然部分匹配值是相对于一个串的概念，为了后面方便计算，这里将各个部分匹配值记为每一位字符的部分匹配值，列成表格如下：

    
      
        
           
          A
          B
          C
          D
          A
          B
          D
        
      
      
        
          部分匹配值
          0
          0
          0
          0
          1
          2
          0
        
      
    

    

    部分匹配值的意义在于，当模式串的第 $i$ 个字符与主串不匹配时，咱们已经知道模式串前 $(i-1)$ 个字符的信息，KMP算法就是利用这个已知的信息避免主串的工作指针回退，只改变模式串的工作指针，从而提高算法效率，KMP算法的时间复杂度是 $O(m+n)$ 。

    模式串的第 $i$ 个字符不匹配时，根据最后一个匹配的字符（第 $(i-1)$ 个字符）的部分匹配值可以算出模式串向后移动的位数：

    记第 $i$ 个字符对应的部分匹配值为 $f(i)$ ，移动位数为 $move$，则有

\[move = (i-1)- f(i-1)\]

    即 移动位数=已匹配的字符数-最后一个匹配的字符对应的部分匹配值

    发生不匹配时，模式串向后移动move位后与主串的当前位继续比较。

    

    关于部分匹配值，可以这么理解，模式字符串向后移动的时候保留多少位已经匹配过的字符，显然如果部分匹配值为0，就直接把模式字符串的头移动到不匹配的地方然后继续匹配就行，不用保留任何字符。如果部分匹配值为1，说明模式字符串最后一个字符和第一个字符相同，下一轮比较的时候保留一位，把模式字符串的第一个字符和这一位对齐后，因为这一位已经相等了，就可以跳过这一位了，直接从后一位继续比较。部分匹配值为其余值时同理。
  


Next数组的含义

前面为了便于理解，前面一直在说模式字符串怎么怎么移动，但是在实际程序中，模式字符串在内存里是不会动的，咱们改变的只是它的工作指针。

KMP算法的高效之处就在于比较过程中，主串的工作指针 i （i指向主串的第 $i$ 个字符）一直 i++ （匹配）或不变（不匹配），不会发生BF中的回溯情况，模式字符串的工作指针 j （j指向主串的第 $j$ 个字符）根据当前位的比较结果进行 j++ （匹配）或跳转 j=next[j] （不匹配）。Next数组就是指示模式字符串的工作指针在不匹配时如何进行跳转的数组。

next[j]=k的含义：

模式串中第 $j$ 个字符与主串中第 $i$ 个字符不匹配时，模式串的工作指针需要跳转到的位置，和主串的第 $i$ 个字符继续比较。



从前面可以知道：


  当模式串的第 $1$ 个字符不匹配时，进行操作j=next[1]=0，然后进入下一轮循环，判断j==0后对应的操作是主串的工作指针++、模式串的工作指针++，这样就指向第 $1$ 位，然后进入下一轮循环和主串的当前位比较。将 next[1] 赋值为0是KMP迭代的基础，表示头一个字符就不匹配的情况。这里结合最后的应用代码的KMP函数就比较好理解了。
  当模式串的第 $j(j \ge 2)$ 个字符不匹配时，对应的操作是主串工作指针不变，模式串的工作指针跳转到第 next[j] 个字符处，然后继续比较。这里 next[j] 显然就是前 $(j-1)$ 个字符组成的字符串的最长公共前后缀的长度 $+1$ 。同时易得 next[2]=1 ，因为单个字符的部分匹配值为 $0$ ， $0+1=1$ ，没有公共前后缀的时候 next[j] 也为 $1$ 。




记 $ f(j) = $ 前 $(j-1)$ 个字符的最大公共前后缀长度，字符串下标从 $1$ 开始计算，则有：

\[\begin{equation}
next[j]=\left\{
\begin{array}{rcl}
0 &amp; &amp; {j = 1}\\
f(j) &amp; &amp; {j \ge 2}
\end{array} \right.
\end{equation}\]

求 Next 数组的方法

考试的时候直接比划比划就出来了，还是比较简单的，408统考的话应该不会考代码。

KMP算法的时间复杂度是 $O(m+n)$。（主串长度n，模式串长度m）

下面上代码（下标从 0 开始，只要理解了原理不管从 0 开始还是从 1 开始都很好理解）

/*
next的计算思想如前所述
不过这里字符串数组下标从0开始计算
上面的讲述以及严奶奶教材里是从1开始的，所以本代码的next公式为：
next[j]=
        max{k|j之前的串的最长共同前后缀的长度} //因为从0开始算，直接取最长的长度即可，不用+1
        -1，j=0  表示j=0时候，j之前肯定是空串。
*/
void get_next(SString T,int next[])
{
    int j=0,k=-1;   // j=0时k=-1，表示j之前不存在最长的前后缀串，即next[0]=-1
    next[0]=-1; // 这种情况下表示一开始就匹配不上，对应上面讲的第一种情况，对应操作是i后移，j指向模式串头
    while(j&lt;strlen(T))  // 这段是精华啊精华
    {
        // T[0]...T[j]的next值都求完了
        // 如果上一轮刚得到next值，这里的k是T[j]的next值，即前j个的字符组成的串的最长公共前后缀长度
        if(k==-1||T[j]==T[k]) // T[j]==T[k]的意思就是，因为要求next[j+1]，那么考查的是前j+1个字符，T[j]就是第j+1个字符，那么显然T[k]是前j个字符组成的串的最长公共前后缀的那个前缀的后面一个字符，T[j]是那个后缀的后一个字符，如果这俩相等，那么next[j+1]=k+1
        {
            next[++j]=++k;  // j++,k++,next[j]=k;
            // 在next[j]=k的情况下,如果T[j]==T[k],则next[j+1]=k+1
            // 或者k=-1时，next[j+1]=0，表示j&gt;0时候不存在相同的最长前后缀串，++k后k=0
        }
        else k=next[k]; // 如果T[j]!=T[k]，k跳转到next[k]继续循环匹配。
                        // 这里的思想是用前缀T[0]...T[k](看成模式串)与后缀T[j-k+1]...T[j](看成主串)进行模式匹配，将前缀向右迭代滑动直到找到某个更短的前缀满足T[0]...T[k']==T[j-k'+1]...T[j]
    }
}


求 Next 数组改进版算法

考虑下面这种情况：

S = "aaabaaabaaabaaabaaab"

P = "aaaab"

改进前：next[j]=-1 0 1 2 3（下标从0开始），S[3]与P[3]不匹配时，按照之前的next值，下一次S[3]和P[2]比较，不匹配，下下次s[3]和P[1]比较，不匹配，后面还要再比较2次，而这几次S[3]一直都是和’a’比较，显然咱们第一次就知道S[3]和’a’不等，这样重复的比较是没有意义的。

出现这种现象的原因就是：若有P[j]=P[next[j]]，即模式串当前失配字符与模式串根据next数组找到的下一个要被匹配的字符相同，那么显然会继续失配，由此提出KMP算法的改进版本。

如果出现上面的情况，则一直将next[j]修正为next[next[j]]，直到两者不相等，通常将此种改进版的next数组更名为nextval。

优化后：nextval[j]=-1 -1 -1 -1 3

改进版求next数组代码如下：

// 计算next值的优化算法，下标从0开始计算
void get_nextval(SString T,int next[])
{
    int j=0, k=-1;  // 
    next[0]=-1; // 表示一开始就匹配不上，是迭代计算next值的基础
    while(j&lt;strlen(T))
    {
        if(k==-1||T[j]==T[k])
        {
            j++,k++;
            if(T[j]!=T[k])
                next[j]=k;
            else
                next[j]=next[k];
        }
        else
            k=next[k];  //如果T[j]!=T[k]，k跳转到next[k]继续循环匹配
    }
}

KMP完整版应用代码（改进版本）

#include&lt;iostream&gt;
#include&lt;string.h&gt;
using namespace std;

typedef char SString[255];//定义字符串类型SString

void get_nextval(SString T,int next[])
{
    int j=0, k=-1;  // 
    next[0]=-1; // 表示一开始就匹配不上，是迭代计算next值的基础
    while(j&lt;strlen(T))
    {
        if(k==-1||T[j]==T[k])
        {
            j++,k++;
            if(T[j]!=T[k])
                next[j]=k;
            else
                next[j]=next[k];
        }
        else
            k=next[k];  //如果T[j]!=T[k]，k跳转到next[k]继续循环匹配
    }
}

int KMP(SString A,SString B,int Pos)
{
    int i=Pos,j=0;
    int next[strlen(B)];  // 定义next数组
    get_nextval(B,next);  // 改进版计算next数组的值
    for(int m=0;m&lt;strlen(B);m++)
        cout&lt;&lt;next[m]&lt;&lt;" ";
    while(i&lt;strlen(A)&amp;&amp;j&lt;strlen(B))
    {
        if(j==-1||A[i]==B[j])
        {
            i++,j++;
        }
        else
            j=next[j];
    }
    if(j==strlen(B))
        return i-j;
    else
        return -1;
}

int main()
{
    SString S,T;
    cout&lt;&lt;"Input mainstring S:";
    cin&gt;&gt;S;
    cout&lt;&lt;"Intput substring T:";
    cin&gt;&gt;T;
    cout&lt;&lt;"The match position = "&lt;&lt;KMP(S,T,0)&lt;&lt;endl;
    return 0;
}


KMP算法较之BF算法的优势


  KMP算法的时间复杂度为$O(m+n)$，BF算法的时间复杂度为$O(m*n)$
  KMP算法中主串的工作指针不需要回溯
  KMP算法只需要考虑模式串
  KMP算法中主串指针不需回溯意味着对于规模较大的外存中的字符串的匹配操作可以分段进行，先读入一部分到内存然后完成匹配后写回外存，可以保证发生不匹配时不需要将之前写回外存的部分再次读入，减少了I/O操作，提高了效率。

" />
    
    <meta name="author" content="今天又刷了什么水题" />

    
    <meta property="og:title" content="【数据结构/算法】 KMP算法（第四章、串）" />
    <meta property="twitter:title" content="【数据结构/算法】 KMP算法（第四章、串）" />
    
  <!-- Async font loading -->
<script>
  window.WebFontConfig = {
      custom: {
          families: ['Spoqa Han Sans:100,300,400,700'],
          urls: ['https://spoqa.github.io/spoqa-han-sans/css/SpoqaHanSans-kr.css']
      },
      timeout: 60000
  };
  (function(d) {
      var wf = d.createElement('script'), s = d.scripts[0];
      wf.src = 'https://ajax.googleapis.com/ajax/libs/webfont/1.5.18/webfont.js';
      s.parentNode.insertBefore(wf, s);
  })(document);
</script>

<!--adobe fonts-->
<script>
    (function(d) {
      var config = {
        kitId: 'vbt3gjx',
        scriptTimeout: 3000,
        async: true
      },
      h=d.documentElement,t=setTimeout(function(){h.className=h.className.replace(/\bwf-loading\b/g,"")+" wf-inactive";},config.scriptTimeout),tk=d.createElement("script"),f=false,s=d.getElementsByTagName("script")[0],a;h.className+=" wf-loading";tk.src='https://use.typekit.net/'+config.kitId+'.js';tk.async=true;tk.onload=tk.onreadystatechange=function(){a=this.readyState;if(f||a&&a!="complete"&&a!="loaded")return;f=true;clearTimeout(t);try{Typekit.load(config)}catch(e){}};s.parentNode.insertBefore(tk,s)
    })(document);
</script> 

  <!--[if lt IE 9]>
    <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link rel="stylesheet" type="text/css" href="/style.css" />
  <link rel="alternate" type="application/rss+xml" title="今天又刷了什么水题 - 为者常成，行者常至" href="/feed.xml" />
  <link rel="shortcut icon" href="/favicon.ico">
  <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
  <script src="https://unpkg.com/feather-icons"></script>
  <script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
        inlineMath: [['$','$']]
      }
    });
  </script>

  <!-- Created with Jekyll Now - http://github.com/barryclark/jekyll-now -->

</head>

  <body>
    <div class="wrapper-sidebar">
  <header class="sidebar clearfix">
    <div class="site-info">
      
        <a href="/" class="site-avatar"><img src="/logo.jpg" /></a>
       
      <h1 class="site-name"><a href="/">今天又刷了什么水题</a></h1>
      <p class="site-description">为者常成，行者常至</p>
    </div>
  </header>

  <div class="navlist">
    <nav>
      
      
      <a href="/">首页</a>
      
      
      
      <a href="/about">关于</a>
      
      
      
      <a href="/archive">归档</a>
      
      
      
      <a href="/tags">标签</a>
      
      
      
      <a href="/categories">分类</a>
      
      
    </nav>
  </div>

  <div class="wrapper-footer-desktop">
    <footer class="footer">
      <!-- Refer to https://codepen.io/ruandre/pen/howFi -->
<ul class="svg-icon">

  
  
  

  

  
  <li><a href="mailto:hiter_sun@163.com" class="icon-8 email" title="Email"><svg viewBox="0 0 512 512"><path d="M502.3 190.8c3.9-3.1 9.7-.2 9.7 4.7V400c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V195.6c0-5 5.7-7.8 9.7-4.7 22.4 17.4 52.1 39.5 154.1 113.6 21.1 15.4 56.7 47.8 92.2 47.6 35.7.3 72-32.8 92.3-47.6 102-74.1 131.6-96.3 154-113.7zM256 320c23.2.4 56.6-29.2 73.4-41.4 132.7-96.3 142.8-104.7 173.4-128.7 5.8-4.5 9.2-11.5 9.2-18.9v-19c0-26.5-21.5-48-48-48H48C21.5 64 0 85.5 0 112v19c0 7.4 3.4 14.3 9.2 18.9 30.6 23.9 40.7 32.4 173.4 128.7 16.8 12.2 50.2 41.8 73.4 41.4z"/></svg><!--[if lt IE 9]><em>Email</em><![endif]--></a></li>
  

  

  

  
  <li><a href="https://github.com/suniven" class="icon-13 github" title="GitHub"><svg viewBox="0 0 512 512"><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg><!--[if lt IE 9]><em>GitHub</em><![endif]--></a></li>
  

  

  

  

  
  <li><a href="/feed.xml" class="icon-21 rss" title="RSS"><svg viewBox="0 0 512 512"><path d="M400 32H48C21.49 32 0 53.49 0 80v352c0 26.51 21.49 48 48 48h352c26.51 0 48-21.49 48-48V80c0-26.51-21.49-48-48-48zM112 416c-26.51 0-48-21.49-48-48s21.49-48 48-48 48 21.49 48 48-21.49 48-48 48zm157.533 0h-34.335c-6.011 0-11.051-4.636-11.442-10.634-5.214-80.05-69.243-143.92-149.123-149.123-5.997-.39-10.633-5.431-10.633-11.441v-34.335c0-6.535 5.468-11.777 11.994-11.425 110.546 5.974 198.997 94.536 204.964 204.964.352 6.526-4.89 11.994-11.425 11.994zm103.027 0h-34.334c-6.161 0-11.175-4.882-11.427-11.038-5.598-136.535-115.204-246.161-251.76-251.76C68.882 152.949 64 147.935 64 141.774V107.44c0-6.454 5.338-11.664 11.787-11.432 167.83 6.025 302.21 141.191 308.205 308.205.232 6.449-4.978 11.787-11.432 11.787z"/></svg><!--[if lt IE 9]><em>RSS</em><![endif]--></a></li>
  

  

  

  

  

</ul>



<p>Copyright (c) 2019-2021 From Gotei13 12th Div.</p>

    </footer>
  </div>
</div>

    
      <aside class="toc">
        <ul>
  <li><a href="#">【数据结构/算法】 KMP算法（第四章、串）</a>
    <ul>
      <li><a href="#相关概念">相关概念</a></li>
      <li><a href="#next数组的含义">Next数组的含义</a></li>
      <li><a href="#求-next-数组的方法">求 Next 数组的方法</a></li>
      <li><a href="#求-next-数组改进版算法">求 Next 数组改进版算法</a></li>
      <li><a href="#kmp完整版应用代码改进版本">KMP完整版应用代码（改进版本）</a></li>
      <li><a href="#kmp算法较之bf算法的优势">KMP算法较之BF算法的优势</a></li>
    </ul>
  </li>
</ul>
      </aside>
    

    <div id="main" role="main" class="wrapper-content">
      <div class="container">
        <article class="posts">
  <h1>【数据结构/算法】 KMP算法（第四章、串）</h1>

  <div clsss="meta">
    <span class="author">
      Sun
    </span>

    <span class="date">
      2020-08-14
    </span>

    <ul class="tag">
      
      <li>
        <a href="/tags#数据结构">
          数据结构
        </a>
      </li>
      
      <li>
        <a href="/tags#408">
          408
        </a>
      </li>
      
      <li>
        <a href="/tags#算法">
          算法
        </a>
      </li>
      
      <li>
        <a href="/tags#KMP算法">
          KMP算法
        </a>
      </li>
      
      <li>
        <a href="/tags#模式匹配">
          模式匹配
        </a>
      </li>
      
    </ul>
  </div>

  <div class="entry">
    <p>因为KMP每次用的时候都要看一遍，还是没有透彻理解，所以这里记录一下。数据结构统考中一般只以选择题形式出现，考查Next数组的计算，会手推即可。</p>

<h2 id="相关概念">相关概念</h2>

<ul>
  <li>
    <p>前缀</p>

    <p>除了最后一个字符以外，该字符串的所有头部子串</p>
  </li>
  <li>
    <p>后缀</p>

    <p>除了第一个字符以外，该字符串的所有尾部子串</p>
  </li>
  <li>
    <p>部分匹配值</p>

    <p>部分匹配值是一个字符串的前缀和后缀的最长的共有元素的长度，即最长公共前后缀的长度。</p>

    <p><br /></p>

    <p>如：字符串 “$ ABCDABD $”</p>

    <ul>
      <li>”$ A $” ：前缀后缀都为空集，部分匹配值为 $ 0 $</li>
      <li>”$ AB $” ：前缀为 $ \lbrace A \rbrace $ ，后缀为 $ \lbrace B \rbrace $ ，部分匹配值为 $ 0 $</li>
      <li>”$ ABC $” ：前缀为 $ \lbrace A,AB \rbrace $ ，后缀为 $ \lbrace BC,B \rbrace $ ，部分匹配值为 $ 0 $</li>
      <li>”$ ABCD $” ：前缀为 $ \lbrace A,AB,ABC \rbrace $ ，后缀为 $ \lbrace BCD,BC,B \rbrace $ ，部分匹配值为 $ 0 $</li>
      <li>”$ ABCDA $” ：前缀为 $ \lbrace A,AB,ABC,ABCD \rbrace $ ，后缀为 $ \lbrace BCDA,CDA,DA,A \rbrace $ ，部分匹配值为 $ 1 $</li>
      <li>”$ ABCDAB $” ：前缀为 $ \lbrace A,AB,ABC,ABCD,ABCDA \rbrace $ ，后缀为 $ \lbrace BCDAB,CDAB,DAB,AB,B \rbrace$ ，部分匹配值为 $ 2 $</li>
      <li>”$ ABCDABD $” ：前缀为 $ \lbrace A,AB,ABC,ABCD,ABCDA,ABCDAB \rbrace $ ，后缀为 $ \lbrace BCDABD,CDABD,DAB,AB,B \rbrace $ ，部分匹配值为 $ 0 $</li>
    </ul>

    <p><br /></p>

    <p>虽然部分匹配值是相对于一个串的概念，为了后面方便计算，这里将各个部分匹配值记为每一位字符的部分匹配值，列成表格如下：</p>

    <table>
      <thead>
        <tr>
          <th> </th>
          <th>A</th>
          <th>B</th>
          <th>C</th>
          <th>D</th>
          <th>A</th>
          <th>B</th>
          <th>D</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>部分匹配值</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>1</td>
          <td>2</td>
          <td>0</td>
        </tr>
      </tbody>
    </table>

    <p><br /></p>

    <p>部分匹配值的意义在于，当模式串的第 $i$ 个字符与主串不匹配时，咱们已经知道模式串前 $(i-1)$ 个字符的信息，KMP算法就是利用这个已知的信息避免主串的工作指针回退，只改变模式串的工作指针，从而提高算法效率，KMP算法的时间复杂度是 $O(m+n)$ 。</p>

    <p>模式串的第 $i$ 个字符不匹配时，根据最后一个匹配的字符（第 $(i-1)$ 个字符）的部分匹配值可以算出模式串向后移动的位数：</p>

    <p>记第 $i$ 个字符对应的部分匹配值为 $f(i)$ ，移动位数为 $move$，则有</p>

\[move = (i-1)- f(i-1)\]

    <p>即 <strong>移动位数=已匹配的字符数-最后一个匹配的字符对应的部分匹配值</strong></p>

    <p>发生不匹配时，模式串向后移动move位后与主串的当前位继续比较。</p>

    <p><br /></p>

    <p><strong>关于部分匹配值，可以这么理解，模式字符串向后移动的时候保留多少位已经匹配过的字符，显然如果部分匹配值为0，就直接把模式字符串的头移动到不匹配的地方然后继续匹配就行，不用保留任何字符。如果部分匹配值为1，说明模式字符串最后一个字符和第一个字符相同，下一轮比较的时候<em>保留一位</em>，把模式字符串的第一个字符和这一位对齐后，因为这一位已经相等了，就可以跳过这一位了，直接从后一位继续比较。部分匹配值为其余值时同理。</strong></p>
  </li>
</ul>

<h2 id="next数组的含义">Next数组的含义</h2>

<p>前面为了便于理解，前面一直在说模式字符串怎么怎么<strong>移动</strong>，但是在实际程序中，模式字符串在内存里是不会动的，咱们改变的只是它的工作指针。</p>

<p>KMP算法的高效之处就在于比较过程中，主串的工作指针 <code class="language-plaintext highlighter-rouge">i</code> （<code class="language-plaintext highlighter-rouge">i</code>指向主串的第 $i$ 个字符）一直 <code class="language-plaintext highlighter-rouge">i++</code> （匹配）或不变（不匹配），不会发生BF中的回溯情况，模式字符串的工作指针 <code class="language-plaintext highlighter-rouge">j</code> （<code class="language-plaintext highlighter-rouge">j</code>指向主串的第 $j$ 个字符）根据当前位的比较结果进行 <code class="language-plaintext highlighter-rouge">j++</code> （匹配）或跳转 <code class="language-plaintext highlighter-rouge">j=next[j]</code> （不匹配）。Next数组就是指示模式字符串的工作指针在不匹配时如何进行跳转的数组。</p>

<p><code class="language-plaintext highlighter-rouge">next[j]=k</code>的含义：</p>

<p>模式串中第 $j$ 个字符与主串中第 $i$ 个字符不匹配时，模式串的工作指针需要跳转到的位置，和主串的第 $i$ 个字符继续比较。</p>

<p><br /></p>

<p>从前面可以知道：</p>

<ul>
  <li>当模式串的第 $1$ 个字符不匹配时，进行操作<code class="language-plaintext highlighter-rouge">j=next[1]=0</code>，然后进入下一轮循环，判断<code class="language-plaintext highlighter-rouge">j==0</code>后对应的操作是主串的工作指针<code class="language-plaintext highlighter-rouge">++</code>、模式串的工作指针<code class="language-plaintext highlighter-rouge">++</code>，这样就指向第 $1$ 位，然后进入下一轮循环和主串的当前位比较。将 <code class="language-plaintext highlighter-rouge">next[1]</code> 赋值为0是KMP迭代的基础，表示头一个字符就不匹配的情况。这里结合最后的应用代码的KMP函数就比较好理解了。</li>
  <li>当模式串的第 $j(j \ge 2)$ 个字符不匹配时，对应的操作是主串工作指针不变，模式串的工作指针跳转到第 <code class="language-plaintext highlighter-rouge">next[j]</code> 个字符处，然后继续比较。这里 <code class="language-plaintext highlighter-rouge">next[j]</code> 显然就是前 $(j-1)$ 个字符组成的字符串的最长公共前后缀的长度 $+1$ 。同时易得 <code class="language-plaintext highlighter-rouge">next[2]=1</code> ，因为单个字符的部分匹配值为 $0$ ， $0+1=1$ ，没有公共前后缀的时候 <code class="language-plaintext highlighter-rouge">next[j]</code> 也为 $1$ 。</li>
</ul>

<p><br /></p>

<p>记 $ f(j) = $ 前 $(j-1)$ 个字符的最大公共前后缀长度，字符串下标从 $1$ 开始计算，则有：</p>

\[\begin{equation}
next[j]=\left\{
\begin{array}{rcl}
0 &amp; &amp; {j = 1}\\
f(j) &amp; &amp; {j \ge 2}
\end{array} \right.
\end{equation}\]

<h2 id="求-next-数组的方法">求 Next 数组的方法</h2>

<p>考试的时候直接比划比划就出来了，还是比较简单的，408统考的话应该不会考代码。</p>

<p>KMP算法的时间复杂度是 $O(m+n)$。（主串长度n，模式串长度m）</p>

<p>下面上代码（<strong>下标从 0 开始</strong>，只要理解了原理不管从 0 开始还是从 1 开始都很好理解）</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
next的计算思想如前所述
不过这里字符串数组下标从0开始计算
上面的讲述以及严奶奶教材里是从1开始的，所以本代码的next公式为：
next[j]=
        max{k|j之前的串的最长共同前后缀的长度} //因为从0开始算，直接取最长的长度即可，不用+1
        -1，j=0  表示j=0时候，j之前肯定是空串。
*/</span>
<span class="kt">void</span> <span class="nf">get_next</span><span class="p">(</span><span class="n">SString</span> <span class="n">T</span><span class="p">,</span><span class="kt">int</span> <span class="n">next</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">k</span><span class="o">=-</span><span class="mi">1</span><span class="p">;</span>   <span class="c1">// j=0时k=-1，表示j之前不存在最长的前后缀串，即next[0]=-1</span>
    <span class="n">next</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// 这种情况下表示一开始就匹配不上，对应上面讲的第一种情况，对应操作是i后移，j指向模式串头</span>
    <span class="k">while</span><span class="p">(</span><span class="n">j</span><span class="o">&lt;</span><span class="n">strlen</span><span class="p">(</span><span class="n">T</span><span class="p">))</span>  <span class="c1">// 这段是精华啊精华</span>
    <span class="p">{</span>
        <span class="c1">// T[0]...T[j]的next值都求完了</span>
        <span class="c1">// 如果上一轮刚得到next值，这里的k是T[j]的next值，即前j个的字符组成的串的最长公共前后缀长度</span>
        <span class="k">if</span><span class="p">(</span><span class="n">k</span><span class="o">==-</span><span class="mi">1</span><span class="o">||</span><span class="n">T</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">==</span><span class="n">T</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="c1">// T[j]==T[k]的意思就是，因为要求next[j+1]，那么考查的是前j+1个字符，T[j]就是第j+1个字符，那么显然T[k]是前j个字符组成的串的最长公共前后缀的那个前缀的后面一个字符，T[j]是那个后缀的后一个字符，如果这俩相等，那么next[j+1]=k+1</span>
        <span class="p">{</span>
            <span class="n">next</span><span class="p">[</span><span class="o">++</span><span class="n">j</span><span class="p">]</span><span class="o">=++</span><span class="n">k</span><span class="p">;</span>  <span class="c1">// j++,k++,next[j]=k;</span>
            <span class="c1">// 在next[j]=k的情况下,如果T[j]==T[k],则next[j+1]=k+1</span>
            <span class="c1">// 或者k=-1时，next[j+1]=0，表示j&gt;0时候不存在相同的最长前后缀串，++k后k=0</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="n">k</span><span class="o">=</span><span class="n">next</span><span class="p">[</span><span class="n">k</span><span class="p">];</span> <span class="c1">// 如果T[j]!=T[k]，k跳转到next[k]继续循环匹配。</span>
                        <span class="c1">// 这里的思想是用前缀T[0]...T[k](看成模式串)与后缀T[j-k+1]...T[j](看成主串)进行模式匹配，将前缀向右迭代滑动直到找到某个更短的前缀满足T[0]...T[k']==T[j-k'+1]...T[j]</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="求-next-数组改进版算法">求 Next 数组改进版算法</h2>

<p>考虑下面这种情况：</p>

<p><code class="language-plaintext highlighter-rouge">S = "aaabaaabaaabaaabaaab"</code></p>

<p><code class="language-plaintext highlighter-rouge">P = "aaaab"</code></p>

<p>改进前：<code class="language-plaintext highlighter-rouge">next[j]=-1 0 1 2 3</code>（下标从0开始），<code class="language-plaintext highlighter-rouge">S[3]</code>与<code class="language-plaintext highlighter-rouge">P[3]</code>不匹配时，按照之前的next值，下一次<code class="language-plaintext highlighter-rouge">S[3]</code>和<code class="language-plaintext highlighter-rouge">P[2]</code>比较，不匹配，下下次<code class="language-plaintext highlighter-rouge">s[3]</code>和<code class="language-plaintext highlighter-rouge">P[1]</code>比较，不匹配，后面还要再比较2次，而这几次<code class="language-plaintext highlighter-rouge">S[3]</code>一直都是和’a’比较，显然咱们第一次就知道<code class="language-plaintext highlighter-rouge">S[3]</code>和’a’不等，这样重复的比较是没有意义的。</p>

<p>出现这种现象的原因就是：若有<code class="language-plaintext highlighter-rouge">P[j]=P[next[j]]</code>，即模式串当前失配字符与模式串根据next数组找到的下一个要被匹配的字符相同，那么显然会继续失配，由此提出KMP算法的改进版本。</p>

<p>如果出现上面的情况，则一直将<code class="language-plaintext highlighter-rouge">next[j]</code>修正为<code class="language-plaintext highlighter-rouge">next[next[j]]</code>，直到两者不相等，通常将此种改进版的next数组更名为nextval。</p>

<p>优化后：<code class="language-plaintext highlighter-rouge">nextval[j]=-1 -1 -1 -1 3</code></p>

<p>改进版求next数组代码如下：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 计算next值的优化算法，下标从0开始计算</span>
<span class="kt">void</span> <span class="nf">get_nextval</span><span class="p">(</span><span class="n">SString</span> <span class="n">T</span><span class="p">,</span><span class="kt">int</span> <span class="n">next</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">k</span><span class="o">=-</span><span class="mi">1</span><span class="p">;</span>  <span class="c1">// </span>
    <span class="n">next</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// 表示一开始就匹配不上，是迭代计算next值的基础</span>
    <span class="k">while</span><span class="p">(</span><span class="n">j</span><span class="o">&lt;</span><span class="n">strlen</span><span class="p">(</span><span class="n">T</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">k</span><span class="o">==-</span><span class="mi">1</span><span class="o">||</span><span class="n">T</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">==</span><span class="n">T</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
        <span class="p">{</span>
            <span class="n">j</span><span class="o">++</span><span class="p">,</span><span class="n">k</span><span class="o">++</span><span class="p">;</span>
            <span class="k">if</span><span class="p">(</span><span class="n">T</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">!=</span><span class="n">T</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                <span class="n">next</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">k</span><span class="p">;</span>
            <span class="k">else</span>
                <span class="n">next</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">next</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">else</span>
            <span class="n">k</span><span class="o">=</span><span class="n">next</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>  <span class="c1">//如果T[j]!=T[k]，k跳转到next[k]继续循环匹配</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<h2 id="kmp完整版应用代码改进版本">KMP完整版应用代码（改进版本）</h2>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include&lt;iostream&gt;
#include&lt;string.h&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">typedef</span> <span class="kt">char</span> <span class="n">SString</span><span class="p">[</span><span class="mi">255</span><span class="p">];</span><span class="c1">//定义字符串类型SString</span>

<span class="kt">void</span> <span class="nf">get_nextval</span><span class="p">(</span><span class="n">SString</span> <span class="n">T</span><span class="p">,</span><span class="kt">int</span> <span class="n">next</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">k</span><span class="o">=-</span><span class="mi">1</span><span class="p">;</span>  <span class="c1">// </span>
    <span class="n">next</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// 表示一开始就匹配不上，是迭代计算next值的基础</span>
    <span class="k">while</span><span class="p">(</span><span class="n">j</span><span class="o">&lt;</span><span class="n">strlen</span><span class="p">(</span><span class="n">T</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">k</span><span class="o">==-</span><span class="mi">1</span><span class="o">||</span><span class="n">T</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">==</span><span class="n">T</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
        <span class="p">{</span>
            <span class="n">j</span><span class="o">++</span><span class="p">,</span><span class="n">k</span><span class="o">++</span><span class="p">;</span>
            <span class="k">if</span><span class="p">(</span><span class="n">T</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">!=</span><span class="n">T</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                <span class="n">next</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">k</span><span class="p">;</span>
            <span class="k">else</span>
                <span class="n">next</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">next</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">else</span>
            <span class="n">k</span><span class="o">=</span><span class="n">next</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>  <span class="c1">//如果T[j]!=T[k]，k跳转到next[k]继续循环匹配</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">KMP</span><span class="p">(</span><span class="n">SString</span> <span class="n">A</span><span class="p">,</span><span class="n">SString</span> <span class="n">B</span><span class="p">,</span><span class="kt">int</span> <span class="n">Pos</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">Pos</span><span class="p">,</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">next</span><span class="p">[</span><span class="n">strlen</span><span class="p">(</span><span class="n">B</span><span class="p">)];</span>  <span class="c1">// 定义next数组</span>
    <span class="n">get_nextval</span><span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="n">next</span><span class="p">);</span>  <span class="c1">// 改进版计算next数组的值</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">m</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">m</span><span class="o">&lt;</span><span class="n">strlen</span><span class="p">(</span><span class="n">B</span><span class="p">);</span><span class="n">m</span><span class="o">++</span><span class="p">)</span>
        <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">next</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="s">" "</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="n">strlen</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">strlen</span><span class="p">(</span><span class="n">B</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="o">==-</span><span class="mi">1</span><span class="o">||</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="n">B</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
        <span class="p">{</span>
            <span class="n">i</span><span class="o">++</span><span class="p">,</span><span class="n">j</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span>
            <span class="n">j</span><span class="o">=</span><span class="n">next</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="o">==</span><span class="n">strlen</span><span class="p">(</span><span class="n">B</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">i</span><span class="o">-</span><span class="n">j</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">SString</span> <span class="n">S</span><span class="p">,</span><span class="n">T</span><span class="p">;</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"Input mainstring S:"</span><span class="p">;</span>
    <span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">S</span><span class="p">;</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"Intput substring T:"</span><span class="p">;</span>
    <span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">T</span><span class="p">;</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"The match position = "</span><span class="o">&lt;&lt;</span><span class="n">KMP</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">T</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="kmp算法较之bf算法的优势">KMP算法较之BF算法的优势</h2>

<ul>
  <li>KMP算法的时间复杂度为$O(m+n)$，BF算法的时间复杂度为$O(m*n)$</li>
  <li>KMP算法中主串的工作指针不需要回溯</li>
  <li>KMP算法只需要考虑模式串</li>
  <li>KMP算法中主串指针不需回溯意味着对于规模较大的外存中的字符串的匹配操作可以分段进行，先读入一部分到内存然后完成匹配后写回外存，可以保证发生不匹配时不需要将之前写回外存的部分再次读入，减少了I/O操作，提高了效率。</li>
</ul>

  </div>

  
  
<script src="https://utteranc.es/client.js"
        repo=""
        issue-term="issue-term"
        label="utteranc"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>


  
</article>

<div class="pagination">
  
    <span class="prev" >
      <a href="/english-reading/">
        ← 上一篇
      </a>
    </span>
  
  
    <span class="next" >
      <a href="/ds-tree/">
        下一篇 →
      </a>
    </span>
  
</div>
      </div>
    </div>

    

  </body>

  
  <script>
    document.getElementById("main").classList.add("withtoc");
  </script>
  

  <div class="wrapper-footer-mobile">
    <footer class="footer">
      <!-- Refer to https://codepen.io/ruandre/pen/howFi -->
<ul class="svg-icon">

  
  
  

  

  
  <li><a href="mailto:hiter_sun@163.com" class="icon-8 email" title="Email"><svg viewBox="0 0 512 512"><path d="M502.3 190.8c3.9-3.1 9.7-.2 9.7 4.7V400c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V195.6c0-5 5.7-7.8 9.7-4.7 22.4 17.4 52.1 39.5 154.1 113.6 21.1 15.4 56.7 47.8 92.2 47.6 35.7.3 72-32.8 92.3-47.6 102-74.1 131.6-96.3 154-113.7zM256 320c23.2.4 56.6-29.2 73.4-41.4 132.7-96.3 142.8-104.7 173.4-128.7 5.8-4.5 9.2-11.5 9.2-18.9v-19c0-26.5-21.5-48-48-48H48C21.5 64 0 85.5 0 112v19c0 7.4 3.4 14.3 9.2 18.9 30.6 23.9 40.7 32.4 173.4 128.7 16.8 12.2 50.2 41.8 73.4 41.4z"/></svg><!--[if lt IE 9]><em>Email</em><![endif]--></a></li>
  

  

  

  
  <li><a href="https://github.com/suniven" class="icon-13 github" title="GitHub"><svg viewBox="0 0 512 512"><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg><!--[if lt IE 9]><em>GitHub</em><![endif]--></a></li>
  

  

  

  

  
  <li><a href="/feed.xml" class="icon-21 rss" title="RSS"><svg viewBox="0 0 512 512"><path d="M400 32H48C21.49 32 0 53.49 0 80v352c0 26.51 21.49 48 48 48h352c26.51 0 48-21.49 48-48V80c0-26.51-21.49-48-48-48zM112 416c-26.51 0-48-21.49-48-48s21.49-48 48-48 48 21.49 48 48-21.49 48-48 48zm157.533 0h-34.335c-6.011 0-11.051-4.636-11.442-10.634-5.214-80.05-69.243-143.92-149.123-149.123-5.997-.39-10.633-5.431-10.633-11.441v-34.335c0-6.535 5.468-11.777 11.994-11.425 110.546 5.974 198.997 94.536 204.964 204.964.352 6.526-4.89 11.994-11.425 11.994zm103.027 0h-34.334c-6.161 0-11.175-4.882-11.427-11.038-5.598-136.535-115.204-246.161-251.76-251.76C68.882 152.949 64 147.935 64 141.774V107.44c0-6.454 5.338-11.664 11.787-11.432 167.83 6.025 302.21 141.191 308.205 308.205.232 6.449-4.978 11.787-11.432 11.787z"/></svg><!--[if lt IE 9]><em>RSS</em><![endif]--></a></li>
  

  

  

  

  

</ul>



<p>Copyright (c) 2019-2021 From Gotei13 12th Div.</p>

    </footer>


</html>
