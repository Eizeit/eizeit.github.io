<!DOCTYPE html>
<html>
  <head>
  <title>【汇编与接口】 8086指令集 – 今天又刷了什么水题 – 为者常成，行者常至</title>

      <meta charset="utf-8" />
    <meta content='text/html; charset=utf-8' http-equiv='Content-Type'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0'>

    
    <meta name="description" content="8086指令集，汇编语言基础。

3.1 8086指令系统

3.1.1 寻址方式

指令的寻址方式就是指令中操作数的表示方式，8086的寻址方式有立即寻址、寄存器寻址、存储器寻址、串操作寻址、外设I/O端口寻址、程序转移操作寻址


  
    与数据有关的寻址方式

    
      
        立即寻址

        指令直接给出操作数的数值

        立即数只能作为源操作数，若十六进制以字母开头，要在前面加0，如0FFH

        操作位数由目的操作数决定

        eg. MOV AX,0FFFH
      
      
        寄存器寻址

        操作数存放在寄存器中，地址码为寄存器的符号

        由于寄存器在微处理器内部，所有操作都在内部进行，不执行访问内存的周期，执行速度最快

        可用于源/目的操作数

        eg. MOV DS,AX、MOV AL,31H
      
      
        存储器寻址

        操作数存储在主存中，BIU根据EU传送来的偏移地址（操作数的有效地址EA）算出物理地址后执行存取该操作数的总线周期

        
          
            直接寻址

            指令直接给出操作数的偏移地址即EA，eg. MOV AX,[2002H]，INC BYTE PTR[05A2H]

            操作数的地址也可以用符号变量表示（之前定义在数据段中的变量）

            默认段地址为DS中的地址，可通过段跨越前缀进行更改，eg. MOV AX, ES:VALUE

            规定8086的双操作数指令至少有一个操作数采用寄存器寻址或立即寻址，即两个操作数不能同时采用与存储器有关的寻址方式
          
          
            寄存器间接寻址

            操作数的EA在BX或SI/DI/BP中，eg. MOV AX,[BX]

            BX/SI/DI，段地址由DS指明

            BP，段地址由SS指明

            可通过段跨越前缀更改
          
          
            寄存器相对寻址

            操作数的EA为寄存器的内容和一个带符号的8位/16位的位移量之和

            只有BX/BP/SI/DI可用于寄存器相对寻址

            BX/SI/DI，段地址由DS指明

            BP段地址由SS指明

            可通过段跨越前缀更改

            eg. MOV AX,[SI+06H]、MOV AX,COUNT[BX] ;COUNT为常量/变量、MOV AX,[COUNT+BX] ;COUNT为常量、MOV DL,ES:STRING[SI]
          
          
            基址变址寻址

            操作数的EA为基址寄存器（BX/BP）的内容与变址寄存器（SI/DI）的和

            eg. MOV AX,[BX+SI]、MOV AX,[BX][SI]

            BX，段地址由DS指明

            BP，段地址由SS指明

            可添加段跨越前缀更改
          
          
            相对基址变址寻址

            操作数的EA为基址寄存器（BX/BP）、变址寄存器（SI/DI）的内容以及一个带符号的8位/16位偏移量的和

            BX，段地址由DS指明

            BP，段地址由SS指明

            可添加段跨越前缀更改

            eg. MOV AX,[BX+DI+08H]、MOV AX,MASK[BX][SI]、MOV,[MASK+BX+SI]
          
        
      
    
  
  
    与转移地址有关的寻址方式（程序转移寻址）
  


3.1.2 数据传送类指令


  
    MOV DST, SRC（字/字节操作，不影响标志位）

    注意：

    
      
        目的操作数不能是立即数
      
      
        两个操作数的寻址方式不能同时为存储器寻址
      
      
        两个操作数位数必须一致

        eg. MOV BYTE PTR[BX],255是对的，MOV [BX],255是错的
      
      
        CS不能作为目的操作数
      
      
        源和目的不能同时为段寄存器
      
      
        立即数不能直接送段寄存器，一般要以AX为中介

        MOV    AX,2000H
MOV    DS, AX
        
      
    
  




堆栈操作指令


  
    PUSH  SRC（字操作，不影响标志位）

    首先将SP减2，然后将SRC的低字节存入(SP)，高字节存入(SP+1)

    注意：

    
      
        不能用立即寻址（操作数不能是立即数）
      
      
        必须是字操作
      
    
  
  
    POP    DST（字操作，不影响标志位）

    首先将(SP)中的字节数据存入DST的低八位，(SP+1)的字节数据存入DST的高八位，然后将SP加2

    注意：

    
      
        不能用立即寻址（操作数不能是立即数）
      
      
        必须是字操作
      
      
        不能使用CS寄存器
      
    
  




地址传送指令


  
    LEA  REG, SRC（字操作，不影响标志位）

    将SRC的有效地址存入指定寄存器

    
      必须用存储器寻址
    
  
  
    LDS  REG, SRC（字操作，不影响标志位）

    将SRC指明的字存储单元的内容送REG，将地址为SRC+2的字存储单元的内容送DS

    
      必须用存储器寻址
    
  
  
    LES  REG, SRC（字操作，不影响标志位）

    将SRC指明的字存储单元的内容送REG，将地址为SRC+2的字存储单元的内容送ES

    
      必须用存储器寻址
    
  




零地址指令


  
    LAHF（Load AH with Flags，不影响标志位，隐含操作数为FR的低八位）

    将FR的低八位送AH
  
  
    SAHF（Store AH into Flags，影响标志位)

    将AH的内容送FR的低八位
  
  
    PUSHF（Push Flags，不影响标志位）
  
  
    POPF  （Pop Flags，影响标志位）
  





  
    XCHG  DST,SRC（字/字节操作，不影响标志位）

    交换DST和SRT的数据

    注意：

    
      
        两操作数均不能为立即数
      
      
        两操作数均不能用段寄存器
      
      
        两操作数不能同时采用与存储器有关的寻址方式
      
    

    eg. MOV AX,VAR
  




换码指令


  
    XLAT（字节操作，不影响标志位）

    将地址为[BX]+[AL]（AL高位补零）的内存单元当中的字节数据送至AL

    
  


3.1.3 位操作类指令

位操作运算指令分为逻辑运算指令和移位指令
要注意每一条位操作指令如何影响标志位


  
    AND/OR/XOR  DST, SRC（字、字节操作）

    将DST和SRT指明的操作数安位与/或/非，结果存在DST

    注意：

    
      
        DST不能是立即数
      
      
        对标志位的影响：CF=OF=0，SF、ZF、PF看结果，AF不确定
      
    

    eg. ASCII码大小写互换：第6位取反，其余位不变（和0异或不变，和1异或相当于取反），XOR AL,00100000B               [注]：这里期末考用到了
  
  
    TEST DST,SRC（字/字节操作）

    将DST指明的操作数与SRC指明的操作数按位与，只做运算，不存结果，即只影响FR

    对标志位的影响：CF=OF=0，SF、ZF、PF看结果，AF不确定
  
  
    NOT OPR（字/字节操作）

    对OPR指明的操作数按位取反，结果仍存OPR

    
      
        不能是立即数
      
      
        不影响任何标志位
      
    
  




移位指令

（个人实验供参考）关于移位大于1次时对OF位的影响：与PPT上说的不一样，事实上根据实验得到结论


  指令SHL对OF的影响：若移位完成后的符号位与未移位时的符号位相同，则OF为0，否则为1

  指令SHR/ROL/ROR/RCL/RCR对OF的影响：若移位完成后的符号位与最后一次移位完成之前的符号位相同，则OF为0，否则为1


        .MODEL SMALL
        .DATA
        .CODE
START:  MOV			AL,10101010b
        MOV			CL,2
        ;SHL        AL,CL
        ;SHR        AL,CL
        ;ROL        AL,CL
        ;ROR        AL,CL
        ;RCL        AL,CL
        ;RCR        AL,CL
OVER:   MOV     	AX, 4C00H
        INT     	21H
        END        	START




逻辑移位指令


  
    SHL  OPR,1/CL（字/字节操作）

    将OPR指明的操作数逻辑左移，空位补零，移出来的位进CF

    
      
        OPR不能是立即寻址
      
      
        SF/ZF/PF根据结果设置，AF不确定

        OF：事实上根据测试，不是只在移位次数为1时影响；而是若移位后的符号位与未移位时的符号位不同，则OF=1，否则OF=0
      
    
  
  
    SHR OPR,1/CL（字/字节操作）

    将OPR指明的操作数逻辑右移，空位补零，移出来的位进CF

    
      
        OPR不能是立即寻址
      
      
        SF/ZF/PF根据结果设置，AF不确定

        OF：最后一次移位后的符号位与最后一次的前一次移位后的符号位不同，OF=1，事实上只有移位次数为1的时候才有可能改变，因为大于一次时高位都补零了
      
    
  




算术移位指令


  
    SAL  OPR,1/CL（字/字节操作）

    将OPR指明的操作数算数左移，低位补零，移出去的位进CF

    
      
        OPR不能是立即寻址
      
      
        SF/ZF/PF根据结果设置，AF不确定

        OF：若移位完成后的符号位与最后一次移位完成之前的符号位相同，则OF为0，否则为1
      
    
  
  
    SAR  OPR,1/CL（字/字节操作）

    将OPR指明的操作数算数右移，高位补符号位，移出去的位进CF

    
      
        OPR不能是立即寻址
      
      
        SF/ZF/PF根据结果设置，AF不确定

        OF：最后一次移位后的符号位与最后一次的前一次移位后的符号位不同，OF=1，事实上只有移位次数为1的时候才有可能改变，因为大于一次时高位一直补符号位了
      
    
  




不带进位的循环移位指令


  
    ROL  OPR,1/CL（字/字节操作）

    将OPR指明的操组数循环左移，低位空出的位用高位移出的位补，同时移出的位进入CF

    
      
        不能是立即寻址
      
      
        不影响SF/ZF/PF/AF

        OF：若移位完成后的符号位与最后一次移位完成之前的符号位相同，则OF为0，否则为1
      
    
  
  
    ROR  OPR,1/CL（字/字节操作）

    将OPR指明的操组数循环右移，高位空出的位用低位移出的位补，同时移出的位进入CF

    
      
        不能是立即寻址
      
      
        不影响SF/ZF/PF/AF

        OF：若移位完成后的符号位与最后一次移位完成之前的符号位相同，则OF为0，否则为1
      
    
  




带进位循环移位指令


  
    RCL  OPR,1/CL（字/字节操作）

    将OPR指明的操作数连同CF一起循环左移（CF在左边）

    
      
        不能是立即寻址
      
      
        不影响SF/ZF/PF/AF

        OF：若移位完成后的符号位与最后一次移位完成之前的符号位相同，则OF为0，否则为1
      
    
  
  
    RCR  OPR,1.CL（字/字节操作）

    将OPR指明的操作数连同CF一起循环右移（CF在右边）

    
      
        不能是立即寻址
      
      
        不影响SF/ZF/PF/AF

        OF：若移位完成后的符号位与最后一次移位完成之前的符号位相同，则OF为0，否则为1
      
    
  


3.1.4 算术运算类指令

算术运算的操作数一定是定点无/带符号整数
双操作数指令至少有一个操作数在寄存器中/立即寻址
单操作数不允许立即寻址
要注意对标志位的影响


  
    ADD  DST,SRC（字/字节操作）

    将DST和SRT指明的操作数相加，结果保存在DST

    
      
        SF/ZF/PF/AF看运行情况
      
      
        若两个操作数符号相同，但结果的符号与操作数的符号相反，则产生溢出，OF=1，否则OF=0
      
      
        若最高位产生进位，则CF=1，否则CF=0，CF可以表示无符号数的溢出
      
    
  
  
    SUB  DST,SRC（字/字节操作）

    DST指明的操作数减SRC指明的操作数，结果保存在DST

    
      
        SF/ZF/PF/AF看运行情况
      
      
        若两个操作数符号相反，但结果的符号与减数（SRC）的符号相反，则产生溢出，OF=1，否则OF=0
      
      
        （无符号数）若被减数小于减数，则CF=1，否则CF=0
      
    
  
  
    ADC  DST,SRC（字/字节操作）

    将DST与SRC指明的操作数以及当前CF的值相加，结果保存在DST

    
      
        SF/ZF/PF/AF看运行情况
      
      
        若两个操作数符号相同，但结果的符号与操作数的符号相反，则产生溢出，OF=1，否则OF=0
      
      
        若最高位产生进位，则CF=1，否则CF=0
      
    

    eg. 32位数加法，目的操作数存放在DX（高）和AX（低）；源操作数存放在BX（高）、CX（低）

    ADD    AX, CX
ADC    DX, BX
    
  
  
    SBB  DST,SRC（字/字节操作）

    DST指明的操作数减SRC指明的操作数，再减去当前CF的值，结果存DST

    
      
        SF/ZF/PF/AF看运行情况
      
      
        若两个操作数符号相反，但结果的符号与减数（SRC）的符号相反，则产生溢出，OF=1，否则OF=0
      
      
        （无符号数）若被减数小于减数，则CF=1，否则CF=0
      
    

    eg. 32位数减法，目的操作数存放在DX（高）和AX（低）中；源操作数为立即数80004491H

    SUB    AX,4491H
SBB    DX,8000H
    
  
  
    INC  OPR

    OPR指明的操作数+1后存于OPR

    
      
        根据结果影响OF/SF/ZF/PF/AF
      
      
        不影响CF
      
    
  
  
    DEC  OPR

    OPR指明的操组数-1后存于OPR

    
      
        根据结果影响OF/SF/ZF/PF/AF
      
      
        不影响CF
      
    
  
  
    CMP  DST,SRC（字/字节操作）

    DST指明的操作数减SRC指明的操作数，只做运算，不存结果，即只改变符号位，通常后面跟条件转移指令

    
      
        SF/ZF/PF/AF看运行情况
      
      
        若两个操作数符号相反，但结果的符号与减数（SRC）的符号相反，则产生溢出，OF=1，否则OF=0
      
      
        （无符号数）若被减数小于减数，则CF=1，否则CF=0
      
    
  
  
    NEG  OPR（字/字节运算）尚存疑？

    对OPR指明的操作数求补，即按位取反后加1，结果存OPR

    
      
        相当于求相反数
      
      
        根据运算结果影响CF/OF/ZF/SF/PF/AF
      
      
        当且仅当操作数为0时CF=1，否则CF=0
      
      
        当且仅当字节运算时对-128求补或字运算时对-32768求补时OF=1，否则OF=0
      
    

    
      附：一个求负数补码的简便方法

      找到二进制表示形式下的最右边的1，对该位左边的所有位（除去符号位）按位取反

      eg. -1的二进制表示为10000001B，按如上操作后变为11111111B，即0FFH，为-1的补码
    
  
  
    MUL  SRC（字/字节操作）

    若SRC指明的操作数为8位，则将其与AL中的数相乘，结果存于AX；若SRC指明的操作数为16位，则将其与AX中的数相乘，结果的高16位存于DX，低16位存于AX

    
      
        所有操作数都是无符号数
      
      
        若乘积的高半部分位0，则CF=OF=0；否则CF=OF=1；反映乘法是否超过原有的位宽
      
      
        其余标志位无定义（不确定0/1）
      
    
  
  
    IMUL  SRC（字/字节操作）

    若SRC指明的操作数为8位，则将其与AL中的数相乘，结果存于AX；若SRC指明的操作数为16位，则将其与AX中的数相乘，结果的高16位存于DX，低16位存于AX

    
      
        所有操作数都是带符号数
      
      
        若乘积的高半部分位0，则CF=OF=0；否则CF=OF=1；反映乘法是否超过原有的位宽
      
      
        其余标志位无定义（不确定0/1）
      
    
  
  
    DIV  SRC（字/字节操作）

    若SRC为8位，则用AX中的数除以SRC指明的数，商存AL，余数存AH；若SRC为16位，则用DX（高16位）和AX（低16位）组成的32位无符号整数除以SRC指明的数，商存AX，余数存DX

    
      
        所有操作数都是无符号整数
      
      
        所有标志位均不确定
      
      
        若位宽不足以容纳商（商溢出），将自动转入0型中断处理程序，此时得到的商和余数均不确定
      
    
  
  
    IDIV  SRC（字/字节操作）

    若SRC为8位，则用AX中的数除以SRC指明的数，商存AL，余数存AH；若SRC为16位，则用DX（高16位）和AX（低16位）组成的32位无符号整数除以SRC指明的数，商存AX，余数存DX

    
      
        所有操作数都是带符号整数
      
      
        所有标志位均不确定
      
      
        商的符号根据代数除法规则确定，余数的符号同被除数
      
      
        若位宽不足以容纳商（商溢出），将自动转入0型中断处理程序，此时得到的商和余数均不确定
      
    
  
  
    CBW  （convert byte to word）

    隐含操作数AL，若AL最高位为0，则令AH=00H，若AL最高位为1，则令AH=0FFH

    
      
        不影响标志位
      
      
        符号扩展指令用于将被除数调整为合适的位宽
      
    
  
  
    CWD  （convert word to double word）

    隐含操作数AX，若AX最高位为0，则令DX=0000H，若AX最高位为1，则令DX=0FFFFH

    
      
        不影响标志位
      
      
        符号扩展指令用于将被除数调整为合适的位宽
      
    
  
  
    DAA（十进制调整指令）

    隐含操作数AL，对AL中的压缩BCD码进行修正：

    
      
        若AL的低4位在A~F之间或AF=1，则将AL的值加06H，结果存AL并将AF置1
      
      
        若AL的高4位在A~F之间或CF=1，则将AL的值加60H，结果存AL并将XF置1
        
          必须跟在ADD或ADC指令之后（AL为目的操作数）
        
      
    

    
      对OF无定义，根据结果影响所有其余标志位
    

    eg. 计算两个压缩BCD码28与68之和

    MOV    AL, 00101000B
ADD    AL, 01101000B
DAA
    
  
  
    DAS（十进制调整指令）

    隐含操作数AL，对AL中的压缩BCD码进行修正：

    
      
        若AL的低4位在A~F之间或AF=1，则将AL的值减06H，结果存AL并将AF置1
      
      
        若AL的高4位在A~F之间或CF=1，则将AL的值减60H，结果存AL并将XF置1
        
          必须跟在SUB或ASBB指令之后（AL为目的操作数）
        
      
    

    
      对OF无定义，根据结果影响所有其余标志位
    

    eg. 计算两个压缩BCD码86与97之差

    MOV    AL,10000110B
SUB    AL,10010111B
DAS
; 86+(-97)
; 0EFH-06H-60H=89H=10001001B即BCD码的-5
    
  
  
    AAA（ASCII调整指令）

    隐含操作数AL，对AL中的非压缩BCD码（或十进制数的ASCII码）进行修正：

    

    
      
        必须跟在ADD或ADC指令之后（AL为目的操作数）
      
      
        影响AF/CF，对其余标志位无定义
      
    

    eg. 已知(AX)=0535H，(BL)=39H，分析指令

    ADD    AL,BL
AAA
    

    分析：

    结果(AX)=0604H，？？意义？？不是很懂这个指令
  
  
    AAS（ASCII调整指令）

    隐含操作数AL，对AL中的非压缩BCD码（或十进制数的ASCII码）进行修正：

    

    
      
        必须跟在SUB或SBB指令之后（AL为目的操作数）
      
      
        影响AF/CF，对其余标志位无定义
      
    
  
  
    AAM（ASCII调整指令）

    隐含操作数AX，对AL中的非压缩BCD码修正：

    AL中的内容除以10，余数存AL，商存AH

    
      
        必须跟在MUL指令之后，两个操作数为非压缩BCD码（高四位均为0）
      
      
        根据AL中结果设置SF/ZF/PF，其余标志位无定义

        eg. 已知(AL)=07H，(BL)=09H，分析指令

        MUL    BL
AAM
        

        分析：
      
    
  
  
    AAD（ASCII调整指令）

    隐含操作数AX，对AX中的非压缩BCD码修正：

    (AH)*10+(AL)结果存AH，然后将AH清零

    
      必须在DIV指令之前，被除数存于AX，为非压缩BCD码（AH存十位，AL存各位且AH、AL高4位均为0）
      根据AL中结果设置SF/ZF/PF，其余标志位无定义
    

    eg. 编程实现53/3
  


3.1.5 字符串操作类指令

包括串传送、串比较、串扫描、从串取、存入串
一条串操作指令仅能完成1字节/字的操作，需要配合重复前缀指令才能实现对整个串的操作 
分别用SI和DI作为源串和目的串的指针，源串默认在数据段，但可以通过段跨越前缀修改，目的串必须在附加段
每次处理完当前指向的字符后要修改段指针，修改方向由DF决定，DF=0时，DI/SI增加，DF=1时，DI/SI减小   
DF标志位的清零和置1由指令CLD和STD完成


  
    REP  MOVS/LODS/STOS

    
      
        若CX为零则结束，否则转2
      
      
        CX=CX-1
      
      
        执行串操作指令，转1
        
          不影响标志位
        
      
    
  
  
    MOVS  DST, SRC（字/字节操作）

    MOVS/MOVSW

    将SRC指向的字节（字）存储单元的内容送至ES:DI指向的字节（字）存储单元；然后根据DF的值将SI和DI加/减1/2

    
      
        第一种形式由操作数指明字/字节操作
      
      
        第二种形式默认[DS:SI]送[ES:DI]
      
      
        别忘了设置DF

        思考：DF何时取0，何时取1？

        当源串与目的串存储空间有重合时，若源串在前，DF=1；若源串在后，DF=0
      
      
        不影响状态位
      
    
  
  
    STOS  DST

    STOSB/STOSW

    将AL（AX）的值传送至ES:DI指向的字节（字）存储单元，然后根据DF的值将DI增加/减少1/2

    
      
        第一种形式由操作数指明字/字节操作
      
      
        常用于缓冲区初始化
      
      
        不影响标志位
      
    
  
  
    LODS  SRC

    LODSB/LODSW

    将SRC指向的字节（字）存储单元送至AL（AX），然后根据DF的值将SI增加/减少1/2

    
      
        第一种形式由操作数指明字/字节操作
      
      
        不影响标志位
      
      
        一般不与REP联用
      
    
  
  
    REPE/REPZ  CMPS/SCAS

    
      
        若CX不为0且ZF=1则转2，否则结束
      
      
        CX=CX-1
      
      
        执行串操作指令，转1
        
          本身不影响标志位，影响标志位的是其后的串操作
        
      
    
  
  
    CMPS  SRC, DST

    CMPSB/CMPSW

    用SRC指向的字节（字）存储单元的内容减去ES:DI指向的字节（字）存储单元的内容，根据结果设置标志位，然后根据DF的值将SI和DI增加/减少1/2

    
      
        对符号位的影响同SUB指令
      
      
        第一种形式由操作数指明字/字节操作
      
      
        第二种形式默认[DS:SI]-[ES:DI]
      
    
  
  
    REPNZ/REPNE  CMPS/SCAS

    
      
        若CX不为0且ZF=0则转2，否则结束
      
      
        CX=CX-1
      
      
        执行串操作指令，转1
        
          指令本身不影响标志位，影响标志位的是串操作指令
        
      
    
  
  
    SCAS  DST

    SCASB/SCASW

    用AL（AX）中的内容减去ES:DI指向的字节（字）存储单元的内容，根据结果设置标志位，然后根据DF的值将DI增加/减少1/2

    
      
        对符号位影响同SUB指令
      
      
        第一种形式由操作数指明字/字节操作
      
    

    eg. 比较两个等长的字符串是否相同，相同用0表示，不同用-1表示，结果存入result字节单元

        LEA    SI,STR1
    LEA    DI,STR2
    MOV    CX,LEN    ;LEN是字符串长度
    CLD              ;DF=0
    REPZ   CMPSB
    XOR    AL,AL
    JNZ    RE        ;不为零则相等
NE: DEC    AL
RE: MOV    RESULT,AL   
    
  


3.1.6 控制转移类指令

根据功能划分：包括无条件转移、条件转移、循环、子程序调用及返回、中断及返回
根据目标地址与本指令是否在同一代码段划分：段内转移、段间转移。段内转移范围在-128~127之间，段内转移仅需目标的有效地址（CS）不变；段间转移需要确定目标的有效地址和段地址并改变IP和CS的值
寻址方式：


  
    相对寻址：用于段内转移，目标地址的有效地址为IP的当前值与指令中给出的8位或16位位移量之和
  
  
    段内寄存器寻址：段内转移的目标的有效地址为某16位寄存器的内容
  
  
    段内间接寻址：段内转移的目标的有效地址为某字存储单元的内容
  
  
    段间直接寻址：指令中直接给出目标的段地址和有效地址代替CS和IP的内容实现转移
  
  
    段间间接寻址：目标地址为存储器中连续两个字单元的内容（低地址为有效地址，高地址为段地址）
  


注意：所有的条件转移指令只能使用相对寻址的8位位移量，也就是都是段内转移，指令本身不影响标志位


  
    JMP（无条件转移指令）

    ; 段内相对转移
JMP    PROG    ; 16位
JMP    SHORT PROG    ; 8位
; 段内寄存器/间接转移
JMP    BX
JMP    WORD PTR [BX+SI]
; 段间直接转移
JMP    FAR PTR PROC    ; 4字节
; 段间间接转移
JMP    DWORD PTR [DI + BRCHTABLE]
    

    
      不影响标志位
    
  
  
    条件转移指令

    
      
        JZ/JE    JNZ/JNE

        JZ：ZF为1时跳转，否则不跳转；JNZ反之
      
      
        JS    JNS

        JS：SF为1时跳转，否则不跳转；JNS反之
      
      
        JO    JNO

        JO：OF为1时跳转，否则不跳转；JNO反之
      
      
        JP/JPE    JNP/JPO

        JP：PF为1时跳转，否则不跳转；JNP反之
      
      
        JC/JB/JNAE    JNC/JNB/JAE

        JC：CF为1时跳转，否则不跳转；JNC反之
      
      
        JA/JNBE    JNA/JBE

        JA：CF=ZF=0则跳转，否则不跳转；JNA反之

        其实JA就是高于则跳转，JNBE就是不是低于或等于也就是高于，一个意思
      
      
        JL/JNGE    JNL/JGE

        JL：$OF \oplus SF = 1$ 则跳转，否则不跳转；JNL反之

        jump if less 小于则转移
      
      
        JG/JNLE    JNG/JLE

        JG：$OF \oplus SF=0$ 且ZF为0则跳转，否则不跳转；JNG反之

        jump if greater 大于则转移
      
    

    JB/JBE/JNB/JNBE/JA/JAE/JNA/JNAE用于无符号数比较

    JL/JLE/JNL/JNLE/JG/JGE/JNG/JNGE用于带符号数比较

    
      
        JCXZ（jump if cx=zero）

        CX=0则跳转，否则不转
      
    
  
  
    循环指令

    
      
        LOOP OPR

        CX减1存CX，若CX非0，则转移至标号OPR处执行，否则按照代码顺序执行下一条指令

        
          
            属于“直到型循环”
          
          
            只能使用相对寻址的8位位移量
          
          
            不影响标志位
          
        
      
      
        LOOPZ/LOOPE

        LOOPNZ/LOOPNE

        CX减1存CX，若CX非零且ZF=1(0)，则转移至标号OPR处执行，否则按照代码顺序执行下一条指令

        
          
            只能用相对寻址的8位位移量
          
          
            不影响标志位
          
        
      
    
  
  
    子程序调用指令

    CALL DST

    DST：子程序入口地址

    
      
        段内调用：当前IP值进栈（保护断点），然后将DST指明的偏移地址送IP
      
      
        段间调用：当前CS值入栈，当前IP值入栈（保护断点，注意顺序），然后将DST指明的段地址送CS，偏移地址送IP
      
    
  
  
    子程序返回指令

    作为子程序的最后一条指令，返回主程序CALL指令后的下一条指令继续执行

    
      
        RET/RET  N

        段内返回，出栈一个字送IP（恢复断点）

        若带一个立即数N，则在上述操作完成后额外出栈N/2个字
      
      
        RETF/RETF  N

        段间返回，出栈两个字，第一个字送IP，第二个字送CS（恢复断点，注意顺序）

        若带一个立即数N，则在上述操作完成后额外出栈N/2个字
      
    

    不影响标志位
  
  
    中断指令INT

    INT  TYPE

    TYPE为0~255之间的常量

    
      
        当前标志寄存器FLAGS入栈
      
      
        当前CS、IP值入栈（注意顺序）（保护断点）
      
      
        物理地址为 $TYPE \times 4$ 的字存储单元的内容送IP，$TYPE\times 4+2$ 的字存储单元的内容送CS（寻找中断服务程序入口地址）
      
      
        将IF和TF清零（关中断）

        注：参见中断向量表

        
       - INT指令不影响除IF和TF之外的标志位
      
    

    
      关于IP和CS的入栈/出栈顺序：

      可以这么记，栈是向下生长的（地址由大到小），在栈中，保存段地址的地址总是大于保存段内偏移地址的地址
    
  
  
    中断返回指令IRET

    IRET
出栈第一个字送IP；出栈第二个字送CS；出栈第三个字送FLAGS
  
  
    系统功能调用

    以21H为总入口，再配以具体功能号（AH），常用的有：

    
      
        01H：从键盘输入一个字符并回显至屏幕
      
      
        02H：显示一个字符至屏幕（字符放在DL）
      
      
        09H：显示字符串至屏幕
      
      
        0AH：从键盘输入字符串到缓冲区
      
      
        4CH：带返回码结束
      
    
  
  
    中断指令INTO（溢出中断服务）
若OF=0，继续执行下一条指令
若OF=1：

    
      
        FLAGS入栈
      
      
        CS、IP入栈
      
      
        物理地址为10H的字存储单元的内容送IP，物理地址为12H的字存储单元的内容送CS（类型为4的中断）
      
      
        IF和TF清零
        
          INTO不影响除IF和TF以外的标志位
        
      
    
  
  
    标志操作指令（不影响其余标志位）

    
      
        CLC，将CF清零
      
      
        CMC，将CF取反
      
      
        STC，将CF置1
      
      
        CLD，将DF清零
      
      
        STD，将DF置1
      
      
        CLI，将IF清零
      
      
        STI，将IF置1

        开中断，8259A编程中，调用某中断后若想中断嵌套，必须在中断处理程序开头加上STI
      
    

    对于其他标志位无相应的清零或置1指令
  
  
    无操作指令NOP（不影响标志位）
  
  
    停机指令HLT
使处理机处于停机状态，以等待一次外部中断或RESET信号的到来，中断处理结束后继续执行后续指令
  
  
    等待指令WAIT
等待 $\overline{TEST}$ 信号有效，每五个时钟周期测试一次，有效后顺序执行下一条指令
  
  
    交权指令ESC
ESC  OPCODE, SRC
与WAIT指令一同用于与协处理器配合
  
  
    总线封锁前缀指令LOCK
可以添加在任何指令之前，在该条指令执行期间保持CPU对总线的控制权，其他处理器不能从CPU抢占总线
  


3.2 8086汇编语言的基本语法


  
    框架（简略模式）

            ;采用简化版的段定义伪指令，下一个段的开始即表示上一个段的结束
        .model small
        .stack    [常量(大小为常量个字节)默认1KB]
        .data
; ...定义的数据
; [变量名]    DB    操作数列表
; DB(define word)
; DD(define double word)
; DQ
; DT
; PORTA    EQU    20H  符号常量也可用=定义
; PTR 类型属性操作符 转换类型    类型 PTR 变量名/含变量名的表达式
        .code    [段名]
start:  mov    ax, @data     ; @data表示代码段名
        mov    ds, ax        ; 装载数据段
          
        ; ....一些操作
          
        mov    ax,4c00h
        int    21h           ; 调用21号中断结束汇编
      end    start
    
  
  
    框架（非简略模式）

    SSTACK	SEGMEN	STACK
		DB	200 DUP(0)
SSTACK	ENDS        
DATA	SEGMENT
; ORG 3000H    ; ORG规定起始地址
; ARY     DB    100,98,-1,-2,-4,7,0,100,32,1
; ARRY  DQ DUP(?)    ; DUP复制操作符,?表示只分配存储空间
DATA	ENDS
CODE    SEGMENT
        ASSUME     CS:CODE,DS:DATA,SS:SSTACK
START:  MOV     AX,DATA
        MOV     DS,AX
        MOV     AX,STACK
        MOV     SS,AX
        ; CS不需要送段寄存器
        ; ...一些操作
        MOV    AX,4C00H
        INT    21H           ; 调用21号中断结束汇编
CODE    ENDS
        END      START
    
  
  
    标识符的属性

    
      
        段属性
标号的段属性必在CS寄存器中
      
      
        偏移属性（16位无符号数）
      
      
        类型属性

        
          
            标号：NEAR/FAR
          
          
            变量名：BYTE/WORD/DWORD/QWORD/TBYTE
          
        
      
    
  
  
    常量

    
      
        常数
      
      
        字符
      
      
        字符串（可以在单引号里也可以在双引号里）
      
      
        符号常量
标识符  EQU/=  常量或常量表达式 该语句不占内存

        $：当前行的偏移地址
      
    
  
  
    变量

    
      
        DB/DW/DD/DQ/DT
      
      
        类型转换：
类型  PTR  变量名/含变量名的表达式

        JMP WORD PTR [BX]
      
    
  
  
    运算符（操作符）

    
      
        算术运算符：“+” “-” “*” “/” 和MOD
      
      
        逻辑运算符：AND/OR/XOR/NOT/SHL/SHR
      
      
        关系运算符：EQ/NE/LT/GT/LE/GE
      
      
        属性运算符：PTR/SHORT/THIS/HIGH/LOW/TYPE/LENGTH/SIZE
      
      
        地址运算符：“[]” 、“$”、 “:”、 OFFSET、SEG
      
    

    运算符出现在操作数项内部，运算在汇编时完成
  


3.3 汇编语言程序设计基础

理论不多说了，还是要编


  
    顺序结构程序设计
  
  
    分支结构程序设计

    注意跳过不该执行的分支

    
      
        eg. 显示2位压缩BCD码的值（0-99），不输出前导0，并设待显示字节数据已用DB伪指令存至变量BCD中

        	  ; 核心部分
      mov    dl, bcd
      test   dl, 0F0H    ; 按位与看看是一位数还是两位数
      jz     one
two:  mov    cl, 4
      shr    dl, cl      ; 把BCD码的十位移到ASCII的低4位
      add    dl, 30h
      mov    ah, 02h
      int    21h
      mov    dl, bcd
      and    dl, 0fh
      add    dl, 30h
one:  mov    ah, 02h
      int    21h
        
      
      
        多分支结构
跳跃表法
eg. 根据BX的低四位哪一位为1（由低到高）在屏幕上显示1、2、4、8

                .model small
        .data
var     equ        ?    ; 测试数据
tab     dw         foo1, foo2, foo3, foo4    ; ***
        .code
start:  mov        ax, @data
        mov        ds, ax
        mov        bx, var
        xor        si, si
find:   shr        bx, 1
        jnc        no
        mov        ah, 02h
        jmp        tab[si]
no:     add        si, 2
        jmp        find
foo1:   mov        dl,'1'
        jmp        over
foo2:   mov        dl,'2'
        jmp        over
foo3:   mov        dl,'4'
        jmp        over
foo4:   mov        dl,'8'
        jmp        over
over:   int        21h
        mov        ax,4c00h
        int        21h
        end        start
        

        DW标识符是将该标识符（标号、变量名、etc…）对应的段内偏移地址存入一个字单元，类似的，可用DD将某标识符的偏移地址和段地址存入两个相邻的字单元（双字，偏移地址放在低地址单元，段地址放在高地址单元
      
    
  
  
    循环结构

    
      
        计数控制
      
      
        条件控制（无条件转移指令、条件转移指令）

        eg. 输入若干学生姓名，直接按回车则结束，将其中最大者（按字典序）输出。

        		.model  small
        .data
maxlen	db      11h				;一个学生姓名的最大长度+1（回车）
actlen	db      ?      			;实际输入的字符个数
nmbuf	db      11h dup(0)		;namebuffer
rslt	db      'Result: '		;
longnm	db		0dh, 0ah, '$'	;初始化，一开始肯定比'a'小就对了
        db		10h dup(0)		;最大的名字
crlf	db		0dh, 0ah, '$'	;回车换行
        .code
start:  mov		ax, @data
        mov		ds, ax
        mov     es, ax
        cld
next:   lea     si, nmbuf
        lea		di, longnm
        lea		dx, maxlen		;把最大可输入字符数存到缓冲区第一个字节单元
        mov		ah, 0ah			;输入姓名
        int		21h
    
        lea     dx, crlf        ;输出回车换行
        dec 	ah              ;09H号，输出字符串
        int   	21h
    
        mov  	cl, actlen
        xor    	ch, ch
        jcxz	otpt            ;若CX=0则跳转，CX=0即只键入了一个回车，结束
    
        repe    cmpsb           ;比较nmbuf和longnm的大小 SI-DI
        jng     next            ;/js
        lea   	si, nmbuf       ;更新当前的最大名字
        lea  	di, longnm
        mov   	cl, actlen
        rep		movsb
    
        mov		byte ptr [di], 0dh        ;回车换行结束
        mov		byte ptr [di+1], 0ah
        mov		byte ptr [di+2], '$'
    
        jmp     next
otpt:   mov     dx, offset rslt	;因为rslf后面存的就是结果，结果里才有'$'所以一直输出到结束
         int        21h
         mov        ax, 4c00h
         int        21h
         end        start
        

        
          
            双重循环

            eg. 改进的冒泡排序

                    ;改进的冒泡排序,递增
        .model small
        .data
COUNT   EQU		11
FLAG    DB		1
        .CODE
START:  MOV        AX,@DATA
        MOV        DS,AX
        MOV        DI,3000H
        MOV        CX,COUNT    
        DEC        CX           ;外层循环次数
OLP:    MOV        DX,CX        ;暂存外层循环
        CMP        FLAG,0       ;如果上一轮没有进行交换
        JE         OVER         ;提前结束[优化]
        MOV        FLAG,0
        MOV        DI,3000H
    
ILP:    MOV        AL,[DI]
        CMP        AL,[DI+1]    ;ax-[DI+1]
        JB         STEP         ;小于则直接比较下一组
        XCHG       AL,[DI+1]    ;大于则交换
        MOV        [DI],AL
        MOV        FLAG,1       ;一轮中发生交换将FLAG置1        
STEP:   INC        DI
        LOOP       ILP
        MOV        CX,DX        ;恢复CX继续计数
        LOOP       OLP
    
OVER:   MOV        AX,4C00H
        INT        21
END     START
    
            
          
        
      
    
  
  
    子程序结构

    格式：

      过程名    PROC    [属性]
      …         ;子程序主体部分
  过程名    ENDP
    

    属性为NEAR/FAR

    eg. N的阶乘

              	;N的阶乘
STACK   SEGMENT STACK
		DB 200 DUP(0)
STACK   ENDS
DATA	SEGMENT
		N         DW 7
		RESULT    DW ?
DATA    ENDS
CODE    SEGMENT
  		ASSUME     CS:CODE,SS:STACK,DS:DATA
START:	MOV		AX,DATA
        MOV     DS,AX
        MOV     AX,N
        MOV     DX,1
        CALL    FACT
        MOV     RESULT,DX
        MOV     AX,4C00H
        INT     21H
          
FACT    PROC
        CMP     AX,0
        JNE     STEP        ;没结束
        MOV     DX,1
        RET
  
STEP:   PUSH    AX
        DEC     AX
        CALL    FACT        ;递归调用
        POP     AX
        MUL     DX
        MOV     DX,AX
        RET
FACT    ENDP
  
CODE    ENDS
		END      START
    

    
      
        子程序的参数传递——寄存器传参
适用于参数较少的时候
      
      
        子程序的参数传递——地址表传参
适用于参数较多的情况

        eg. 计算数组的累加和

                .model small
        .data
ary     dw        10 dup(?)
cnt     dw        10
sum     dw        ?
tbl     dw        3 dup(?)
        .code    
main    proc    far
begin:  mov     ax, @data
        mov     ds, ax
        mov     tbl, offset ary
        mov     tbl+2, offset cnt
        mov     tbl+4, offset sum
        mov     bx, offset tbl
        call    addtab
        mov     ax, 4c00h
        int     21h
main    endp
addtab  proc	near
        push	ax
        push	cx
        push	si
        push    di
        mov    	si, [bx]        ;数组首地址
        mov   	di, [bx+2]      ;数组元素个数
        mov     cx, [di]        ;数组元素个数送CX
        mov     di, [bx+4]      ;sum
        xor     ax, ax          ;ax存每次相加后的结果
next:   add     ax, [si]
        add     si, 2
        loop    next
        mov     [di], ax        ;结果送sum
        pop     di
        pop     si
        pop     cx
        pop     ax
        ret
addtab  endp
        end   	begin
        
      
      
        子程序的参数传递——堆栈传参
适用于子程序有嵌套、递归调用的情况，主程序将参数压栈，子程序将参数弹栈。使用堆栈传参要注意对栈的管理，最好可以画个图。

        eg. 数组累加

                .model small
        .data
ary     dw        10 dup(?)
cnt     dw        10
sum     dw        ?
        .stack
        dw        100 dup(?)
btm     dw        ?                ;栈是向下生长的
        .code    
main    proc	far
begin:  mov     ax, @data
        mov     ds, ax
        mov     sp, offset btm    ;栈顶指针，当前指向栈底
        mov     bx, offset ary    ;数组首地址
        push    bx
        mov     bx, offset cnt    ;数组元素个数
        push    bx
        mov     bx, offset sum    ;数组元素和
        push    bx
        call    addstk
        mov     ax, 4c00h
        int     21h
main    endp
addstk  proc    near
        push    bp
        mov        bp, sp
        push    ax
        push    cx
        push    si
        push    di
        mov     si, [bp+8]  ;&amp;ary
        mov     di, [bp+6]  ;&amp;cnt
        mov     cx, [di]    ;数组元素个数
        mov     di, [bp+4]	;&amp;sum
        xor     ax, ax
next:   add     ax, [si]
        add     si, 2
        loop    next
        mov     [di], ax
        pop     di
        pop     si
        pop     cx
        pop     ax
        pop     bp
        ret     6        	;额外弹出3个字（丢弃不再需要的参数）
addstk  endp
        end     begin
        

        

        BP的专门用途正是堆栈传参，BP寄存器默认与SS段寄存器配合

        递归式累加代码：

        ; 元素个数用堆栈传递，累加和用AX传递
        .model    small
        .data
ary     dw        10 dup(2)
cnt     dw        10
sum     dw        ?
        .stack
        dw    100 dup(?)
btm     dw    ?
        .code
main    proc	far
begin:  mov   	ax, @data
        mov 	ds, ax
        mov		sp, offset btm        ;栈顶指针，初始指向栈底
        push    cnt
        mov     bx, offset ary
        push    bx
        xor     ax, ax
        call    addrec
        mov		sum, ax
        mov     ax, 4c00h
        int     21h
main    endp
addrec  proc    near
        push    bp
        mov     bp, sp
        push    bx
        mov     bx, [bp+6]        ;cnt
        test    bx, bx            ;cnt=0?
        jz      back
recur:  dec     bx
        push    bx
        mov     bx, [bp+4]
        add     bx, 2
        push    bx
        call    addrec
        mov     bx, [bp+4]
        add     ax, [bx]
back:   pop     bx
        pop     bp
        ret     4
        end     begin
        

        当CNT=2时堆栈的变化如下图：（借此了解一下栈帧）
      
    

    

    
      
        子程序参数传递——结构化参数

        格式：

        结构名    STRUC
… …
结构名    ENDS

        结构变量名    结构名    &lt;预赋值说明（给出各字段的值，用逗号分隔，不填表示缺省）&gt;

        
      
    
  
  
    宏定义

    
      
        格式：
宏名 MACRO [形参列表]
 …     ; 宏定义体
ENDM
      
      
        宏名必须以字母开头，形参可缺省，也可有多个形参（逗号分隔）
      
      
        宏定义中出现标号时，必须用LOCAL伪指令将其声明为局部标号，否则多次宏调用将出现重复标号问题

        注意：LOCAL伪指令只能用于宏定义体内部，必须是MACRO伪指令后的第一条语句，在MARCO和LOCAL之间不能有注释

                ; 将ASCII码转化为真值
        ASCTOH    MACRO
                LOCAL    ASCTOH1, ASCTOH2
                CMP        AL, ‘9’
                JBE        ASCTOH1
                CMP        AL, ‘a’
                JB        ASCTOH2
                SUB        AL, 20H
        ASCTOH2:    
                SUB        AL, 7
        ASCTOH1:    
                SUB        AL, 30H
                ENDM
        
      
    
  
  
    宏调用与宏展开

    
      
        宏调用

        格式：宏名 [实参列表]

        宏调用也称宏指令，对汇编语言源程序进行汇编时，汇编程序将对每一个宏调用作宏展开
      
      
        宏展开

        即以宏定义体替换宏名，并将宏定义提中出现的形参用与之位置相同的实参替换
      
      
        宏指令名可以与指令或伪指令的助记符相同，宏的优先级最高
可以用PURGE伪指令取消宏定义以恢复指令的原始含义，如 PURGE ADD

        eg. 显示一个字符的宏定义

        DISPCH  MACRO    CHAR
        MOV        AH, 2
        MOV        DL, CHAR
        INT        21H
        ENDM
        ; 宏调用
        DISPCH    ‘Y’
        DISPCH    BL
        DISPCH    BYTE_VAR
        

        eg. 实参作为指令操作码助记符的一部分

        
          宏展开时，’&amp;’ 前后的符号将合并
        

            LEAP     MACRO    COND, LAB
    J&amp;COND   LAB
    ENDM
    ;宏调用
    LEAP     Z, THERE
    LEAP     NC, HERE
    ;宏展开
    JZ       THERE
    JNC      HERE
        
      
    
  
  
    重复汇编

    格式：

              REPT    表达式
          ...        ;重复块
          ENDM
    
  
  
    宏与子程序对比

    
      宏是文本替换，子程序是流程转移
      宏展开发生在程序执行之前的汇编阶段，程序执行时已经没有宏了；子程序则是在程序执行时才被执行
      宏的速度更快，函数的空间更小
      程序较短且要求执行较快时适合采用宏实现；程序段较长时适合采用子程序
    
  
  
    条件汇编

    汇编程序根据条件决定是否对某一段源代码进行汇编

              IFXX    参数
              …    ;参数满足条件则汇编此块
          [ELSE]
              …    ;参数不满足条件则汇编此块
          ENDIF
    

    
      
        IF 表达式：计算表达式的值，若结果不为零则满足条件
      
      
        IFE 表达式：计算表达式的值，若结果为零则满足条件
      
      
        IFDEF 符号：若符号已在程序中定义，或者已经用EXTERN伪指令声明为外部符号，则满足条件
      
      
        IFNDEF 符号：若符号未在程序中定义且未用EXTERN伪指令声明为外部符号，则满足条件
      
      
        IFB ：若自变量为空则满足条件
      
      
        IFNB ：若自变量非空则满足条件

        eg. GOTO L, X, REL

            ;宏定义
GOTO    MACRO    L, X, REL
    	IFB    &lt;REL&gt;
    	JMP    L
    	ELSE
    	MOV    CX, X
L:      DEC    CX
    	ADD    X, CX
    	AND    CX, CX
    	J&amp;REL    L
    	ENDIF
    	ENDM
    	;宏调用
    	…
    	SUM    DW    100
   	 	…
    	GOTO    NEXT, SUM, NZ
    	GOTO    EXIT
   		 …
    	;宏展开
    	MOV    CX, SUM
NEXT:   DEC    CX
    	ADD    SUM, CX
    	AND    CX, CX
    	JNZ    NEXT
    	JMP    EXIT
        
      
    
  




练习


  
    如何将AX寄存器清零
  
  
    比较REP指令与LOOP指令：循环类型、影响标志位？
  
  
    MOV  BX,OFFEST  LIST与LEA  BX, LIST的区别？

    OFFSET属于运算符，在汇编时完成，属于立即寻址
 LEA则是在程序运行时执行，属于直接寻址
  
  
    下面的代码完成了什么操作？如果直接执行mov ax, dvar会怎么样？

    .MODEL SMALL
        .DATA
dvar    dd    12347777h, 87651111h, ?
        .CODE
START:  mov        ax,@data
        mov        ds,ax
        mov        ax, word ptr dvar[0]    ;ax=7777h
        mov        dx, word ptr dvar[2]    ;dx=1234h
        add        ax, word ptr dvar[4]    ;ax=8888h
        adc        dx, word ptr dvar[6]    ;dx=9999h
        mov        word ptr dvar[8], ax    ;dvar[8]=88h dvar[9]=88h
        mov        word ptr dvar[10], dx   ;dvar[10]=99h dvar[11]=99h
        mov        ax, dvar                ;ax=7777h(warning)
OVER:   MOV        AX, 4C00H
        INT        21H
        END        START
    

    小端存储，它是这样存的：

    
      
        
           
           
          高地址
        
      
      
        
           
           
           
        
        
           
           
           
        
        
           
           
           
        
        
          87H
          dvar[7]
           
        
        
          65H
          dvar[6]
           
        
        
          11H
          dvar[5]
           
        
        
          11H
          dvar[4]
           
        
        
          12H
          dvar[3]
           
        
        
          34H
          dvar[2]
           
        
        
          77H
          dvar[1]
           
        
        
          77H
          dvar[0]
          低地址
        
      
    
  

" />
    <meta property="og:description" content="8086指令集，汇编语言基础。

3.1 8086指令系统

3.1.1 寻址方式

指令的寻址方式就是指令中操作数的表示方式，8086的寻址方式有立即寻址、寄存器寻址、存储器寻址、串操作寻址、外设I/O端口寻址、程序转移操作寻址


  
    与数据有关的寻址方式

    
      
        立即寻址

        指令直接给出操作数的数值

        立即数只能作为源操作数，若十六进制以字母开头，要在前面加0，如0FFH

        操作位数由目的操作数决定

        eg. MOV AX,0FFFH
      
      
        寄存器寻址

        操作数存放在寄存器中，地址码为寄存器的符号

        由于寄存器在微处理器内部，所有操作都在内部进行，不执行访问内存的周期，执行速度最快

        可用于源/目的操作数

        eg. MOV DS,AX、MOV AL,31H
      
      
        存储器寻址

        操作数存储在主存中，BIU根据EU传送来的偏移地址（操作数的有效地址EA）算出物理地址后执行存取该操作数的总线周期

        
          
            直接寻址

            指令直接给出操作数的偏移地址即EA，eg. MOV AX,[2002H]，INC BYTE PTR[05A2H]

            操作数的地址也可以用符号变量表示（之前定义在数据段中的变量）

            默认段地址为DS中的地址，可通过段跨越前缀进行更改，eg. MOV AX, ES:VALUE

            规定8086的双操作数指令至少有一个操作数采用寄存器寻址或立即寻址，即两个操作数不能同时采用与存储器有关的寻址方式
          
          
            寄存器间接寻址

            操作数的EA在BX或SI/DI/BP中，eg. MOV AX,[BX]

            BX/SI/DI，段地址由DS指明

            BP，段地址由SS指明

            可通过段跨越前缀更改
          
          
            寄存器相对寻址

            操作数的EA为寄存器的内容和一个带符号的8位/16位的位移量之和

            只有BX/BP/SI/DI可用于寄存器相对寻址

            BX/SI/DI，段地址由DS指明

            BP段地址由SS指明

            可通过段跨越前缀更改

            eg. MOV AX,[SI+06H]、MOV AX,COUNT[BX] ;COUNT为常量/变量、MOV AX,[COUNT+BX] ;COUNT为常量、MOV DL,ES:STRING[SI]
          
          
            基址变址寻址

            操作数的EA为基址寄存器（BX/BP）的内容与变址寄存器（SI/DI）的和

            eg. MOV AX,[BX+SI]、MOV AX,[BX][SI]

            BX，段地址由DS指明

            BP，段地址由SS指明

            可添加段跨越前缀更改
          
          
            相对基址变址寻址

            操作数的EA为基址寄存器（BX/BP）、变址寄存器（SI/DI）的内容以及一个带符号的8位/16位偏移量的和

            BX，段地址由DS指明

            BP，段地址由SS指明

            可添加段跨越前缀更改

            eg. MOV AX,[BX+DI+08H]、MOV AX,MASK[BX][SI]、MOV,[MASK+BX+SI]
          
        
      
    
  
  
    与转移地址有关的寻址方式（程序转移寻址）
  


3.1.2 数据传送类指令


  
    MOV DST, SRC（字/字节操作，不影响标志位）

    注意：

    
      
        目的操作数不能是立即数
      
      
        两个操作数的寻址方式不能同时为存储器寻址
      
      
        两个操作数位数必须一致

        eg. MOV BYTE PTR[BX],255是对的，MOV [BX],255是错的
      
      
        CS不能作为目的操作数
      
      
        源和目的不能同时为段寄存器
      
      
        立即数不能直接送段寄存器，一般要以AX为中介

        MOV    AX,2000H
MOV    DS, AX
        
      
    
  




堆栈操作指令


  
    PUSH  SRC（字操作，不影响标志位）

    首先将SP减2，然后将SRC的低字节存入(SP)，高字节存入(SP+1)

    注意：

    
      
        不能用立即寻址（操作数不能是立即数）
      
      
        必须是字操作
      
    
  
  
    POP    DST（字操作，不影响标志位）

    首先将(SP)中的字节数据存入DST的低八位，(SP+1)的字节数据存入DST的高八位，然后将SP加2

    注意：

    
      
        不能用立即寻址（操作数不能是立即数）
      
      
        必须是字操作
      
      
        不能使用CS寄存器
      
    
  




地址传送指令


  
    LEA  REG, SRC（字操作，不影响标志位）

    将SRC的有效地址存入指定寄存器

    
      必须用存储器寻址
    
  
  
    LDS  REG, SRC（字操作，不影响标志位）

    将SRC指明的字存储单元的内容送REG，将地址为SRC+2的字存储单元的内容送DS

    
      必须用存储器寻址
    
  
  
    LES  REG, SRC（字操作，不影响标志位）

    将SRC指明的字存储单元的内容送REG，将地址为SRC+2的字存储单元的内容送ES

    
      必须用存储器寻址
    
  




零地址指令


  
    LAHF（Load AH with Flags，不影响标志位，隐含操作数为FR的低八位）

    将FR的低八位送AH
  
  
    SAHF（Store AH into Flags，影响标志位)

    将AH的内容送FR的低八位
  
  
    PUSHF（Push Flags，不影响标志位）
  
  
    POPF  （Pop Flags，影响标志位）
  





  
    XCHG  DST,SRC（字/字节操作，不影响标志位）

    交换DST和SRT的数据

    注意：

    
      
        两操作数均不能为立即数
      
      
        两操作数均不能用段寄存器
      
      
        两操作数不能同时采用与存储器有关的寻址方式
      
    

    eg. MOV AX,VAR
  




换码指令


  
    XLAT（字节操作，不影响标志位）

    将地址为[BX]+[AL]（AL高位补零）的内存单元当中的字节数据送至AL

    
  


3.1.3 位操作类指令

位操作运算指令分为逻辑运算指令和移位指令
要注意每一条位操作指令如何影响标志位


  
    AND/OR/XOR  DST, SRC（字、字节操作）

    将DST和SRT指明的操作数安位与/或/非，结果存在DST

    注意：

    
      
        DST不能是立即数
      
      
        对标志位的影响：CF=OF=0，SF、ZF、PF看结果，AF不确定
      
    

    eg. ASCII码大小写互换：第6位取反，其余位不变（和0异或不变，和1异或相当于取反），XOR AL,00100000B               [注]：这里期末考用到了
  
  
    TEST DST,SRC（字/字节操作）

    将DST指明的操作数与SRC指明的操作数按位与，只做运算，不存结果，即只影响FR

    对标志位的影响：CF=OF=0，SF、ZF、PF看结果，AF不确定
  
  
    NOT OPR（字/字节操作）

    对OPR指明的操作数按位取反，结果仍存OPR

    
      
        不能是立即数
      
      
        不影响任何标志位
      
    
  




移位指令

（个人实验供参考）关于移位大于1次时对OF位的影响：与PPT上说的不一样，事实上根据实验得到结论


  指令SHL对OF的影响：若移位完成后的符号位与未移位时的符号位相同，则OF为0，否则为1

  指令SHR/ROL/ROR/RCL/RCR对OF的影响：若移位完成后的符号位与最后一次移位完成之前的符号位相同，则OF为0，否则为1


        .MODEL SMALL
        .DATA
        .CODE
START:  MOV			AL,10101010b
        MOV			CL,2
        ;SHL        AL,CL
        ;SHR        AL,CL
        ;ROL        AL,CL
        ;ROR        AL,CL
        ;RCL        AL,CL
        ;RCR        AL,CL
OVER:   MOV     	AX, 4C00H
        INT     	21H
        END        	START




逻辑移位指令


  
    SHL  OPR,1/CL（字/字节操作）

    将OPR指明的操作数逻辑左移，空位补零，移出来的位进CF

    
      
        OPR不能是立即寻址
      
      
        SF/ZF/PF根据结果设置，AF不确定

        OF：事实上根据测试，不是只在移位次数为1时影响；而是若移位后的符号位与未移位时的符号位不同，则OF=1，否则OF=0
      
    
  
  
    SHR OPR,1/CL（字/字节操作）

    将OPR指明的操作数逻辑右移，空位补零，移出来的位进CF

    
      
        OPR不能是立即寻址
      
      
        SF/ZF/PF根据结果设置，AF不确定

        OF：最后一次移位后的符号位与最后一次的前一次移位后的符号位不同，OF=1，事实上只有移位次数为1的时候才有可能改变，因为大于一次时高位都补零了
      
    
  




算术移位指令


  
    SAL  OPR,1/CL（字/字节操作）

    将OPR指明的操作数算数左移，低位补零，移出去的位进CF

    
      
        OPR不能是立即寻址
      
      
        SF/ZF/PF根据结果设置，AF不确定

        OF：若移位完成后的符号位与最后一次移位完成之前的符号位相同，则OF为0，否则为1
      
    
  
  
    SAR  OPR,1/CL（字/字节操作）

    将OPR指明的操作数算数右移，高位补符号位，移出去的位进CF

    
      
        OPR不能是立即寻址
      
      
        SF/ZF/PF根据结果设置，AF不确定

        OF：最后一次移位后的符号位与最后一次的前一次移位后的符号位不同，OF=1，事实上只有移位次数为1的时候才有可能改变，因为大于一次时高位一直补符号位了
      
    
  




不带进位的循环移位指令


  
    ROL  OPR,1/CL（字/字节操作）

    将OPR指明的操组数循环左移，低位空出的位用高位移出的位补，同时移出的位进入CF

    
      
        不能是立即寻址
      
      
        不影响SF/ZF/PF/AF

        OF：若移位完成后的符号位与最后一次移位完成之前的符号位相同，则OF为0，否则为1
      
    
  
  
    ROR  OPR,1/CL（字/字节操作）

    将OPR指明的操组数循环右移，高位空出的位用低位移出的位补，同时移出的位进入CF

    
      
        不能是立即寻址
      
      
        不影响SF/ZF/PF/AF

        OF：若移位完成后的符号位与最后一次移位完成之前的符号位相同，则OF为0，否则为1
      
    
  




带进位循环移位指令


  
    RCL  OPR,1/CL（字/字节操作）

    将OPR指明的操作数连同CF一起循环左移（CF在左边）

    
      
        不能是立即寻址
      
      
        不影响SF/ZF/PF/AF

        OF：若移位完成后的符号位与最后一次移位完成之前的符号位相同，则OF为0，否则为1
      
    
  
  
    RCR  OPR,1.CL（字/字节操作）

    将OPR指明的操作数连同CF一起循环右移（CF在右边）

    
      
        不能是立即寻址
      
      
        不影响SF/ZF/PF/AF

        OF：若移位完成后的符号位与最后一次移位完成之前的符号位相同，则OF为0，否则为1
      
    
  


3.1.4 算术运算类指令

算术运算的操作数一定是定点无/带符号整数
双操作数指令至少有一个操作数在寄存器中/立即寻址
单操作数不允许立即寻址
要注意对标志位的影响


  
    ADD  DST,SRC（字/字节操作）

    将DST和SRT指明的操作数相加，结果保存在DST

    
      
        SF/ZF/PF/AF看运行情况
      
      
        若两个操作数符号相同，但结果的符号与操作数的符号相反，则产生溢出，OF=1，否则OF=0
      
      
        若最高位产生进位，则CF=1，否则CF=0，CF可以表示无符号数的溢出
      
    
  
  
    SUB  DST,SRC（字/字节操作）

    DST指明的操作数减SRC指明的操作数，结果保存在DST

    
      
        SF/ZF/PF/AF看运行情况
      
      
        若两个操作数符号相反，但结果的符号与减数（SRC）的符号相反，则产生溢出，OF=1，否则OF=0
      
      
        （无符号数）若被减数小于减数，则CF=1，否则CF=0
      
    
  
  
    ADC  DST,SRC（字/字节操作）

    将DST与SRC指明的操作数以及当前CF的值相加，结果保存在DST

    
      
        SF/ZF/PF/AF看运行情况
      
      
        若两个操作数符号相同，但结果的符号与操作数的符号相反，则产生溢出，OF=1，否则OF=0
      
      
        若最高位产生进位，则CF=1，否则CF=0
      
    

    eg. 32位数加法，目的操作数存放在DX（高）和AX（低）；源操作数存放在BX（高）、CX（低）

    ADD    AX, CX
ADC    DX, BX
    
  
  
    SBB  DST,SRC（字/字节操作）

    DST指明的操作数减SRC指明的操作数，再减去当前CF的值，结果存DST

    
      
        SF/ZF/PF/AF看运行情况
      
      
        若两个操作数符号相反，但结果的符号与减数（SRC）的符号相反，则产生溢出，OF=1，否则OF=0
      
      
        （无符号数）若被减数小于减数，则CF=1，否则CF=0
      
    

    eg. 32位数减法，目的操作数存放在DX（高）和AX（低）中；源操作数为立即数80004491H

    SUB    AX,4491H
SBB    DX,8000H
    
  
  
    INC  OPR

    OPR指明的操作数+1后存于OPR

    
      
        根据结果影响OF/SF/ZF/PF/AF
      
      
        不影响CF
      
    
  
  
    DEC  OPR

    OPR指明的操组数-1后存于OPR

    
      
        根据结果影响OF/SF/ZF/PF/AF
      
      
        不影响CF
      
    
  
  
    CMP  DST,SRC（字/字节操作）

    DST指明的操作数减SRC指明的操作数，只做运算，不存结果，即只改变符号位，通常后面跟条件转移指令

    
      
        SF/ZF/PF/AF看运行情况
      
      
        若两个操作数符号相反，但结果的符号与减数（SRC）的符号相反，则产生溢出，OF=1，否则OF=0
      
      
        （无符号数）若被减数小于减数，则CF=1，否则CF=0
      
    
  
  
    NEG  OPR（字/字节运算）尚存疑？

    对OPR指明的操作数求补，即按位取反后加1，结果存OPR

    
      
        相当于求相反数
      
      
        根据运算结果影响CF/OF/ZF/SF/PF/AF
      
      
        当且仅当操作数为0时CF=1，否则CF=0
      
      
        当且仅当字节运算时对-128求补或字运算时对-32768求补时OF=1，否则OF=0
      
    

    
      附：一个求负数补码的简便方法

      找到二进制表示形式下的最右边的1，对该位左边的所有位（除去符号位）按位取反

      eg. -1的二进制表示为10000001B，按如上操作后变为11111111B，即0FFH，为-1的补码
    
  
  
    MUL  SRC（字/字节操作）

    若SRC指明的操作数为8位，则将其与AL中的数相乘，结果存于AX；若SRC指明的操作数为16位，则将其与AX中的数相乘，结果的高16位存于DX，低16位存于AX

    
      
        所有操作数都是无符号数
      
      
        若乘积的高半部分位0，则CF=OF=0；否则CF=OF=1；反映乘法是否超过原有的位宽
      
      
        其余标志位无定义（不确定0/1）
      
    
  
  
    IMUL  SRC（字/字节操作）

    若SRC指明的操作数为8位，则将其与AL中的数相乘，结果存于AX；若SRC指明的操作数为16位，则将其与AX中的数相乘，结果的高16位存于DX，低16位存于AX

    
      
        所有操作数都是带符号数
      
      
        若乘积的高半部分位0，则CF=OF=0；否则CF=OF=1；反映乘法是否超过原有的位宽
      
      
        其余标志位无定义（不确定0/1）
      
    
  
  
    DIV  SRC（字/字节操作）

    若SRC为8位，则用AX中的数除以SRC指明的数，商存AL，余数存AH；若SRC为16位，则用DX（高16位）和AX（低16位）组成的32位无符号整数除以SRC指明的数，商存AX，余数存DX

    
      
        所有操作数都是无符号整数
      
      
        所有标志位均不确定
      
      
        若位宽不足以容纳商（商溢出），将自动转入0型中断处理程序，此时得到的商和余数均不确定
      
    
  
  
    IDIV  SRC（字/字节操作）

    若SRC为8位，则用AX中的数除以SRC指明的数，商存AL，余数存AH；若SRC为16位，则用DX（高16位）和AX（低16位）组成的32位无符号整数除以SRC指明的数，商存AX，余数存DX

    
      
        所有操作数都是带符号整数
      
      
        所有标志位均不确定
      
      
        商的符号根据代数除法规则确定，余数的符号同被除数
      
      
        若位宽不足以容纳商（商溢出），将自动转入0型中断处理程序，此时得到的商和余数均不确定
      
    
  
  
    CBW  （convert byte to word）

    隐含操作数AL，若AL最高位为0，则令AH=00H，若AL最高位为1，则令AH=0FFH

    
      
        不影响标志位
      
      
        符号扩展指令用于将被除数调整为合适的位宽
      
    
  
  
    CWD  （convert word to double word）

    隐含操作数AX，若AX最高位为0，则令DX=0000H，若AX最高位为1，则令DX=0FFFFH

    
      
        不影响标志位
      
      
        符号扩展指令用于将被除数调整为合适的位宽
      
    
  
  
    DAA（十进制调整指令）

    隐含操作数AL，对AL中的压缩BCD码进行修正：

    
      
        若AL的低4位在A~F之间或AF=1，则将AL的值加06H，结果存AL并将AF置1
      
      
        若AL的高4位在A~F之间或CF=1，则将AL的值加60H，结果存AL并将XF置1
        
          必须跟在ADD或ADC指令之后（AL为目的操作数）
        
      
    

    
      对OF无定义，根据结果影响所有其余标志位
    

    eg. 计算两个压缩BCD码28与68之和

    MOV    AL, 00101000B
ADD    AL, 01101000B
DAA
    
  
  
    DAS（十进制调整指令）

    隐含操作数AL，对AL中的压缩BCD码进行修正：

    
      
        若AL的低4位在A~F之间或AF=1，则将AL的值减06H，结果存AL并将AF置1
      
      
        若AL的高4位在A~F之间或CF=1，则将AL的值减60H，结果存AL并将XF置1
        
          必须跟在SUB或ASBB指令之后（AL为目的操作数）
        
      
    

    
      对OF无定义，根据结果影响所有其余标志位
    

    eg. 计算两个压缩BCD码86与97之差

    MOV    AL,10000110B
SUB    AL,10010111B
DAS
; 86+(-97)
; 0EFH-06H-60H=89H=10001001B即BCD码的-5
    
  
  
    AAA（ASCII调整指令）

    隐含操作数AL，对AL中的非压缩BCD码（或十进制数的ASCII码）进行修正：

    

    
      
        必须跟在ADD或ADC指令之后（AL为目的操作数）
      
      
        影响AF/CF，对其余标志位无定义
      
    

    eg. 已知(AX)=0535H，(BL)=39H，分析指令

    ADD    AL,BL
AAA
    

    分析：

    结果(AX)=0604H，？？意义？？不是很懂这个指令
  
  
    AAS（ASCII调整指令）

    隐含操作数AL，对AL中的非压缩BCD码（或十进制数的ASCII码）进行修正：

    

    
      
        必须跟在SUB或SBB指令之后（AL为目的操作数）
      
      
        影响AF/CF，对其余标志位无定义
      
    
  
  
    AAM（ASCII调整指令）

    隐含操作数AX，对AL中的非压缩BCD码修正：

    AL中的内容除以10，余数存AL，商存AH

    
      
        必须跟在MUL指令之后，两个操作数为非压缩BCD码（高四位均为0）
      
      
        根据AL中结果设置SF/ZF/PF，其余标志位无定义

        eg. 已知(AL)=07H，(BL)=09H，分析指令

        MUL    BL
AAM
        

        分析：
      
    
  
  
    AAD（ASCII调整指令）

    隐含操作数AX，对AX中的非压缩BCD码修正：

    (AH)*10+(AL)结果存AH，然后将AH清零

    
      必须在DIV指令之前，被除数存于AX，为非压缩BCD码（AH存十位，AL存各位且AH、AL高4位均为0）
      根据AL中结果设置SF/ZF/PF，其余标志位无定义
    

    eg. 编程实现53/3
  


3.1.5 字符串操作类指令

包括串传送、串比较、串扫描、从串取、存入串
一条串操作指令仅能完成1字节/字的操作，需要配合重复前缀指令才能实现对整个串的操作 
分别用SI和DI作为源串和目的串的指针，源串默认在数据段，但可以通过段跨越前缀修改，目的串必须在附加段
每次处理完当前指向的字符后要修改段指针，修改方向由DF决定，DF=0时，DI/SI增加，DF=1时，DI/SI减小   
DF标志位的清零和置1由指令CLD和STD完成


  
    REP  MOVS/LODS/STOS

    
      
        若CX为零则结束，否则转2
      
      
        CX=CX-1
      
      
        执行串操作指令，转1
        
          不影响标志位
        
      
    
  
  
    MOVS  DST, SRC（字/字节操作）

    MOVS/MOVSW

    将SRC指向的字节（字）存储单元的内容送至ES:DI指向的字节（字）存储单元；然后根据DF的值将SI和DI加/减1/2

    
      
        第一种形式由操作数指明字/字节操作
      
      
        第二种形式默认[DS:SI]送[ES:DI]
      
      
        别忘了设置DF

        思考：DF何时取0，何时取1？

        当源串与目的串存储空间有重合时，若源串在前，DF=1；若源串在后，DF=0
      
      
        不影响状态位
      
    
  
  
    STOS  DST

    STOSB/STOSW

    将AL（AX）的值传送至ES:DI指向的字节（字）存储单元，然后根据DF的值将DI增加/减少1/2

    
      
        第一种形式由操作数指明字/字节操作
      
      
        常用于缓冲区初始化
      
      
        不影响标志位
      
    
  
  
    LODS  SRC

    LODSB/LODSW

    将SRC指向的字节（字）存储单元送至AL（AX），然后根据DF的值将SI增加/减少1/2

    
      
        第一种形式由操作数指明字/字节操作
      
      
        不影响标志位
      
      
        一般不与REP联用
      
    
  
  
    REPE/REPZ  CMPS/SCAS

    
      
        若CX不为0且ZF=1则转2，否则结束
      
      
        CX=CX-1
      
      
        执行串操作指令，转1
        
          本身不影响标志位，影响标志位的是其后的串操作
        
      
    
  
  
    CMPS  SRC, DST

    CMPSB/CMPSW

    用SRC指向的字节（字）存储单元的内容减去ES:DI指向的字节（字）存储单元的内容，根据结果设置标志位，然后根据DF的值将SI和DI增加/减少1/2

    
      
        对符号位的影响同SUB指令
      
      
        第一种形式由操作数指明字/字节操作
      
      
        第二种形式默认[DS:SI]-[ES:DI]
      
    
  
  
    REPNZ/REPNE  CMPS/SCAS

    
      
        若CX不为0且ZF=0则转2，否则结束
      
      
        CX=CX-1
      
      
        执行串操作指令，转1
        
          指令本身不影响标志位，影响标志位的是串操作指令
        
      
    
  
  
    SCAS  DST

    SCASB/SCASW

    用AL（AX）中的内容减去ES:DI指向的字节（字）存储单元的内容，根据结果设置标志位，然后根据DF的值将DI增加/减少1/2

    
      
        对符号位影响同SUB指令
      
      
        第一种形式由操作数指明字/字节操作
      
    

    eg. 比较两个等长的字符串是否相同，相同用0表示，不同用-1表示，结果存入result字节单元

        LEA    SI,STR1
    LEA    DI,STR2
    MOV    CX,LEN    ;LEN是字符串长度
    CLD              ;DF=0
    REPZ   CMPSB
    XOR    AL,AL
    JNZ    RE        ;不为零则相等
NE: DEC    AL
RE: MOV    RESULT,AL   
    
  


3.1.6 控制转移类指令

根据功能划分：包括无条件转移、条件转移、循环、子程序调用及返回、中断及返回
根据目标地址与本指令是否在同一代码段划分：段内转移、段间转移。段内转移范围在-128~127之间，段内转移仅需目标的有效地址（CS）不变；段间转移需要确定目标的有效地址和段地址并改变IP和CS的值
寻址方式：


  
    相对寻址：用于段内转移，目标地址的有效地址为IP的当前值与指令中给出的8位或16位位移量之和
  
  
    段内寄存器寻址：段内转移的目标的有效地址为某16位寄存器的内容
  
  
    段内间接寻址：段内转移的目标的有效地址为某字存储单元的内容
  
  
    段间直接寻址：指令中直接给出目标的段地址和有效地址代替CS和IP的内容实现转移
  
  
    段间间接寻址：目标地址为存储器中连续两个字单元的内容（低地址为有效地址，高地址为段地址）
  


注意：所有的条件转移指令只能使用相对寻址的8位位移量，也就是都是段内转移，指令本身不影响标志位


  
    JMP（无条件转移指令）

    ; 段内相对转移
JMP    PROG    ; 16位
JMP    SHORT PROG    ; 8位
; 段内寄存器/间接转移
JMP    BX
JMP    WORD PTR [BX+SI]
; 段间直接转移
JMP    FAR PTR PROC    ; 4字节
; 段间间接转移
JMP    DWORD PTR [DI + BRCHTABLE]
    

    
      不影响标志位
    
  
  
    条件转移指令

    
      
        JZ/JE    JNZ/JNE

        JZ：ZF为1时跳转，否则不跳转；JNZ反之
      
      
        JS    JNS

        JS：SF为1时跳转，否则不跳转；JNS反之
      
      
        JO    JNO

        JO：OF为1时跳转，否则不跳转；JNO反之
      
      
        JP/JPE    JNP/JPO

        JP：PF为1时跳转，否则不跳转；JNP反之
      
      
        JC/JB/JNAE    JNC/JNB/JAE

        JC：CF为1时跳转，否则不跳转；JNC反之
      
      
        JA/JNBE    JNA/JBE

        JA：CF=ZF=0则跳转，否则不跳转；JNA反之

        其实JA就是高于则跳转，JNBE就是不是低于或等于也就是高于，一个意思
      
      
        JL/JNGE    JNL/JGE

        JL：$OF \oplus SF = 1$ 则跳转，否则不跳转；JNL反之

        jump if less 小于则转移
      
      
        JG/JNLE    JNG/JLE

        JG：$OF \oplus SF=0$ 且ZF为0则跳转，否则不跳转；JNG反之

        jump if greater 大于则转移
      
    

    JB/JBE/JNB/JNBE/JA/JAE/JNA/JNAE用于无符号数比较

    JL/JLE/JNL/JNLE/JG/JGE/JNG/JNGE用于带符号数比较

    
      
        JCXZ（jump if cx=zero）

        CX=0则跳转，否则不转
      
    
  
  
    循环指令

    
      
        LOOP OPR

        CX减1存CX，若CX非0，则转移至标号OPR处执行，否则按照代码顺序执行下一条指令

        
          
            属于“直到型循环”
          
          
            只能使用相对寻址的8位位移量
          
          
            不影响标志位
          
        
      
      
        LOOPZ/LOOPE

        LOOPNZ/LOOPNE

        CX减1存CX，若CX非零且ZF=1(0)，则转移至标号OPR处执行，否则按照代码顺序执行下一条指令

        
          
            只能用相对寻址的8位位移量
          
          
            不影响标志位
          
        
      
    
  
  
    子程序调用指令

    CALL DST

    DST：子程序入口地址

    
      
        段内调用：当前IP值进栈（保护断点），然后将DST指明的偏移地址送IP
      
      
        段间调用：当前CS值入栈，当前IP值入栈（保护断点，注意顺序），然后将DST指明的段地址送CS，偏移地址送IP
      
    
  
  
    子程序返回指令

    作为子程序的最后一条指令，返回主程序CALL指令后的下一条指令继续执行

    
      
        RET/RET  N

        段内返回，出栈一个字送IP（恢复断点）

        若带一个立即数N，则在上述操作完成后额外出栈N/2个字
      
      
        RETF/RETF  N

        段间返回，出栈两个字，第一个字送IP，第二个字送CS（恢复断点，注意顺序）

        若带一个立即数N，则在上述操作完成后额外出栈N/2个字
      
    

    不影响标志位
  
  
    中断指令INT

    INT  TYPE

    TYPE为0~255之间的常量

    
      
        当前标志寄存器FLAGS入栈
      
      
        当前CS、IP值入栈（注意顺序）（保护断点）
      
      
        物理地址为 $TYPE \times 4$ 的字存储单元的内容送IP，$TYPE\times 4+2$ 的字存储单元的内容送CS（寻找中断服务程序入口地址）
      
      
        将IF和TF清零（关中断）

        注：参见中断向量表

        
       - INT指令不影响除IF和TF之外的标志位
      
    

    
      关于IP和CS的入栈/出栈顺序：

      可以这么记，栈是向下生长的（地址由大到小），在栈中，保存段地址的地址总是大于保存段内偏移地址的地址
    
  
  
    中断返回指令IRET

    IRET
出栈第一个字送IP；出栈第二个字送CS；出栈第三个字送FLAGS
  
  
    系统功能调用

    以21H为总入口，再配以具体功能号（AH），常用的有：

    
      
        01H：从键盘输入一个字符并回显至屏幕
      
      
        02H：显示一个字符至屏幕（字符放在DL）
      
      
        09H：显示字符串至屏幕
      
      
        0AH：从键盘输入字符串到缓冲区
      
      
        4CH：带返回码结束
      
    
  
  
    中断指令INTO（溢出中断服务）
若OF=0，继续执行下一条指令
若OF=1：

    
      
        FLAGS入栈
      
      
        CS、IP入栈
      
      
        物理地址为10H的字存储单元的内容送IP，物理地址为12H的字存储单元的内容送CS（类型为4的中断）
      
      
        IF和TF清零
        
          INTO不影响除IF和TF以外的标志位
        
      
    
  
  
    标志操作指令（不影响其余标志位）

    
      
        CLC，将CF清零
      
      
        CMC，将CF取反
      
      
        STC，将CF置1
      
      
        CLD，将DF清零
      
      
        STD，将DF置1
      
      
        CLI，将IF清零
      
      
        STI，将IF置1

        开中断，8259A编程中，调用某中断后若想中断嵌套，必须在中断处理程序开头加上STI
      
    

    对于其他标志位无相应的清零或置1指令
  
  
    无操作指令NOP（不影响标志位）
  
  
    停机指令HLT
使处理机处于停机状态，以等待一次外部中断或RESET信号的到来，中断处理结束后继续执行后续指令
  
  
    等待指令WAIT
等待 $\overline{TEST}$ 信号有效，每五个时钟周期测试一次，有效后顺序执行下一条指令
  
  
    交权指令ESC
ESC  OPCODE, SRC
与WAIT指令一同用于与协处理器配合
  
  
    总线封锁前缀指令LOCK
可以添加在任何指令之前，在该条指令执行期间保持CPU对总线的控制权，其他处理器不能从CPU抢占总线
  


3.2 8086汇编语言的基本语法


  
    框架（简略模式）

            ;采用简化版的段定义伪指令，下一个段的开始即表示上一个段的结束
        .model small
        .stack    [常量(大小为常量个字节)默认1KB]
        .data
; ...定义的数据
; [变量名]    DB    操作数列表
; DB(define word)
; DD(define double word)
; DQ
; DT
; PORTA    EQU    20H  符号常量也可用=定义
; PTR 类型属性操作符 转换类型    类型 PTR 变量名/含变量名的表达式
        .code    [段名]
start:  mov    ax, @data     ; @data表示代码段名
        mov    ds, ax        ; 装载数据段
          
        ; ....一些操作
          
        mov    ax,4c00h
        int    21h           ; 调用21号中断结束汇编
      end    start
    
  
  
    框架（非简略模式）

    SSTACK	SEGMEN	STACK
		DB	200 DUP(0)
SSTACK	ENDS        
DATA	SEGMENT
; ORG 3000H    ; ORG规定起始地址
; ARY     DB    100,98,-1,-2,-4,7,0,100,32,1
; ARRY  DQ DUP(?)    ; DUP复制操作符,?表示只分配存储空间
DATA	ENDS
CODE    SEGMENT
        ASSUME     CS:CODE,DS:DATA,SS:SSTACK
START:  MOV     AX,DATA
        MOV     DS,AX
        MOV     AX,STACK
        MOV     SS,AX
        ; CS不需要送段寄存器
        ; ...一些操作
        MOV    AX,4C00H
        INT    21H           ; 调用21号中断结束汇编
CODE    ENDS
        END      START
    
  
  
    标识符的属性

    
      
        段属性
标号的段属性必在CS寄存器中
      
      
        偏移属性（16位无符号数）
      
      
        类型属性

        
          
            标号：NEAR/FAR
          
          
            变量名：BYTE/WORD/DWORD/QWORD/TBYTE
          
        
      
    
  
  
    常量

    
      
        常数
      
      
        字符
      
      
        字符串（可以在单引号里也可以在双引号里）
      
      
        符号常量
标识符  EQU/=  常量或常量表达式 该语句不占内存

        $：当前行的偏移地址
      
    
  
  
    变量

    
      
        DB/DW/DD/DQ/DT
      
      
        类型转换：
类型  PTR  变量名/含变量名的表达式

        JMP WORD PTR [BX]
      
    
  
  
    运算符（操作符）

    
      
        算术运算符：“+” “-” “*” “/” 和MOD
      
      
        逻辑运算符：AND/OR/XOR/NOT/SHL/SHR
      
      
        关系运算符：EQ/NE/LT/GT/LE/GE
      
      
        属性运算符：PTR/SHORT/THIS/HIGH/LOW/TYPE/LENGTH/SIZE
      
      
        地址运算符：“[]” 、“$”、 “:”、 OFFSET、SEG
      
    

    运算符出现在操作数项内部，运算在汇编时完成
  


3.3 汇编语言程序设计基础

理论不多说了，还是要编


  
    顺序结构程序设计
  
  
    分支结构程序设计

    注意跳过不该执行的分支

    
      
        eg. 显示2位压缩BCD码的值（0-99），不输出前导0，并设待显示字节数据已用DB伪指令存至变量BCD中

        	  ; 核心部分
      mov    dl, bcd
      test   dl, 0F0H    ; 按位与看看是一位数还是两位数
      jz     one
two:  mov    cl, 4
      shr    dl, cl      ; 把BCD码的十位移到ASCII的低4位
      add    dl, 30h
      mov    ah, 02h
      int    21h
      mov    dl, bcd
      and    dl, 0fh
      add    dl, 30h
one:  mov    ah, 02h
      int    21h
        
      
      
        多分支结构
跳跃表法
eg. 根据BX的低四位哪一位为1（由低到高）在屏幕上显示1、2、4、8

                .model small
        .data
var     equ        ?    ; 测试数据
tab     dw         foo1, foo2, foo3, foo4    ; ***
        .code
start:  mov        ax, @data
        mov        ds, ax
        mov        bx, var
        xor        si, si
find:   shr        bx, 1
        jnc        no
        mov        ah, 02h
        jmp        tab[si]
no:     add        si, 2
        jmp        find
foo1:   mov        dl,'1'
        jmp        over
foo2:   mov        dl,'2'
        jmp        over
foo3:   mov        dl,'4'
        jmp        over
foo4:   mov        dl,'8'
        jmp        over
over:   int        21h
        mov        ax,4c00h
        int        21h
        end        start
        

        DW标识符是将该标识符（标号、变量名、etc…）对应的段内偏移地址存入一个字单元，类似的，可用DD将某标识符的偏移地址和段地址存入两个相邻的字单元（双字，偏移地址放在低地址单元，段地址放在高地址单元
      
    
  
  
    循环结构

    
      
        计数控制
      
      
        条件控制（无条件转移指令、条件转移指令）

        eg. 输入若干学生姓名，直接按回车则结束，将其中最大者（按字典序）输出。

        		.model  small
        .data
maxlen	db      11h				;一个学生姓名的最大长度+1（回车）
actlen	db      ?      			;实际输入的字符个数
nmbuf	db      11h dup(0)		;namebuffer
rslt	db      'Result: '		;
longnm	db		0dh, 0ah, '$'	;初始化，一开始肯定比'a'小就对了
        db		10h dup(0)		;最大的名字
crlf	db		0dh, 0ah, '$'	;回车换行
        .code
start:  mov		ax, @data
        mov		ds, ax
        mov     es, ax
        cld
next:   lea     si, nmbuf
        lea		di, longnm
        lea		dx, maxlen		;把最大可输入字符数存到缓冲区第一个字节单元
        mov		ah, 0ah			;输入姓名
        int		21h
    
        lea     dx, crlf        ;输出回车换行
        dec 	ah              ;09H号，输出字符串
        int   	21h
    
        mov  	cl, actlen
        xor    	ch, ch
        jcxz	otpt            ;若CX=0则跳转，CX=0即只键入了一个回车，结束
    
        repe    cmpsb           ;比较nmbuf和longnm的大小 SI-DI
        jng     next            ;/js
        lea   	si, nmbuf       ;更新当前的最大名字
        lea  	di, longnm
        mov   	cl, actlen
        rep		movsb
    
        mov		byte ptr [di], 0dh        ;回车换行结束
        mov		byte ptr [di+1], 0ah
        mov		byte ptr [di+2], '$'
    
        jmp     next
otpt:   mov     dx, offset rslt	;因为rslf后面存的就是结果，结果里才有'$'所以一直输出到结束
         int        21h
         mov        ax, 4c00h
         int        21h
         end        start
        

        
          
            双重循环

            eg. 改进的冒泡排序

                    ;改进的冒泡排序,递增
        .model small
        .data
COUNT   EQU		11
FLAG    DB		1
        .CODE
START:  MOV        AX,@DATA
        MOV        DS,AX
        MOV        DI,3000H
        MOV        CX,COUNT    
        DEC        CX           ;外层循环次数
OLP:    MOV        DX,CX        ;暂存外层循环
        CMP        FLAG,0       ;如果上一轮没有进行交换
        JE         OVER         ;提前结束[优化]
        MOV        FLAG,0
        MOV        DI,3000H
    
ILP:    MOV        AL,[DI]
        CMP        AL,[DI+1]    ;ax-[DI+1]
        JB         STEP         ;小于则直接比较下一组
        XCHG       AL,[DI+1]    ;大于则交换
        MOV        [DI],AL
        MOV        FLAG,1       ;一轮中发生交换将FLAG置1        
STEP:   INC        DI
        LOOP       ILP
        MOV        CX,DX        ;恢复CX继续计数
        LOOP       OLP
    
OVER:   MOV        AX,4C00H
        INT        21
END     START
    
            
          
        
      
    
  
  
    子程序结构

    格式：

      过程名    PROC    [属性]
      …         ;子程序主体部分
  过程名    ENDP
    

    属性为NEAR/FAR

    eg. N的阶乘

              	;N的阶乘
STACK   SEGMENT STACK
		DB 200 DUP(0)
STACK   ENDS
DATA	SEGMENT
		N         DW 7
		RESULT    DW ?
DATA    ENDS
CODE    SEGMENT
  		ASSUME     CS:CODE,SS:STACK,DS:DATA
START:	MOV		AX,DATA
        MOV     DS,AX
        MOV     AX,N
        MOV     DX,1
        CALL    FACT
        MOV     RESULT,DX
        MOV     AX,4C00H
        INT     21H
          
FACT    PROC
        CMP     AX,0
        JNE     STEP        ;没结束
        MOV     DX,1
        RET
  
STEP:   PUSH    AX
        DEC     AX
        CALL    FACT        ;递归调用
        POP     AX
        MUL     DX
        MOV     DX,AX
        RET
FACT    ENDP
  
CODE    ENDS
		END      START
    

    
      
        子程序的参数传递——寄存器传参
适用于参数较少的时候
      
      
        子程序的参数传递——地址表传参
适用于参数较多的情况

        eg. 计算数组的累加和

                .model small
        .data
ary     dw        10 dup(?)
cnt     dw        10
sum     dw        ?
tbl     dw        3 dup(?)
        .code    
main    proc    far
begin:  mov     ax, @data
        mov     ds, ax
        mov     tbl, offset ary
        mov     tbl+2, offset cnt
        mov     tbl+4, offset sum
        mov     bx, offset tbl
        call    addtab
        mov     ax, 4c00h
        int     21h
main    endp
addtab  proc	near
        push	ax
        push	cx
        push	si
        push    di
        mov    	si, [bx]        ;数组首地址
        mov   	di, [bx+2]      ;数组元素个数
        mov     cx, [di]        ;数组元素个数送CX
        mov     di, [bx+4]      ;sum
        xor     ax, ax          ;ax存每次相加后的结果
next:   add     ax, [si]
        add     si, 2
        loop    next
        mov     [di], ax        ;结果送sum
        pop     di
        pop     si
        pop     cx
        pop     ax
        ret
addtab  endp
        end   	begin
        
      
      
        子程序的参数传递——堆栈传参
适用于子程序有嵌套、递归调用的情况，主程序将参数压栈，子程序将参数弹栈。使用堆栈传参要注意对栈的管理，最好可以画个图。

        eg. 数组累加

                .model small
        .data
ary     dw        10 dup(?)
cnt     dw        10
sum     dw        ?
        .stack
        dw        100 dup(?)
btm     dw        ?                ;栈是向下生长的
        .code    
main    proc	far
begin:  mov     ax, @data
        mov     ds, ax
        mov     sp, offset btm    ;栈顶指针，当前指向栈底
        mov     bx, offset ary    ;数组首地址
        push    bx
        mov     bx, offset cnt    ;数组元素个数
        push    bx
        mov     bx, offset sum    ;数组元素和
        push    bx
        call    addstk
        mov     ax, 4c00h
        int     21h
main    endp
addstk  proc    near
        push    bp
        mov        bp, sp
        push    ax
        push    cx
        push    si
        push    di
        mov     si, [bp+8]  ;&amp;ary
        mov     di, [bp+6]  ;&amp;cnt
        mov     cx, [di]    ;数组元素个数
        mov     di, [bp+4]	;&amp;sum
        xor     ax, ax
next:   add     ax, [si]
        add     si, 2
        loop    next
        mov     [di], ax
        pop     di
        pop     si
        pop     cx
        pop     ax
        pop     bp
        ret     6        	;额外弹出3个字（丢弃不再需要的参数）
addstk  endp
        end     begin
        

        

        BP的专门用途正是堆栈传参，BP寄存器默认与SS段寄存器配合

        递归式累加代码：

        ; 元素个数用堆栈传递，累加和用AX传递
        .model    small
        .data
ary     dw        10 dup(2)
cnt     dw        10
sum     dw        ?
        .stack
        dw    100 dup(?)
btm     dw    ?
        .code
main    proc	far
begin:  mov   	ax, @data
        mov 	ds, ax
        mov		sp, offset btm        ;栈顶指针，初始指向栈底
        push    cnt
        mov     bx, offset ary
        push    bx
        xor     ax, ax
        call    addrec
        mov		sum, ax
        mov     ax, 4c00h
        int     21h
main    endp
addrec  proc    near
        push    bp
        mov     bp, sp
        push    bx
        mov     bx, [bp+6]        ;cnt
        test    bx, bx            ;cnt=0?
        jz      back
recur:  dec     bx
        push    bx
        mov     bx, [bp+4]
        add     bx, 2
        push    bx
        call    addrec
        mov     bx, [bp+4]
        add     ax, [bx]
back:   pop     bx
        pop     bp
        ret     4
        end     begin
        

        当CNT=2时堆栈的变化如下图：（借此了解一下栈帧）
      
    

    

    
      
        子程序参数传递——结构化参数

        格式：

        结构名    STRUC
… …
结构名    ENDS

        结构变量名    结构名    &lt;预赋值说明（给出各字段的值，用逗号分隔，不填表示缺省）&gt;

        
      
    
  
  
    宏定义

    
      
        格式：
宏名 MACRO [形参列表]
 …     ; 宏定义体
ENDM
      
      
        宏名必须以字母开头，形参可缺省，也可有多个形参（逗号分隔）
      
      
        宏定义中出现标号时，必须用LOCAL伪指令将其声明为局部标号，否则多次宏调用将出现重复标号问题

        注意：LOCAL伪指令只能用于宏定义体内部，必须是MACRO伪指令后的第一条语句，在MARCO和LOCAL之间不能有注释

                ; 将ASCII码转化为真值
        ASCTOH    MACRO
                LOCAL    ASCTOH1, ASCTOH2
                CMP        AL, ‘9’
                JBE        ASCTOH1
                CMP        AL, ‘a’
                JB        ASCTOH2
                SUB        AL, 20H
        ASCTOH2:    
                SUB        AL, 7
        ASCTOH1:    
                SUB        AL, 30H
                ENDM
        
      
    
  
  
    宏调用与宏展开

    
      
        宏调用

        格式：宏名 [实参列表]

        宏调用也称宏指令，对汇编语言源程序进行汇编时，汇编程序将对每一个宏调用作宏展开
      
      
        宏展开

        即以宏定义体替换宏名，并将宏定义提中出现的形参用与之位置相同的实参替换
      
      
        宏指令名可以与指令或伪指令的助记符相同，宏的优先级最高
可以用PURGE伪指令取消宏定义以恢复指令的原始含义，如 PURGE ADD

        eg. 显示一个字符的宏定义

        DISPCH  MACRO    CHAR
        MOV        AH, 2
        MOV        DL, CHAR
        INT        21H
        ENDM
        ; 宏调用
        DISPCH    ‘Y’
        DISPCH    BL
        DISPCH    BYTE_VAR
        

        eg. 实参作为指令操作码助记符的一部分

        
          宏展开时，’&amp;’ 前后的符号将合并
        

            LEAP     MACRO    COND, LAB
    J&amp;COND   LAB
    ENDM
    ;宏调用
    LEAP     Z, THERE
    LEAP     NC, HERE
    ;宏展开
    JZ       THERE
    JNC      HERE
        
      
    
  
  
    重复汇编

    格式：

              REPT    表达式
          ...        ;重复块
          ENDM
    
  
  
    宏与子程序对比

    
      宏是文本替换，子程序是流程转移
      宏展开发生在程序执行之前的汇编阶段，程序执行时已经没有宏了；子程序则是在程序执行时才被执行
      宏的速度更快，函数的空间更小
      程序较短且要求执行较快时适合采用宏实现；程序段较长时适合采用子程序
    
  
  
    条件汇编

    汇编程序根据条件决定是否对某一段源代码进行汇编

              IFXX    参数
              …    ;参数满足条件则汇编此块
          [ELSE]
              …    ;参数不满足条件则汇编此块
          ENDIF
    

    
      
        IF 表达式：计算表达式的值，若结果不为零则满足条件
      
      
        IFE 表达式：计算表达式的值，若结果为零则满足条件
      
      
        IFDEF 符号：若符号已在程序中定义，或者已经用EXTERN伪指令声明为外部符号，则满足条件
      
      
        IFNDEF 符号：若符号未在程序中定义且未用EXTERN伪指令声明为外部符号，则满足条件
      
      
        IFB ：若自变量为空则满足条件
      
      
        IFNB ：若自变量非空则满足条件

        eg. GOTO L, X, REL

            ;宏定义
GOTO    MACRO    L, X, REL
    	IFB    &lt;REL&gt;
    	JMP    L
    	ELSE
    	MOV    CX, X
L:      DEC    CX
    	ADD    X, CX
    	AND    CX, CX
    	J&amp;REL    L
    	ENDIF
    	ENDM
    	;宏调用
    	…
    	SUM    DW    100
   	 	…
    	GOTO    NEXT, SUM, NZ
    	GOTO    EXIT
   		 …
    	;宏展开
    	MOV    CX, SUM
NEXT:   DEC    CX
    	ADD    SUM, CX
    	AND    CX, CX
    	JNZ    NEXT
    	JMP    EXIT
        
      
    
  




练习


  
    如何将AX寄存器清零
  
  
    比较REP指令与LOOP指令：循环类型、影响标志位？
  
  
    MOV  BX,OFFEST  LIST与LEA  BX, LIST的区别？

    OFFSET属于运算符，在汇编时完成，属于立即寻址
 LEA则是在程序运行时执行，属于直接寻址
  
  
    下面的代码完成了什么操作？如果直接执行mov ax, dvar会怎么样？

    .MODEL SMALL
        .DATA
dvar    dd    12347777h, 87651111h, ?
        .CODE
START:  mov        ax,@data
        mov        ds,ax
        mov        ax, word ptr dvar[0]    ;ax=7777h
        mov        dx, word ptr dvar[2]    ;dx=1234h
        add        ax, word ptr dvar[4]    ;ax=8888h
        adc        dx, word ptr dvar[6]    ;dx=9999h
        mov        word ptr dvar[8], ax    ;dvar[8]=88h dvar[9]=88h
        mov        word ptr dvar[10], dx   ;dvar[10]=99h dvar[11]=99h
        mov        ax, dvar                ;ax=7777h(warning)
OVER:   MOV        AX, 4C00H
        INT        21H
        END        START
    

    小端存储，它是这样存的：

    
      
        
           
           
          高地址
        
      
      
        
           
           
           
        
        
           
           
           
        
        
           
           
           
        
        
          87H
          dvar[7]
           
        
        
          65H
          dvar[6]
           
        
        
          11H
          dvar[5]
           
        
        
          11H
          dvar[4]
           
        
        
          12H
          dvar[3]
           
        
        
          34H
          dvar[2]
           
        
        
          77H
          dvar[1]
           
        
        
          77H
          dvar[0]
          低地址
        
      
    
  

" />
    
    <meta name="author" content="今天又刷了什么水题" />

    
    <meta property="og:title" content="【汇编与接口】 8086指令集" />
    <meta property="twitter:title" content="【汇编与接口】 8086指令集" />
    
  <!-- Async font loading -->
<script>
  window.WebFontConfig = {
      custom: {
          families: ['Spoqa Han Sans:100,300,400,700'],
          urls: ['https://spoqa.github.io/spoqa-han-sans/css/SpoqaHanSans-kr.css']
      },
      timeout: 60000
  };
  (function(d) {
      var wf = d.createElement('script'), s = d.scripts[0];
      wf.src = 'https://ajax.googleapis.com/ajax/libs/webfont/1.5.18/webfont.js';
      s.parentNode.insertBefore(wf, s);
  })(document);
</script>

<!--adobe fonts-->
<script>
    (function(d) {
      var config = {
        kitId: 'vbt3gjx',
        scriptTimeout: 3000,
        async: true
      },
      h=d.documentElement,t=setTimeout(function(){h.className=h.className.replace(/\bwf-loading\b/g,"")+" wf-inactive";},config.scriptTimeout),tk=d.createElement("script"),f=false,s=d.getElementsByTagName("script")[0],a;h.className+=" wf-loading";tk.src='https://use.typekit.net/'+config.kitId+'.js';tk.async=true;tk.onload=tk.onreadystatechange=function(){a=this.readyState;if(f||a&&a!="complete"&&a!="loaded")return;f=true;clearTimeout(t);try{Typekit.load(config)}catch(e){}};s.parentNode.insertBefore(tk,s)
    })(document);
</script> 

  <!--[if lt IE 9]>
    <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link rel="stylesheet" type="text/css" href="/style.css" />
  <link rel="alternate" type="application/rss+xml" title="今天又刷了什么水题 - 为者常成，行者常至" href="/feed.xml" />
  <link rel="shortcut icon" href="/favicon.ico">
  <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
  <script src="https://unpkg.com/feather-icons"></script>
  <script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
        inlineMath: [['$','$']]
      }
    });
  </script>

  <!-- Created with Jekyll Now - http://github.com/barryclark/jekyll-now -->

</head>

  <body>
    <div class="wrapper-sidebar">
  <header class="sidebar clearfix">
    <div class="site-info">
      
        <a href="/" class="site-avatar"><img src="/logo.jpg" /></a>
       
      <h1 class="site-name"><a href="/">今天又刷了什么水题</a></h1>
      <p class="site-description">为者常成，行者常至</p>
    </div>
  </header>

  <div class="navlist">
    <nav>
      
      
      <a href="/">首页</a>
      
      
      
      <a href="/about">关于</a>
      
      
      
      <a href="/archive">归档</a>
      
      
      
      <a href="/tags">标签</a>
      
      
      
      <a href="/categories">分类</a>
      
      
    </nav>
  </div>

  <div class="wrapper-footer-desktop">
    <footer class="footer">
      <!-- Refer to https://codepen.io/ruandre/pen/howFi -->
<ul class="svg-icon">

  
  
  

  

  
  <li><a href="mailto:hiter_sun@163.com" class="icon-8 email" title="Email"><svg viewBox="0 0 512 512"><path d="M502.3 190.8c3.9-3.1 9.7-.2 9.7 4.7V400c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V195.6c0-5 5.7-7.8 9.7-4.7 22.4 17.4 52.1 39.5 154.1 113.6 21.1 15.4 56.7 47.8 92.2 47.6 35.7.3 72-32.8 92.3-47.6 102-74.1 131.6-96.3 154-113.7zM256 320c23.2.4 56.6-29.2 73.4-41.4 132.7-96.3 142.8-104.7 173.4-128.7 5.8-4.5 9.2-11.5 9.2-18.9v-19c0-26.5-21.5-48-48-48H48C21.5 64 0 85.5 0 112v19c0 7.4 3.4 14.3 9.2 18.9 30.6 23.9 40.7 32.4 173.4 128.7 16.8 12.2 50.2 41.8 73.4 41.4z"/></svg><!--[if lt IE 9]><em>Email</em><![endif]--></a></li>
  

  

  

  
  <li><a href="https://github.com/suniven" class="icon-13 github" title="GitHub"><svg viewBox="0 0 512 512"><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg><!--[if lt IE 9]><em>GitHub</em><![endif]--></a></li>
  

  

  

  

  
  <li><a href="/feed.xml" class="icon-21 rss" title="RSS"><svg viewBox="0 0 512 512"><path d="M400 32H48C21.49 32 0 53.49 0 80v352c0 26.51 21.49 48 48 48h352c26.51 0 48-21.49 48-48V80c0-26.51-21.49-48-48-48zM112 416c-26.51 0-48-21.49-48-48s21.49-48 48-48 48 21.49 48 48-21.49 48-48 48zm157.533 0h-34.335c-6.011 0-11.051-4.636-11.442-10.634-5.214-80.05-69.243-143.92-149.123-149.123-5.997-.39-10.633-5.431-10.633-11.441v-34.335c0-6.535 5.468-11.777 11.994-11.425 110.546 5.974 198.997 94.536 204.964 204.964.352 6.526-4.89 11.994-11.425 11.994zm103.027 0h-34.334c-6.161 0-11.175-4.882-11.427-11.038-5.598-136.535-115.204-246.161-251.76-251.76C68.882 152.949 64 147.935 64 141.774V107.44c0-6.454 5.338-11.664 11.787-11.432 167.83 6.025 302.21 141.191 308.205 308.205.232 6.449-4.978 11.787-11.432 11.787z"/></svg><!--[if lt IE 9]><em>RSS</em><![endif]--></a></li>
  

  

  

  

  

</ul>



<p>Copyright (c) 2019-2021 From Gotei13 12th Div.</p>

    </footer>
  </div>
</div>

    
      <aside class="toc">
        <ul>
  <li><a href="#">【汇编与接口】 8086指令集</a>
    <ul>
      <li><a href="#31-8086指令系统">3.1 8086指令系统</a>
        <ul>
          <li><a href="#311-寻址方式">3.1.1 寻址方式</a></li>
          <li><a href="#312-数据传送类指令">3.1.2 数据传送类指令</a></li>
          <li><a href="#313-位操作类指令">3.1.3 位操作类指令</a></li>
          <li><a href="#314-算术运算类指令">3.1.4 算术运算类指令</a></li>
          <li><a href="#315-字符串操作类指令">3.1.5 字符串操作类指令</a></li>
          <li><a href="#316-控制转移类指令">3.1.6 控制转移类指令</a></li>
        </ul>
      </li>
      <li><a href="#32-8086汇编语言的基本语法">3.2 8086汇编语言的基本语法</a></li>
      <li><a href="#33-汇编语言程序设计基础">3.3 汇编语言程序设计基础</a></li>
      <li><a href="#练习">练习</a></li>
    </ul>
  </li>
</ul>
      </aside>
    

    <div id="main" role="main" class="wrapper-content">
      <div class="container">
        <article class="posts">
  <h1>【汇编与接口】 8086指令集</h1>

  <div clsss="meta">
    <span class="author">
      Sun
    </span>

    <span class="date">
      2019-12-15
    </span>

    <ul class="tag">
      
      <li>
        <a href="/tags#汇编与接口">
          汇编与接口
        </a>
      </li>
      
      <li>
        <a href="/tags#汇编语言">
          汇编语言
        </a>
      </li>
      
    </ul>
  </div>

  <div class="entry">
    <p>8086指令集，汇编语言基础。</p>

<h2 id="31-8086指令系统">3.1 8086指令系统</h2>

<h3 id="311-寻址方式">3.1.1 寻址方式</h3>

<p>指令的寻址方式就是指令中操作数的表示方式，8086的寻址方式有立即寻址、寄存器寻址、存储器寻址、串操作寻址、外设I/O端口寻址、程序转移操作寻址</p>

<ul>
  <li>
    <p>与数据有关的寻址方式</p>

    <ol>
      <li>
        <p>立即寻址</p>

        <p>指令直接给出操作数的数值</p>

        <p><strong>立即数只能作为源操作数</strong>，若十六进制以字母开头，要在前面加0，如<strong>0FFH</strong></p>

        <p>操作位数由<strong>目的操作数</strong>决定</p>

        <p>eg. <code class="language-plaintext highlighter-rouge">MOV AX,0FFFH</code></p>
      </li>
      <li>
        <p>寄存器寻址</p>

        <p>操作数存放在寄存器中，地址码为寄存器的符号</p>

        <p>由于寄存器在微处理器内部，所有操作都在内部进行，<strong>不执行访问内存的周期，执行速度最快</strong></p>

        <p>可用于源/目的操作数</p>

        <p>eg. <code class="language-plaintext highlighter-rouge">MOV DS,AX</code>、<code class="language-plaintext highlighter-rouge">MOV AL,31H</code></p>
      </li>
      <li>
        <p>存储器寻址</p>

        <p>操作数存储在主存中，BIU根据EU传送来的偏移地址（操作数的有效地址EA）算出物理地址后执行存取该操作数的总线周期</p>

        <ul>
          <li>
            <p>直接寻址</p>

            <p>指令直接给出操作数的偏移地址即EA，eg. <code class="language-plaintext highlighter-rouge">MOV AX,[2002H]</code>，<code class="language-plaintext highlighter-rouge">INC BYTE PTR[05A2H]</code></p>

            <p>操作数的地址也可以用符号变量表示（之前定义在数据段中的变量）</p>

            <p>默认段地址为DS中的地址，可通过<strong>段跨越前缀</strong>进行更改，eg. <code class="language-plaintext highlighter-rouge">MOV AX, ES:VALUE</code></p>

            <p><strong><em>规定8086的双操作数指令至少有一个操作数采用寄存器寻址或立即寻址，即两个操作数不能同时采用与存储器有关的寻址方式</em></strong></p>
          </li>
          <li>
            <p>寄存器间接寻址</p>

            <p>操作数的EA在<strong>BX或SI/DI/BP</strong>中，eg. <code class="language-plaintext highlighter-rouge">MOV AX,[BX]</code></p>

            <p><strong>BX/SI/DI，段地址由DS指明</strong></p>

            <p><strong>BP，段地址由SS指明</strong></p>

            <p>可通过段跨越前缀更改</p>
          </li>
          <li>
            <p>寄存器相对寻址</p>

            <p>操作数的EA为寄存器的内容和一个<strong>带符号</strong>的8位/16位的位移量之和</p>

            <p><strong>只有BX/BP/SI/DI可用于寄存器相对寻址</strong></p>

            <p><strong>BX/SI/DI，段地址由DS指明</strong></p>

            <p><strong>BP段地址由SS指明</strong></p>

            <p>可通过段跨越前缀更改</p>

            <p>eg. <code class="language-plaintext highlighter-rouge">MOV AX,[SI+06H]</code>、<code class="language-plaintext highlighter-rouge">MOV AX,COUNT[BX] ;COUNT为常量/变量</code>、<code class="language-plaintext highlighter-rouge">MOV AX,[COUNT+BX] ;COUNT为常量</code>、<code class="language-plaintext highlighter-rouge">MOV DL,ES:STRING[SI]</code></p>
          </li>
          <li>
            <p>基址变址寻址</p>

            <p>操作数的EA为基址寄存器（BX/BP）的内容与变址寄存器（SI/DI）的和</p>

            <p>eg. <code class="language-plaintext highlighter-rouge">MOV AX,[BX+SI]</code>、<code class="language-plaintext highlighter-rouge">MOV AX,[BX][SI]</code></p>

            <p><strong>BX，段地址由DS指明</strong></p>

            <p><strong>BP，段地址由SS指明</strong></p>

            <p>可添加段跨越前缀更改</p>
          </li>
          <li>
            <p>相对基址变址寻址</p>

            <p>操作数的EA为基址寄存器（BX/BP）、变址寄存器（SI/DI）的内容以及一个<strong>带符号</strong>的8位/16位偏移量的和</p>

            <p><strong>BX，段地址由DS指明</strong></p>

            <p><strong>BP，段地址由SS指明</strong></p>

            <p>可添加段跨越前缀更改</p>

            <p>eg. <code class="language-plaintext highlighter-rouge">MOV AX,[BX+DI+08H]</code>、<strong><code class="language-plaintext highlighter-rouge">MOV AX,MASK[BX][SI]</code></strong>、<code class="language-plaintext highlighter-rouge">MOV,[MASK+BX+SI]</code></p>
          </li>
        </ul>
      </li>
    </ol>
  </li>
  <li>
    <p>与转移地址有关的寻址方式（程序转移寻址）</p>
  </li>
</ul>

<h3 id="312-数据传送类指令">3.1.2 数据传送类指令</h3>

<ul>
  <li>
    <p>MOV DST, SRC（字/字节操作，不影响标志位）</p>

    <p><strong>注意：</strong></p>

    <ul>
      <li>
        <p>目的操作数不能是立即数</p>
      </li>
      <li>
        <p>两个操作数的寻址方式不能同时为存储器寻址</p>
      </li>
      <li>
        <p>两个操作数位数必须一致</p>

        <p>eg. <code class="language-plaintext highlighter-rouge">MOV BYTE PTR[BX],255</code>是对的，<code class="language-plaintext highlighter-rouge">MOV [BX],255</code>是错的</p>
      </li>
      <li>
        <p>CS不能作为目的操作数</p>
      </li>
      <li>
        <p>源和目的不能同时为段寄存器</p>
      </li>
      <li>
        <p>立即数不能直接送段寄存器，一般要以AX为中介</p>

        <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">MOV</span>    <span class="nb">AX</span><span class="p">,</span><span class="mh">2000H</span>
<span class="nf">MOV</span>    <span class="nb">DS</span><span class="p">,</span> <span class="nb">AX</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<hr />

<p>堆栈操作指令</p>

<ul>
  <li>
    <p>PUSH  SRC（<strong>字操作</strong>，不影响标志位）</p>

    <p>首先将SP减2，然后将SRC的低字节存入(SP)，高字节存入(SP+1)</p>

    <p><strong>注意：</strong></p>

    <ul>
      <li>
        <p>不能用立即寻址（操作数不能是立即数）</p>
      </li>
      <li>
        <p>必须是字操作</p>
      </li>
    </ul>
  </li>
  <li>
    <p>POP    DST（<strong>字操作</strong>，不影响标志位）</p>

    <p>首先将(SP)中的字节数据存入DST的低八位，(SP+1)的字节数据存入DST的高八位，然后将SP加2</p>

    <p><strong>注意：</strong></p>

    <ul>
      <li>
        <p>不能用立即寻址（操作数不能是立即数）</p>
      </li>
      <li>
        <p>必须是字操作</p>
      </li>
      <li>
        <p>不能使用CS寄存器</p>
      </li>
    </ul>
  </li>
</ul>

<hr />

<p>地址传送指令</p>

<ul>
  <li>
    <p>LEA  REG, SRC（字操作，不影响标志位）</p>

    <p>将SRC的<strong>有效地址</strong>存入指定寄存器</p>

    <ul>
      <li>必须用存储器寻址</li>
    </ul>
  </li>
  <li>
    <p>LDS  REG, SRC（字操作，不影响标志位）</p>

    <p>将SRC指明的<strong>字</strong>存储单元的内容送REG，将地址为SRC+2的<strong>字</strong>存储单元的内容送DS</p>

    <ul>
      <li>必须用存储器寻址</li>
    </ul>
  </li>
  <li>
    <p>LES  REG, SRC（字操作，不影响标志位）</p>

    <p>将SRC指明的<strong>字</strong>存储单元的内容送REG，将地址为SRC+2的<strong>字</strong>存储单元的内容送ES</p>

    <ul>
      <li>必须用存储器寻址</li>
    </ul>
  </li>
</ul>

<hr />

<p>零地址指令</p>

<ul>
  <li>
    <p>LAHF（Load AH with Flags，不影响标志位，隐含操作数为FR的低八位）</p>

    <p>将FR的低八位送AH</p>
  </li>
  <li>
    <p>SAHF（Store AH into Flags，影响标志位)</p>

    <p>将AH的内容送FR的低八位</p>
  </li>
  <li>
    <p>PUSHF（Push Flags，不影响标志位）</p>
  </li>
  <li>
    <p>POPF  （Pop Flags，影响标志位）</p>
  </li>
</ul>

<hr />

<ul>
  <li>
    <p>XCHG  DST,SRC（字/字节操作，不影响标志位）</p>

    <p>交换DST和SRT的数据</p>

    <p><strong>注意：</strong></p>

    <ul>
      <li>
        <p>两操作数均不能为立即数</p>
      </li>
      <li>
        <p>两操作数均不能用段寄存器</p>
      </li>
      <li>
        <p>两操作数不能同时采用与存储器有关的寻址方式</p>
      </li>
    </ul>

    <p>eg. <code class="language-plaintext highlighter-rouge">MOV AX,VAR</code></p>
  </li>
</ul>

<hr />

<p>换码指令</p>

<ul>
  <li>
    <p>XLAT（字节操作，不影响标志位）</p>

    <p>将地址为[BX]+[AL]（AL高位补零）的内存单元当中的字节数据送至AL</p>

    <p><img src="/assets/images/md/assembly/XLAT.png" style="zoom:67%;" /></p>
  </li>
</ul>

<h3 id="313-位操作类指令">3.1.3 位操作类指令</h3>

<p>位操作运算指令分为逻辑运算指令和移位指令<br />
<strong><em>要注意每一条位操作指令如何影响标志位</em></strong></p>

<ul>
  <li>
    <p>AND/OR/XOR  DST, SRC（字、字节操作）</p>

    <p>将DST和SRT指明的操作数安位与/或/非，结果存在DST</p>

    <p><strong>注意：</strong></p>

    <ul>
      <li>
        <p>DST不能是立即数</p>
      </li>
      <li>
        <p><strong>对标志位的影响</strong>：CF=OF=0，SF、ZF、PF看结果，AF不确定</p>
      </li>
    </ul>

    <p>eg. ASCII码大小写互换：第6位取反，其余位不变（和0异或不变，和1异或相当于取反），<code class="language-plaintext highlighter-rouge">XOR AL,00100000B</code>               [注]：这里期末考用到了</p>
  </li>
  <li>
    <p>TEST DST,SRC（字/字节操作）</p>

    <p>将DST指明的操作数与SRC指明的操作数按位与，只做运算，不存结果，即只影响FR</p>

    <p><strong>对标志位的影响</strong>：CF=OF=0，SF、ZF、PF看结果，AF不确定</p>
  </li>
  <li>
    <p>NOT OPR（字/字节操作）</p>

    <p>对OPR指明的操作数按位取反，结果仍存OPR</p>

    <ul>
      <li>
        <p>不能是立即数</p>
      </li>
      <li>
        <p><strong>不影响任何标志位</strong></p>
      </li>
    </ul>
  </li>
</ul>

<hr />

<p>移位指令</p>

<p>（个人实验供参考）<strong>关于移位大于1次时对OF位的影响</strong>：与PPT上说的不一样，事实上根据实验得到结论</p>

<blockquote>
  <p>指令SHL对OF的影响：若<strong>移位完成后的符号位与未移位时的符号位</strong>相同，则OF为0，否则为1</p>

  <p>指令SHR/ROL/ROR/RCL/RCR对OF的影响：若<strong>移位完成后的符号位与最后一次移位完成之前的符号位</strong>相同，则OF为0，否则为1</p>
</blockquote>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="nf">.MODEL</span> <span class="nv">SMALL</span>
        <span class="nf">.DATA</span>
        <span class="nf">.CODE</span>
<span class="nl">START:</span>  <span class="nf">MOV</span>			<span class="nb">AL</span><span class="p">,</span><span class="mb">10101010b</span>
        <span class="nf">MOV</span>			<span class="nb">CL</span><span class="p">,</span><span class="mi">2</span>
        <span class="c1">;SHL        AL,CL</span>
        <span class="c1">;SHR        AL,CL</span>
        <span class="c1">;ROL        AL,CL</span>
        <span class="c1">;ROR        AL,CL</span>
        <span class="c1">;RCL        AL,CL</span>
        <span class="c1">;RCR        AL,CL</span>
<span class="nl">OVER:</span>   <span class="nf">MOV</span>     	<span class="nb">AX</span><span class="p">,</span> <span class="mh">4C00H</span>
        <span class="nf">INT</span>     	<span class="mh">21H</span>
        <span class="nf">END</span>        	<span class="nv">START</span>
</code></pre></div></div>

<hr />

<p>逻辑移位指令</p>

<ul>
  <li>
    <p>SHL  OPR,1/CL（字/字节操作）</p>

    <p>将OPR指明的操作数逻辑左移，空位补零，移出来的位进CF</p>

    <ul>
      <li>
        <p>OPR不能是立即寻址</p>
      </li>
      <li>
        <p>SF/ZF/PF根据结果设置，AF不确定</p>

        <p><strong>OF</strong>：事实上根据测试，不是只在移位次数为1时影响；而是若移位后的符号位与未移位时的符号位不同，则OF=1，否则OF=0</p>
      </li>
    </ul>
  </li>
  <li>
    <p>SHR OPR,1/CL（字/字节操作）</p>

    <p>将OPR指明的操作数逻辑右移，空位补零，移出来的位进CF</p>

    <ul>
      <li>
        <p>OPR不能是立即寻址</p>
      </li>
      <li>
        <p>SF/ZF/PF根据结果设置，AF不确定</p>

        <p>OF：最后一次移位后的符号位与最后一次的前一次移位后的符号位不同，OF=1，事实上只有移位次数为1的时候才有可能改变，因为大于一次时高位都补零了</p>
      </li>
    </ul>
  </li>
</ul>

<hr />

<p>算术移位指令</p>

<ul>
  <li>
    <p>SAL  OPR,1/CL（字/字节操作）</p>

    <p>将OPR指明的操作数算数左移，低位补零，移出去的位进CF</p>

    <ul>
      <li>
        <p>OPR不能是立即寻址</p>
      </li>
      <li>
        <p>SF/ZF/PF根据结果设置，AF不确定</p>

        <p>OF：若移位完成后的符号位与最后一次移位完成之前的符号位相同，则OF为0，否则为1</p>
      </li>
    </ul>
  </li>
  <li>
    <p>SAR  OPR,1/CL（字/字节操作）</p>

    <p>将OPR指明的操作数算数右移，高位补符号位，移出去的位进CF</p>

    <ul>
      <li>
        <p>OPR不能是立即寻址</p>
      </li>
      <li>
        <p>SF/ZF/PF根据结果设置，AF不确定</p>

        <p>OF：最后一次移位后的符号位与最后一次的前一次移位后的符号位不同，OF=1，事实上只有移位次数为1的时候才有可能改变，因为大于一次时高位一直补符号位了</p>
      </li>
    </ul>
  </li>
</ul>

<hr />

<p>不带进位的循环移位指令</p>

<ul>
  <li>
    <p>ROL  OPR,1/CL（字/字节操作）</p>

    <p>将OPR指明的操组数循环左移，低位空出的位用高位移出的位补，同时移出的位进入CF</p>

    <ul>
      <li>
        <p>不能是立即寻址</p>
      </li>
      <li>
        <p><strong>不影响SF/ZF/PF/AF</strong></p>

        <p>OF：若移位完成后的符号位与最后一次移位完成之前的符号位相同，则OF为0，否则为1</p>
      </li>
    </ul>
  </li>
  <li>
    <p>ROR  OPR,1/CL（字/字节操作）</p>

    <p>将OPR指明的操组数循环右移，高位空出的位用低位移出的位补，同时移出的位进入CF</p>

    <ul>
      <li>
        <p>不能是立即寻址</p>
      </li>
      <li>
        <p><strong>不影响SF/ZF/PF/AF</strong></p>

        <p>OF：若移位完成后的符号位与最后一次移位完成之前的符号位相同，则OF为0，否则为1</p>
      </li>
    </ul>
  </li>
</ul>

<hr />

<p>带进位循环移位指令</p>

<ul>
  <li>
    <p>RCL  OPR,1/CL（字/字节操作）</p>

    <p>将OPR指明的操作数连同CF一起循环左移（CF在左边）</p>

    <ul>
      <li>
        <p>不能是立即寻址</p>
      </li>
      <li>
        <p><strong>不影响SF/ZF/PF/AF</strong></p>

        <p>OF：若移位完成后的符号位与最后一次移位完成之前的符号位相同，则OF为0，否则为1</p>
      </li>
    </ul>
  </li>
  <li>
    <p>RCR  OPR,1.CL（字/字节操作）</p>

    <p>将OPR指明的操作数连同CF一起循环右移（CF在右边）</p>

    <ul>
      <li>
        <p>不能是立即寻址</p>
      </li>
      <li>
        <p><strong>不影响SF/ZF/PF/AF</strong></p>

        <p>OF：若移位完成后的符号位与最后一次移位完成之前的符号位相同，则OF为0，否则为1</p>
      </li>
    </ul>
  </li>
</ul>

<h3 id="314-算术运算类指令">3.1.4 算术运算类指令</h3>

<p>算术运算的操作数一定是<strong>定点</strong>无/带符号整数<br />
双操作数指令至少有一个操作数在寄存器中/立即寻址<br />
单操作数不允许立即寻址<br />
<strong><em>要注意对标志位的影响</em></strong></p>

<ul>
  <li>
    <p>ADD  DST,SRC（字/字节操作）</p>

    <p>将DST和SRT指明的操作数相加，结果保存在DST</p>

    <ul>
      <li>
        <p>SF/ZF/PF/AF看运行情况</p>
      </li>
      <li>
        <p>若两个操作数符号相同，但结果的符号与操作数的符号相反，则产生溢出，OF=1，否则OF=0</p>
      </li>
      <li>
        <p>若最高位产生进位，则CF=1，否则CF=0，<strong>CF可以表示无符号数的溢出</strong></p>
      </li>
    </ul>
  </li>
  <li>
    <p>SUB  DST,SRC（字/字节操作）</p>

    <p>DST指明的操作数减SRC指明的操作数，结果保存在DST</p>

    <ul>
      <li>
        <p>SF/ZF/PF/AF看运行情况</p>
      </li>
      <li>
        <p>若两个操作数符号相反，但结果的符号与减数（SRC）的符号相反，则产生溢出，OF=1，否则OF=0</p>
      </li>
      <li>
        <p>（无符号数）若被减数小于减数，则CF=1，否则CF=0</p>
      </li>
    </ul>
  </li>
  <li>
    <p>ADC  DST,SRC（字/字节操作）</p>

    <p>将DST与SRC指明的操作数以及当前CF的值相加，结果保存在DST</p>

    <ul>
      <li>
        <p>SF/ZF/PF/AF看运行情况</p>
      </li>
      <li>
        <p>若两个操作数符号相同，但结果的符号与操作数的符号相反，则产生溢出，OF=1，否则OF=0</p>
      </li>
      <li>
        <p>若最高位产生进位，则CF=1，否则CF=0</p>
      </li>
    </ul>

    <p>eg. 32位数加法，目的操作数存放在DX（高）和AX（低）；源操作数存放在BX（高）、CX（低）</p>

    <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">ADD</span>    <span class="nb">AX</span><span class="p">,</span> <span class="nb">CX</span>
<span class="nf">ADC</span>    <span class="nb">DX</span><span class="p">,</span> <span class="nb">BX</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>SBB  DST,SRC（字/字节操作）</p>

    <p>DST指明的操作数减SRC指明的操作数，再减去当前CF的值，结果存DST</p>

    <ul>
      <li>
        <p>SF/ZF/PF/AF看运行情况</p>
      </li>
      <li>
        <p>若两个操作数符号相反，但结果的符号与减数（SRC）的符号相反，则产生溢出，OF=1，否则OF=0</p>
      </li>
      <li>
        <p>（无符号数）若被减数小于减数，则CF=1，否则CF=0</p>
      </li>
    </ul>

    <p>eg. 32位数减法，目的操作数存放在DX（高）和AX（低）中；源操作数为立即数80004491H</p>

    <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">SUB</span>    <span class="nb">AX</span><span class="p">,</span><span class="mh">4491H</span>
<span class="nf">SBB</span>    <span class="nb">DX</span><span class="p">,</span><span class="mh">8000H</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>INC  OPR</p>

    <p>OPR指明的操作数+1后存于OPR</p>

    <ul>
      <li>
        <p>根据结果影响OF/SF/ZF/PF/AF</p>
      </li>
      <li>
        <p><strong>不影响CF</strong></p>
      </li>
    </ul>
  </li>
  <li>
    <p>DEC  OPR</p>

    <p>OPR指明的操组数-1后存于OPR</p>

    <ul>
      <li>
        <p>根据结果影响OF/SF/ZF/PF/AF</p>
      </li>
      <li>
        <p><strong>不影响CF</strong></p>
      </li>
    </ul>
  </li>
  <li>
    <p>CMP  DST,SRC（字/字节操作）</p>

    <p>DST指明的操作数减SRC指明的操作数，<strong>只做运算，不存结果</strong>，即只改变符号位，通常后面跟条件转移指令</p>

    <ul>
      <li>
        <p>SF/ZF/PF/AF看运行情况</p>
      </li>
      <li>
        <p>若两个操作数符号相反，但结果的符号与减数（SRC）的符号相反，则产生溢出，OF=1，否则OF=0</p>
      </li>
      <li>
        <p>（无符号数）若被减数小于减数，则CF=1，否则CF=0</p>
      </li>
    </ul>
  </li>
  <li>
    <p>NEG  OPR（字/字节运算）<em>尚存疑？</em></p>

    <p>对OPR指明的操作数求补，即按位取反后加1，结果存OPR</p>

    <ul>
      <li>
        <p><strong>相当于求相反数</strong></p>
      </li>
      <li>
        <p>根据运算结果影响CF/OF/ZF/SF/PF/AF</p>
      </li>
      <li>
        <p><strong>当且仅当操作数为0时CF=1</strong>，否则CF=0</p>
      </li>
      <li>
        <p><strong>当且仅当字节运算时对-128求补或字运算时对-32768求补时OF=1</strong>，否则OF=0</p>
      </li>
    </ul>

    <blockquote>
      <p>附：一个求负数补码的简便方法</p>

      <p>找到二进制表示形式下的最右边的1，对该位左边的所有位（除去符号位）按位取反</p>

      <p>eg. -1的二进制表示为10000001B，按如上操作后变为11111111B，即0FFH，为-1的补码</p>
    </blockquote>
  </li>
  <li>
    <p>MUL  SRC（字/字节操作）</p>

    <p>若SRC指明的操作数为8位，则将其与AL中的数相乘，结果存于AX；若SRC指明的操作数为16位，则将其与AX中的数相乘，结果的高16位存于DX，低16位存于AX</p>

    <ul>
      <li>
        <p>所有操作数都是<strong>无符号数</strong></p>
      </li>
      <li>
        <p>若乘积的高半部分位0，则CF=OF=0；否则CF=OF=1；反映乘法是否超过原有的位宽</p>
      </li>
      <li>
        <p>其余标志位无定义（不确定0/1）</p>
      </li>
    </ul>
  </li>
  <li>
    <p>IMUL  SRC（字/字节操作）</p>

    <p>若SRC指明的操作数为8位，则将其与AL中的数相乘，结果存于AX；若SRC指明的操作数为16位，则将其与AX中的数相乘，结果的高16位存于DX，低16位存于AX</p>

    <ul>
      <li>
        <p>所有操作数都是<strong>带符号数</strong></p>
      </li>
      <li>
        <p>若乘积的高半部分位0，则CF=OF=0；否则CF=OF=1；反映乘法是否超过原有的位宽</p>
      </li>
      <li>
        <p>其余标志位无定义（不确定0/1）</p>
      </li>
    </ul>
  </li>
  <li>
    <p>DIV  SRC（字/字节操作）</p>

    <p>若SRC为8位，则用AX中的数除以SRC指明的数，商存AL，余数存AH；若SRC为16位，则用DX（高16位）和AX（低16位）组成的32位无符号整数除以SRC指明的数，商存AX，余数存DX</p>

    <ul>
      <li>
        <p>所有操作数都是<strong>无符号整数</strong></p>
      </li>
      <li>
        <p>所有标志位均不确定</p>
      </li>
      <li>
        <p>若位宽不足以容纳商（商溢出），将自动转入0型中断处理程序，此时得到的商和余数均不确定</p>
      </li>
    </ul>
  </li>
  <li>
    <p>IDIV  SRC（字/字节操作）</p>

    <p>若SRC为8位，则用AX中的数除以SRC指明的数，商存AL，余数存AH；若SRC为16位，则用DX（高16位）和AX（低16位）组成的32位无符号整数除以SRC指明的数，商存AX，余数存DX</p>

    <ul>
      <li>
        <p>所有操作数都是<strong>带符号整数</strong></p>
      </li>
      <li>
        <p>所有标志位均不确定</p>
      </li>
      <li>
        <p>商的符号根据代数除法规则确定，余数的符号同被除数</p>
      </li>
      <li>
        <p>若位宽不足以容纳商（商溢出），将自动转入0型中断处理程序，此时得到的商和余数均不确定</p>
      </li>
    </ul>
  </li>
  <li>
    <p>CBW  （convert byte to word）</p>

    <p><strong>隐含操作数AL</strong>，若AL最高位为0，则令AH=00H，若AL最高位为1，则令AH=0FFH</p>

    <ul>
      <li>
        <p><strong>不影响标志位</strong></p>
      </li>
      <li>
        <p>符号扩展指令用于将被除数调整为合适的位宽</p>
      </li>
    </ul>
  </li>
  <li>
    <p>CWD  （convert word to double word）</p>

    <p><strong>隐含操作数AX</strong>，若AX最高位为0，则令DX=0000H，若AX最高位为1，则令DX=0FFFFH</p>

    <ul>
      <li>
        <p><strong>不影响标志位</strong></p>
      </li>
      <li>
        <p>符号扩展指令用于将被除数调整为合适的位宽</p>
      </li>
    </ul>
  </li>
  <li>
    <p>DAA（十进制调整指令）</p>

    <p><strong>隐含操作数AL</strong>，对AL中的压缩BCD码进行修正：</p>

    <ol>
      <li>
        <p>若AL的低4位在A~F之间或AF=1，则将AL的值加06H，结果存AL并将AF置1</p>
      </li>
      <li>
        <p>若AL的高4位在A~F之间或CF=1，则将AL的值加60H，结果存AL并将XF置1</p>
        <ul>
          <li><strong>必须跟在ADD或ADC指令之后</strong>（AL为目的操作数）</li>
        </ul>
      </li>
    </ol>

    <ul>
      <li>对OF无定义，根据结果影响所有其余标志位</li>
    </ul>

    <p>eg. 计算两个压缩BCD码28与68之和</p>

    <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">MOV</span>    <span class="nb">AL</span><span class="p">,</span> <span class="mb">00101000B</span>
<span class="nf">ADD</span>    <span class="nb">AL</span><span class="p">,</span> <span class="mb">01101000B</span>
<span class="nf">DAA</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>DAS（十进制调整指令）</p>

    <p><strong>隐含操作数AL</strong>，对AL中的压缩BCD码进行修正：</p>

    <ol>
      <li>
        <p>若AL的低4位在A~F之间或AF=1，则将AL的值减06H，结果存AL并将AF置1</p>
      </li>
      <li>
        <p>若AL的高4位在A~F之间或CF=1，则将AL的值减60H，结果存AL并将XF置1</p>
        <ul>
          <li><strong>必须跟在SUB或ASBB指令之后</strong>（AL为目的操作数）</li>
        </ul>
      </li>
    </ol>

    <ul>
      <li>对OF无定义，根据结果影响所有其余标志位</li>
    </ul>

    <p>eg. 计算两个压缩BCD码86与97之差</p>

    <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">MOV</span>    <span class="nb">AL</span><span class="p">,</span><span class="mb">10000110B</span>
<span class="nf">SUB</span>    <span class="nb">AL</span><span class="p">,</span><span class="mb">10010111B</span>
<span class="nf">DAS</span>
<span class="c1">; 86+(-97)</span>
<span class="c1">; 0EFH-06H-60H=89H=10001001B即BCD码的-5</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>AAA（ASCII调整指令）</p>

    <p><strong>隐含操作数AL</strong>，对AL中的非压缩BCD码（或十进制数的ASCII码）进行修正：</p>

    <p><img src="/assets/images/md/assembly/AAA.png" style="zoom:80%;" /></p>

    <ul>
      <li>
        <p><strong>必须跟在ADD或ADC指令之后</strong>（AL为目的操作数）</p>
      </li>
      <li>
        <p>影响AF/CF，对其余标志位无定义</p>
      </li>
    </ul>

    <p>eg. 已知(AX)=0535H，(BL)=39H，分析指令</p>

    <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">ADD</span>    <span class="nb">AL</span><span class="p">,</span><span class="nb">BL</span>
<span class="nf">AAA</span>
</code></pre></div>    </div>

    <p>分析：</p>

    <p>结果(AX)=0604H，<em>？？意义？？</em>不是很懂这个指令</p>
  </li>
  <li>
    <p>AAS（ASCII调整指令）</p>

    <p><strong>隐含操作数AL</strong>，对AL中的非压缩BCD码（或十进制数的ASCII码）进行修正：</p>

    <p><img src="image\3\AAS.png" alt="" /></p>

    <ul>
      <li>
        <p><strong>必须跟在SUB或SBB指令之后</strong>（AL为目的操作数）</p>
      </li>
      <li>
        <p>影响AF/CF，对其余标志位无定义</p>
      </li>
    </ul>
  </li>
  <li>
    <p>AAM（ASCII调整指令）</p>

    <p><strong>隐含操作数AX</strong>，对AL中的<strong>非压缩BCD码</strong>修正：</p>

    <p>AL中的内容除以10，余数存AL，商存AH</p>

    <ul>
      <li>
        <p><strong>必须跟在MUL指令之后</strong>，两个操作数为非压缩BCD码（<strong>高四位均为0</strong>）</p>
      </li>
      <li>
        <p>根据AL中结果设置SF/ZF/PF，其余标志位无定义</p>

        <p>eg. 已知(AL)=07H，(BL)=09H，分析指令</p>

        <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">MUL</span>    <span class="nb">BL</span>
<span class="nf">AAM</span>
</code></pre></div>        </div>

        <p>分析：</p>
      </li>
    </ul>
  </li>
  <li>
    <p>AAD（ASCII调整指令）</p>

    <p><strong>隐含操作数AX</strong>，对AX中的<strong>非压缩BCD码</strong>修正：</p>

    <p>(AH)*10+(AL)结果存AH，然后将AH清零</p>

    <ul>
      <li><strong>必须在DIV指令之前</strong>，被除数存于AX，为非压缩BCD码（AH存十位，AL存各位且AH、AL高4位均为0）</li>
      <li>根据AL中结果设置SF/ZF/PF，其余标志位无定义</li>
    </ul>

    <p>eg. 编程实现53/3</p>
  </li>
</ul>

<h3 id="315-字符串操作类指令">3.1.5 字符串操作类指令</h3>

<p>包括串传送、串比较、串扫描、从串取、存入串<br />
一条串操作指令仅能完成1字节/字的操作，需要配合重复前缀指令才能实现对整个串的操作 <br />
分别用SI和DI作为源串和目的串的指针，源串默认在数据段，但可以通过段跨越前缀修改，<strong>目的串必须在附加段</strong><br />
每次处理完当前指向的字符后要修改段指针，修改方向由DF决定，DF=0时，DI/SI增加，DF=1时，DI/SI减小   <br />
<strong>DF标志位的清零和置1由指令CLD和STD完成</strong></p>

<ul>
  <li>
    <p>REP  MOVS/LODS/STOS</p>

    <ol>
      <li>
        <p>若CX为零则结束，否则转2</p>
      </li>
      <li>
        <p>CX=CX-1</p>
      </li>
      <li>
        <p>执行串操作指令，转1</p>
        <ul>
          <li>不影响标志位</li>
        </ul>
      </li>
    </ol>
  </li>
  <li>
    <p>MOVS  DST, SRC（字/字节操作）</p>

    <p>MOVS/MOVSW</p>

    <p>将SRC指向的字节（字）存储单元的内容送至ES:DI指向的字节（字）存储单元；然后根据DF的值将SI和DI加/减1/2</p>

    <ul>
      <li>
        <p>第一种形式由操作数指明字/字节操作</p>
      </li>
      <li>
        <p>第二种形式默认[DS:SI]送[ES:DI]</p>
      </li>
      <li>
        <p><strong>别忘了设置DF</strong></p>

        <p><em>思考：DF何时取0，何时取1？</em></p>

        <p>当源串与目的串存储空间有重合时，若源串在前，DF=1；若源串在后，DF=0</p>
      </li>
      <li>
        <p>不影响状态位</p>
      </li>
    </ul>
  </li>
  <li>
    <p>STOS  DST</p>

    <p>STOSB/STOSW</p>

    <p>将AL（AX）的值传送至ES:DI指向的字节（字）存储单元，然后根据DF的值将DI增加/减少1/2</p>

    <ul>
      <li>
        <p>第一种形式由操作数指明字/字节操作</p>
      </li>
      <li>
        <p>常用于缓冲区初始化</p>
      </li>
      <li>
        <p>不影响标志位</p>
      </li>
    </ul>
  </li>
  <li>
    <p>LODS  SRC</p>

    <p>LODSB/LODSW</p>

    <p>将SRC指向的字节（字）存储单元送至AL（AX），然后根据DF的值将SI增加/减少1/2</p>

    <ul>
      <li>
        <p>第一种形式由操作数指明字/字节操作</p>
      </li>
      <li>
        <p>不影响标志位</p>
      </li>
      <li>
        <p>一般不与REP联用</p>
      </li>
    </ul>
  </li>
  <li>
    <p>REPE/REPZ  CMPS/SCAS</p>

    <ol>
      <li>
        <p>若CX不为0且ZF=1则转2，否则结束</p>
      </li>
      <li>
        <p>CX=CX-1</p>
      </li>
      <li>
        <p>执行串操作指令，转1</p>
        <ul>
          <li>本身不影响标志位，影响标志位的是其后的串操作</li>
        </ul>
      </li>
    </ol>
  </li>
  <li>
    <p>CMPS  SRC, DST</p>

    <p>CMPSB/CMPSW</p>

    <p>用SRC指向的字节（字）存储单元的内容减去ES:DI指向的字节（字）存储单元的内容，根据结果设置标志位，然后根据DF的值将SI和DI增加/减少1/2</p>

    <ul>
      <li>
        <p>对符号位的影响同SUB指令</p>
      </li>
      <li>
        <p>第一种形式由操作数指明字/字节操作</p>
      </li>
      <li>
        <p>第二种形式默认[DS:SI]-[ES:DI]</p>
      </li>
    </ul>
  </li>
  <li>
    <p>REPNZ/REPNE  CMPS/SCAS</p>

    <ol>
      <li>
        <p>若CX不为0且ZF=0则转2，否则结束</p>
      </li>
      <li>
        <p>CX=CX-1</p>
      </li>
      <li>
        <p>执行串操作指令，转1</p>
        <ul>
          <li>指令本身不影响标志位，影响标志位的是串操作指令</li>
        </ul>
      </li>
    </ol>
  </li>
  <li>
    <p>SCAS  DST</p>

    <p>SCASB/SCASW</p>

    <p>用AL（AX）中的内容减去ES:DI指向的字节（字）存储单元的内容，根据结果设置标志位，然后根据DF的值将DI增加/减少1/2</p>

    <ul>
      <li>
        <p>对符号位影响同SUB指令</p>
      </li>
      <li>
        <p>第一种形式由操作数指明字/字节操作</p>
      </li>
    </ul>

    <p>eg. 比较两个等长的字符串是否相同，相同用0表示，不同用-1表示，结果存入result字节单元</p>

    <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">    </span><span class="nf">LEA</span>    <span class="nb">SI</span><span class="p">,</span><span class="nv">STR1</span>
<span class="err">    </span><span class="nf">LEA</span>    <span class="nb">DI</span><span class="p">,</span><span class="nv">STR2</span>
<span class="err">    </span><span class="nf">MOV</span>    <span class="nb">CX</span><span class="p">,</span><span class="nv">LEN</span>    <span class="c1">;LEN是字符串长度</span>
<span class="err">    </span><span class="nf">CLD</span>              <span class="c1">;DF=0</span>
    <span class="nf">REPZ</span>   <span class="nv">CMPSB</span>
    <span class="nf">XOR</span>    <span class="nb">AL</span><span class="p">,</span><span class="nb">AL</span>
    <span class="nf">JNZ</span>    <span class="nv">RE</span>        <span class="c1">;不为零则相等</span>
<span class="nl">NE:</span> <span class="nf">DEC</span>    <span class="nb">AL</span>
<span class="nl">RE:</span> <span class="nf">MOV</span>    <span class="nv">RESULT</span><span class="p">,</span><span class="nb">AL</span>   
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="316-控制转移类指令">3.1.6 控制转移类指令</h3>

<p>根据功能划分：包括无条件转移、条件转移、循环、子程序调用及返回、中断及返回<br />
根据目标地址与本指令是否在同一代码段划分：段内转移、段间转移。段内转移范围在-128~127之间，段内转移仅需目标的有效地址（CS）不变；段间转移需要确定目标的有效地址和段地址并改变IP和CS的值<br />
寻址方式：</p>

<ol>
  <li>
    <p>相对寻址：用于段内转移，目标地址的有效地址为IP的当前值与指令中给出的8位或16位位移量之<strong>和</strong></p>
  </li>
  <li>
    <p>段内寄存器寻址：段内转移的目标的有效地址为某16位寄存器的内容</p>
  </li>
  <li>
    <p>段内间接寻址：段内转移的目标的有效地址为某字存储单元的内容</p>
  </li>
  <li>
    <p>段间直接寻址：指令中直接给出目标的段地址和有效地址代替CS和IP的内容实现转移</p>
  </li>
  <li>
    <p>段间间接寻址：目标地址为存储器中连续两个字单元的内容（<strong>低地址为有效地址，高地址为段地址</strong>）</p>
  </li>
</ol>

<p><strong>注意：</strong>所有的<strong>条件</strong>转移指令只能使用相对寻址的8位位移量，<strong>也就是都是段内转移</strong>，指令本身不影响标志位</p>

<ul>
  <li>
    <p>JMP（无条件转移指令）</p>

    <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">; 段内相对转移</span>
<span class="nf">JMP</span>    <span class="nv">PROG</span>    <span class="c1">; 16位</span>
<span class="nf">JMP</span>    <span class="nv">SHORT</span> <span class="nv">PROG</span>    <span class="c1">; 8位</span>
<span class="c1">; 段内寄存器/间接转移</span>
<span class="nf">JMP</span>    <span class="nb">BX</span>
<span class="nf">JMP</span>    <span class="kt">WORD</span> <span class="nv">PTR</span> <span class="p">[</span><span class="nb">BX</span><span class="o">+</span><span class="nb">SI</span><span class="p">]</span>
<span class="c1">; 段间直接转移</span>
<span class="nf">JMP</span>    <span class="nv">FAR</span> <span class="nv">PTR</span> <span class="nv">PROC</span>    <span class="c1">; 4字节</span>
<span class="c1">; 段间间接转移</span>
<span class="nf">JMP</span>    <span class="kt">DWORD</span> <span class="nv">PTR</span> <span class="p">[</span><span class="nb">DI</span> <span class="o">+</span> <span class="nv">BRCHTABLE</span><span class="p">]</span>
</code></pre></div>    </div>

    <ul>
      <li>不影响标志位</li>
    </ul>
  </li>
  <li>
    <p>条件转移指令</p>

    <ul>
      <li>
        <p>JZ/JE    JNZ/JNE</p>

        <p>JZ：ZF为1时跳转，否则不跳转；JNZ反之</p>
      </li>
      <li>
        <p>JS    JNS</p>

        <p>JS：SF为1时跳转，否则不跳转；JNS反之</p>
      </li>
      <li>
        <p>JO    JNO</p>

        <p>JO：OF为1时跳转，否则不跳转；JNO反之</p>
      </li>
      <li>
        <p>JP/JPE    JNP/JPO</p>

        <p>JP：PF为1时跳转，否则不跳转；JNP反之</p>
      </li>
      <li>
        <p>JC/JB/JNAE    JNC/JNB/JAE</p>

        <p>JC：CF为1时跳转，否则不跳转；JNC反之</p>
      </li>
      <li>
        <p>JA/JNBE    JNA/JBE</p>

        <p>JA：CF=ZF=0则跳转，否则不跳转；JNA反之</p>

        <p>其实JA就是高于则跳转，JNBE就是不是低于或等于也就是高于，一个意思</p>
      </li>
      <li>
        <p>JL/JNGE    JNL/JGE</p>

        <p>JL：$OF \oplus SF = 1$ 则跳转，否则不跳转；JNL反之</p>

        <p>jump if less 小于则转移</p>
      </li>
      <li>
        <p>JG/JNLE    JNG/JLE</p>

        <p>JG：$OF \oplus SF=0$ 且ZF为0则跳转，否则不跳转；JNG反之</p>

        <p>jump if greater 大于则转移</p>
      </li>
    </ul>

    <p><strong>JB/JBE/JNB/JNBE/JA/JAE/JNA/JNAE用于无符号数比较</strong></p>

    <p><strong>JL/JLE/JNL/JNLE/JG/JGE/JNG/JNGE用于带符号数比较</strong></p>

    <ul>
      <li>
        <p>JCXZ（jump if cx=zero）</p>

        <p>CX=0则跳转，否则不转</p>
      </li>
    </ul>
  </li>
  <li>
    <p>循环指令</p>

    <ul>
      <li>
        <p>LOOP OPR</p>

        <p>CX减1存CX，若CX非0，则转移至标号OPR处执行，否则按照代码顺序执行下一条指令</p>

        <ul>
          <li>
            <p>属于“直到型循环”</p>
          </li>
          <li>
            <p>只能使用相对寻址的8位位移量</p>
          </li>
          <li>
            <p>不影响标志位</p>
          </li>
        </ul>
      </li>
      <li>
        <p>LOOPZ/LOOPE</p>

        <p>LOOPNZ/LOOPNE</p>

        <p>CX减1存CX，若CX非零且ZF=1(0)，则转移至标号OPR处执行，否则按照代码顺序执行下一条指令</p>

        <ul>
          <li>
            <p>只能用相对寻址的8位位移量</p>
          </li>
          <li>
            <p>不影响标志位</p>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>子程序调用指令</p>

    <p>CALL DST</p>

    <p>DST：子程序入口地址</p>

    <ul>
      <li>
        <p>段内调用：当前IP值进栈（保护断点），然后将DST指明的偏移地址送IP</p>
      </li>
      <li>
        <p>段间调用：当前CS值入栈，当前IP值入栈（保护断点，注意顺序），然后将DST指明的段地址送CS，偏移地址送IP</p>
      </li>
    </ul>
  </li>
  <li>
    <p>子程序返回指令</p>

    <p>作为子程序的最后一条指令，返回主程序CALL指令后的下一条指令继续执行</p>

    <ul>
      <li>
        <p>RET/RET  N</p>

        <p>段内返回，出栈一个字送IP（恢复断点）</p>

        <p>若带一个立即数N，则在上述操作完成后额外出栈N/2个字</p>
      </li>
      <li>
        <p>RETF/RETF  N</p>

        <p>段间返回，出栈两个字，第一个字送IP，第二个字送CS（恢复断点，注意顺序）</p>

        <p>若带一个立即数N，则在上述操作完成后额外出栈N/2个字</p>
      </li>
    </ul>

    <p>不影响标志位</p>
  </li>
  <li>
    <p>中断指令INT</p>

    <p>INT  TYPE</p>

    <p>TYPE为0~255之间的常量</p>

    <ol>
      <li>
        <p>当前标志寄存器FLAGS入栈</p>
      </li>
      <li>
        <p>当前CS、IP值入栈（注意顺序）（保护断点）</p>
      </li>
      <li>
        <p>物理地址为 $TYPE \times 4$ 的字存储单元的内容送IP，$TYPE\times 4+2$ 的字存储单元的内容送CS（寻找中断服务程序入口地址）</p>
      </li>
      <li>
        <p>将<strong>IF和TF清零</strong>（关中断）</p>

        <p>注：参见中断向量表</p>

        <p><img src="/assets/images/md/assembly/int_table.png" style="zoom: 25%;" />
       - INT指令不影响除IF和TF之外的标志位</p>
      </li>
    </ol>

    <blockquote>
      <p>关于IP和CS的入栈/出栈顺序：</p>

      <p>可以这么记，栈是向下生长的（地址由大到小），在栈中，保存段地址的地址总是大于保存段内偏移地址的地址</p>
    </blockquote>
  </li>
  <li>
    <p>中断返回指令IRET</p>

    <p>IRET<br />
出栈第一个字送IP；出栈第二个字送CS；出栈第三个字送FLAGS</p>
  </li>
  <li>
    <p>系统功能调用</p>

    <p>以21H为总入口，再配以具体功能号（AH），常用的有：</p>

    <ul>
      <li>
        <p>01H：从键盘输入一个字符并回显至屏幕</p>
      </li>
      <li>
        <p>02H：显示一个字符至屏幕（字符放在DL）</p>
      </li>
      <li>
        <p>09H：显示字符串至屏幕</p>
      </li>
      <li>
        <p>0AH：从键盘输入字符串到缓冲区</p>
      </li>
      <li>
        <p>4CH：带返回码结束</p>
      </li>
    </ul>
  </li>
  <li>
    <p>中断指令INTO（溢出中断服务）<br />
若OF=0，继续执行下一条指令<br />
若OF=1：</p>

    <ol>
      <li>
        <p>FLAGS入栈</p>
      </li>
      <li>
        <p>CS、IP入栈</p>
      </li>
      <li>
        <p>物理地址为10H的字存储单元的内容送IP，物理地址为12H的字存储单元的内容送CS（类型为4的中断）</p>
      </li>
      <li>
        <p>IF和TF清零</p>
        <ul>
          <li>INTO不影响除IF和TF以外的标志位</li>
        </ul>
      </li>
    </ol>
  </li>
  <li>
    <p>标志操作指令（不影响其余标志位）</p>

    <ul>
      <li>
        <p>CLC，将CF清零</p>
      </li>
      <li>
        <p>CMC，将CF取反</p>
      </li>
      <li>
        <p>STC，将CF置1</p>
      </li>
      <li>
        <p>CLD，将DF清零</p>
      </li>
      <li>
        <p>STD，将DF置1</p>
      </li>
      <li>
        <p>CLI，将IF清零</p>
      </li>
      <li>
        <p>STI，将IF置1</p>

        <p><strong>开中断，8259A编程中，调用某中断后若想中断嵌套，必须在中断处理程序开头加上STI</strong></p>
      </li>
    </ul>

    <p><strong>对于其他标志位无相应的清零或置1指令</strong></p>
  </li>
  <li>
    <p>无操作指令NOP（不影响标志位）</p>
  </li>
  <li>
    <p>停机指令HLT<br />
使处理机处于停机状态，以等待一次外部中断或RESET信号的到来，中断处理结束后继续执行后续指令</p>
  </li>
  <li>
    <p>等待指令WAIT<br />
等待 $\overline{TEST}$ 信号有效，每五个时钟周期测试一次，有效后顺序执行下一条指令</p>
  </li>
  <li>
    <p>交权指令ESC<br />
ESC  OPCODE, SRC<br />
与WAIT指令一同用于与协处理器配合</p>
  </li>
  <li>
    <p>总线封锁前缀指令LOCK<br />
可以添加在任何指令之前，在该条指令执行期间保持CPU对总线的控制权，其他处理器不能从CPU抢占总线</p>
  </li>
</ul>

<h2 id="32-8086汇编语言的基本语法">3.2 8086汇编语言的基本语法</h2>

<ul>
  <li>
    <p>框架（简略模式）</p>

    <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="c1">;采用简化版的段定义伪指令，下一个段的开始即表示上一个段的结束</span>
        <span class="nf">.model</span> <span class="nv">small</span>
        <span class="nf">.stack</span>    <span class="p">[</span><span class="err">常量</span><span class="p">(</span><span class="err">大小为常量个字节</span><span class="p">)</span><span class="err">默认</span><span class="mi">1</span><span class="nv">KB</span><span class="p">]</span>
        <span class="nf">.data</span>
<span class="c1">; ...定义的数据</span>
<span class="c1">; [变量名]    DB    操作数列表</span>
<span class="c1">; DB(define word)</span>
<span class="c1">; DD(define double word)</span>
<span class="c1">; DQ</span>
<span class="c1">; DT</span>
<span class="c1">; PORTA    EQU    20H  符号常量也可用=定义</span>
<span class="c1">; PTR 类型属性操作符 转换类型    类型 PTR 变量名/含变量名的表达式</span>
        <span class="nf">.code</span>    <span class="p">[</span><span class="err">段名</span><span class="p">]</span>
<span class="nl">start:</span>  <span class="nf">mov</span>    <span class="nb">ax</span><span class="p">,</span> <span class="err">@</span><span class="nv">data</span>     <span class="c1">; @data表示代码段名</span>
        <span class="nf">mov</span>    <span class="nb">ds</span><span class="p">,</span> <span class="nb">ax</span>        <span class="c1">; 装载数据段</span>
          
        <span class="c1">; ....一些操作</span>
          
        <span class="nf">mov</span>    <span class="nb">ax</span><span class="p">,</span><span class="mh">4c00h</span>
        <span class="nf">int</span>    <span class="mh">21h</span>           <span class="c1">; 调用21号中断结束汇编</span>
      <span class="nf">end</span>    <span class="nv">start</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>框架（非简略模式）</p>

    <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">SSTACK</span>	<span class="ow">SEG</span><span class="nv">MEN</span>	<span class="nv">STACK</span>
		<span class="kd">DB</span>	<span class="mi">200</span> <span class="nv">DUP</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="nf">SSTACK</span>	<span class="nv">ENDS</span>        
<span class="nf">DATA</span>	<span class="ow">SEG</span><span class="nv">MENT</span>
<span class="c1">; ORG 3000H    ; ORG规定起始地址</span>
<span class="c1">; ARY     DB    100,98,-1,-2,-4,7,0,100,32,1</span>
<span class="c1">; ARRY  DQ DUP(?)    ; DUP复制操作符,?表示只分配存储空间</span>
<span class="nf">DATA</span>	<span class="nv">ENDS</span>
<span class="nf">CODE</span>    <span class="ow">SEG</span><span class="nv">MENT</span>
        <span class="nf">ASSUME</span>     <span class="nb">CS</span><span class="p">:</span><span class="nv">CODE</span><span class="p">,</span><span class="nb">DS</span><span class="p">:</span><span class="nv">DATA</span><span class="p">,</span><span class="nb">SS</span><span class="p">:</span><span class="nb">SS</span><span class="nv">TACK</span>
<span class="nl">START:</span>  <span class="nf">MOV</span>     <span class="nb">AX</span><span class="p">,</span><span class="nv">DATA</span>
        <span class="nf">MOV</span>     <span class="nb">DS</span><span class="p">,</span><span class="nb">AX</span>
        <span class="nf">MOV</span>     <span class="nb">AX</span><span class="p">,</span><span class="nv">STACK</span>
        <span class="nf">MOV</span>     <span class="nb">SS</span><span class="p">,</span><span class="nb">AX</span>
        <span class="c1">; CS不需要送段寄存器</span>
        <span class="c1">; ...一些操作</span>
        <span class="nf">MOV</span>    <span class="nb">AX</span><span class="p">,</span><span class="mh">4C00H</span>
        <span class="nf">INT</span>    <span class="mh">21H</span>           <span class="c1">; 调用21号中断结束汇编</span>
<span class="nf">CODE</span>    <span class="nv">ENDS</span>
        <span class="nf">END</span>      <span class="nv">START</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>标识符的属性</p>

    <ul>
      <li>
        <p>段属性<br />
标号的段属性必在CS寄存器中</p>
      </li>
      <li>
        <p>偏移属性（16位无符号数）</p>
      </li>
      <li>
        <p>类型属性</p>

        <ul>
          <li>
            <p>标号：NEAR/FAR</p>
          </li>
          <li>
            <p>变量名：BYTE/WORD/DWORD/QWORD/TBYTE</p>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>常量</p>

    <ul>
      <li>
        <p>常数</p>
      </li>
      <li>
        <p>字符</p>
      </li>
      <li>
        <p>字符串（可以在单引号里也可以在双引号里）</p>
      </li>
      <li>
        <p>符号常量<br />
标识符  EQU/=  常量或常量表达式 <strong>该语句不占内存</strong></p>

        <p>$：当前行的偏移地址</p>
      </li>
    </ul>
  </li>
  <li>
    <p>变量</p>

    <ul>
      <li>
        <p>DB/DW/DD/DQ/DT</p>
      </li>
      <li>
        <p>类型转换：<br />
类型  PTR  变量名/含变量名的表达式</p>

        <p><code class="language-plaintext highlighter-rouge">JMP WORD PTR [BX]</code></p>
      </li>
    </ul>
  </li>
  <li>
    <p>运算符（操作符）</p>

    <ul>
      <li>
        <p>算术运算符：“+” “-” “*” “/” 和MOD</p>
      </li>
      <li>
        <p>逻辑运算符：AND/OR/XOR/NOT/SHL/SHR</p>
      </li>
      <li>
        <p>关系运算符：EQ/NE/LT/GT/LE/GE</p>
      </li>
      <li>
        <p>属性运算符：PTR/SHORT/THIS/HIGH/LOW/TYPE/LENGTH/SIZE</p>
      </li>
      <li>
        <p>地址运算符：“[]” 、“$”、 “:”、 OFFSET、SEG</p>
      </li>
    </ul>

    <p>运算符出现在<strong>操作数项内部</strong>，运算在<strong>汇编时完成</strong></p>
  </li>
</ul>

<h2 id="33-汇编语言程序设计基础">3.3 汇编语言程序设计基础</h2>

<p>理论不多说了，还是要编</p>

<ul>
  <li>
    <p>顺序结构程序设计</p>
  </li>
  <li>
    <p>分支结构程序设计</p>

    <p><strong>注意跳过不该执行的分支</strong></p>

    <ul>
      <li>
        <p>eg. 显示2位压缩BCD码的值（0-99），不输出前导0，并设待显示字节数据已用DB伪指令存至变量BCD中</p>

        <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	  <span class="c1">; 核心部分</span>
      <span class="nf">mov</span>    <span class="nb">dl</span><span class="p">,</span> <span class="nv">bcd</span>
      <span class="nf">test</span>   <span class="nb">dl</span><span class="p">,</span> <span class="mh">0F0H</span>    <span class="c1">; 按位与看看是一位数还是两位数</span>
      <span class="nf">jz</span>     <span class="nv">one</span>
<span class="nl">two:</span>  <span class="nf">mov</span>    <span class="nb">cl</span><span class="p">,</span> <span class="mi">4</span>
      <span class="nf">shr</span>    <span class="nb">dl</span><span class="p">,</span> <span class="nb">cl</span>      <span class="c1">; 把BCD码的十位移到ASCII的低4位</span>
      <span class="nf">add</span>    <span class="nb">dl</span><span class="p">,</span> <span class="mh">30h</span>
      <span class="nf">mov</span>    <span class="nb">ah</span><span class="p">,</span> <span class="mh">02h</span>
      <span class="nf">int</span>    <span class="mh">21h</span>
      <span class="nf">mov</span>    <span class="nb">dl</span><span class="p">,</span> <span class="nv">bcd</span>
      <span class="nf">and</span>    <span class="nb">dl</span><span class="p">,</span> <span class="mh">0fh</span>
      <span class="nf">add</span>    <span class="nb">dl</span><span class="p">,</span> <span class="mh">30h</span>
<span class="nl">one:</span>  <span class="nf">mov</span>    <span class="nb">ah</span><span class="p">,</span> <span class="mh">02h</span>
      <span class="nf">int</span>    <span class="mh">21h</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>多分支结构<br />
<strong>跳跃表法</strong><br />
eg. 根据BX的低四位哪一位为1（由低到高）在屏幕上显示1、2、4、8</p>

        <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="nf">.model</span> <span class="nv">small</span>
        <span class="nf">.data</span>
<span class="no">var</span><span class="kd">     equ</span>        <span class="nv">?</span>    <span class="c1">; 测试数据</span>
<span class="nf">tab</span>     <span class="nv">dw</span>         <span class="nv">foo1</span><span class="p">,</span> <span class="nv">foo2</span><span class="p">,</span> <span class="nv">foo3</span><span class="p">,</span> <span class="nv">foo4</span>    <span class="c1">; ***</span>
        <span class="nf">.code</span>
<span class="nl">start:</span>  <span class="nf">mov</span>        <span class="nb">ax</span><span class="p">,</span> <span class="err">@</span><span class="nv">data</span>
        <span class="nf">mov</span>        <span class="nb">ds</span><span class="p">,</span> <span class="nb">ax</span>
        <span class="nf">mov</span>        <span class="nb">bx</span><span class="p">,</span> <span class="nv">var</span>
        <span class="nf">xor</span>        <span class="nb">si</span><span class="p">,</span> <span class="nb">si</span>
<span class="nl">find:</span>   <span class="nf">shr</span>        <span class="nb">bx</span><span class="p">,</span> <span class="mi">1</span>
        <span class="nf">jnc</span>        <span class="nv">no</span>
        <span class="nf">mov</span>        <span class="nb">ah</span><span class="p">,</span> <span class="mh">02h</span>
        <span class="nf">jmp</span>        <span class="nv">tab</span><span class="p">[</span><span class="nb">si</span><span class="p">]</span>
<span class="nl">no:</span>     <span class="nf">add</span>        <span class="nb">si</span><span class="p">,</span> <span class="mi">2</span>
        <span class="nf">jmp</span>        <span class="nv">find</span>
<span class="nl">foo1:</span>   <span class="nf">mov</span>        <span class="nb">dl</span><span class="p">,</span><span class="s">'1'</span>
        <span class="nf">jmp</span>        <span class="nv">over</span>
<span class="nl">foo2:</span>   <span class="nf">mov</span>        <span class="nb">dl</span><span class="p">,</span><span class="s">'2'</span>
        <span class="nf">jmp</span>        <span class="nv">over</span>
<span class="nl">foo3:</span>   <span class="nf">mov</span>        <span class="nb">dl</span><span class="p">,</span><span class="s">'4'</span>
        <span class="nf">jmp</span>        <span class="nv">over</span>
<span class="nl">foo4:</span>   <span class="nf">mov</span>        <span class="nb">dl</span><span class="p">,</span><span class="s">'8'</span>
        <span class="nf">jmp</span>        <span class="nv">over</span>
<span class="nl">over:</span>   <span class="nf">int</span>        <span class="mh">21h</span>
        <span class="nf">mov</span>        <span class="nb">ax</span><span class="p">,</span><span class="mh">4c00h</span>
        <span class="nf">int</span>        <span class="mh">21h</span>
        <span class="nf">end</span>        <span class="nv">start</span>
</code></pre></div>        </div>

        <p><strong>DW标识符</strong>是将该标识符（标号、变量名、etc…）对应的段内偏移地址存入一个字单元，类似的，<strong>可用DD将某标识符的偏移地址和段地址存入两个相邻的字单元（双字，偏移地址放在低地址单元，段地址放在高地址单元</strong></p>
      </li>
    </ul>
  </li>
  <li>
    <p>循环结构</p>

    <ul>
      <li>
        <p>计数控制</p>
      </li>
      <li>
        <p>条件控制（无条件转移指令、条件转移指令）</p>

        <p>eg. 输入若干学生姓名，直接按回车则结束，将其中最大者（按字典序）输出。</p>

        <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>		<span class="nf">.model</span>  <span class="nv">small</span>
        <span class="nf">.data</span>
<span class="nf">maxlen</span>	<span class="nv">db</span>      <span class="mh">11h</span>				<span class="c1">;一个学生姓名的最大长度+1（回车）</span>
<span class="nf">actlen</span>	<span class="nv">db</span>      <span class="nv">?</span>      			<span class="c1">;实际输入的字符个数</span>
<span class="nf">nmbuf</span>	<span class="nv">db</span>      <span class="mh">11h</span> <span class="nv">dup</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>		<span class="c1">;namebuffer</span>
<span class="nf">rslt</span>	<span class="nv">db</span>      <span class="s">'Result: '</span>		<span class="c1">;</span>
<span class="nf">longnm</span>	<span class="nv">db</span>		<span class="mh">0dh</span><span class="p">,</span> <span class="mh">0ah</span><span class="p">,</span> <span class="s">'$'</span>	<span class="c1">;初始化，一开始肯定比'a'小就对了</span>
        <span class="kd">db</span>		<span class="mh">10h</span> <span class="nv">dup</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>		<span class="c1">;最大的名字</span>
<span class="nf">crlf</span>	<span class="nv">db</span>		<span class="mh">0dh</span><span class="p">,</span> <span class="mh">0ah</span><span class="p">,</span> <span class="s">'$'</span>	<span class="c1">;回车换行</span>
        <span class="nf">.code</span>
<span class="nl">start:</span>  <span class="nf">mov</span>		<span class="nb">ax</span><span class="p">,</span> <span class="err">@</span><span class="nv">data</span>
        <span class="nf">mov</span>		<span class="nb">ds</span><span class="p">,</span> <span class="nb">ax</span>
        <span class="nf">mov</span>     <span class="nb">es</span><span class="p">,</span> <span class="nb">ax</span>
        <span class="nf">cld</span>
<span class="nl">next:</span>   <span class="nf">lea</span>     <span class="nb">si</span><span class="p">,</span> <span class="nv">nmbuf</span>
        <span class="nf">lea</span>		<span class="nb">di</span><span class="p">,</span> <span class="nv">longnm</span>
        <span class="nf">lea</span>		<span class="nb">dx</span><span class="p">,</span> <span class="nv">maxlen</span>		<span class="c1">;把最大可输入字符数存到缓冲区第一个字节单元</span>
        <span class="nf">mov</span>		<span class="nb">ah</span><span class="p">,</span> <span class="mh">0ah</span>			<span class="c1">;输入姓名</span>
        <span class="nf">int</span>		<span class="mh">21h</span>
    
        <span class="nf">lea</span>     <span class="nb">dx</span><span class="p">,</span> <span class="nv">crlf</span>        <span class="c1">;输出回车换行</span>
        <span class="nf">dec</span> 	<span class="nb">ah</span>              <span class="c1">;09H号，输出字符串</span>
        <span class="nf">int</span>   	<span class="mh">21h</span>
    
        <span class="nf">mov</span>  	<span class="nb">cl</span><span class="p">,</span> <span class="nv">actlen</span>
        <span class="nf">xor</span>    	<span class="nb">ch</span><span class="p">,</span> <span class="nb">ch</span>
        <span class="nf">jcxz</span>	<span class="nv">otpt</span>            <span class="c1">;若CX=0则跳转，CX=0即只键入了一个回车，结束</span>
    
        <span class="nf">repe</span>    <span class="nv">cmpsb</span>           <span class="c1">;比较nmbuf和longnm的大小 SI-DI</span>
        <span class="nf">jng</span>     <span class="nv">next</span>            <span class="c1">;/js</span>
        <span class="nf">lea</span>   	<span class="nb">si</span><span class="p">,</span> <span class="nv">nmbuf</span>       <span class="c1">;更新当前的最大名字</span>
        <span class="nf">lea</span>  	<span class="nb">di</span><span class="p">,</span> <span class="nv">longnm</span>
        <span class="nf">mov</span>   	<span class="nb">cl</span><span class="p">,</span> <span class="nv">actlen</span>
        <span class="nf">rep</span>		<span class="nv">movsb</span>
    
        <span class="nf">mov</span>		<span class="kt">byte</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">di</span><span class="p">],</span> <span class="mh">0dh</span>        <span class="c1">;回车换行结束</span>
        <span class="nf">mov</span>		<span class="kt">byte</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">di</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="mh">0ah</span>
        <span class="nf">mov</span>		<span class="kt">byte</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">di</span><span class="o">+</span><span class="mi">2</span><span class="p">],</span> <span class="s">'$'</span>
    
        <span class="nf">jmp</span>     <span class="nv">next</span>
<span class="nl">otpt:</span>   <span class="nf">mov</span>     <span class="nb">dx</span><span class="p">,</span> <span class="nv">offset</span> <span class="nv">rslt</span>	<span class="c1">;因为rslf后面存的就是结果，结果里才有'$'所以一直输出到结束</span>
         <span class="nf">int</span>        <span class="mh">21h</span>
         <span class="nf">mov</span>        <span class="nb">ax</span><span class="p">,</span> <span class="mh">4c00h</span>
         <span class="nf">int</span>        <span class="mh">21h</span>
         <span class="nf">end</span>        <span class="nv">start</span>
</code></pre></div>        </div>

        <ul>
          <li>
            <p>双重循环</p>

            <p>eg. 改进的冒泡排序</p>

            <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="c1">;改进的冒泡排序,递增</span>
        <span class="nf">.model</span> <span class="nv">small</span>
        <span class="nf">.data</span>
<span class="no">COUNT</span><span class="kd">   EQU</span>		<span class="mi">11</span>
<span class="nf">FLAG</span>    <span class="nv">DB</span>		<span class="mi">1</span>
        <span class="nf">.CODE</span>
<span class="nl">START:</span>  <span class="nf">MOV</span>        <span class="nb">AX</span><span class="p">,</span><span class="err">@</span><span class="nv">DATA</span>
        <span class="nf">MOV</span>        <span class="nb">DS</span><span class="p">,</span><span class="nb">AX</span>
        <span class="nf">MOV</span>        <span class="nb">DI</span><span class="p">,</span><span class="mh">3000H</span>
        <span class="nf">MOV</span>        <span class="nb">CX</span><span class="p">,</span><span class="nv">COUNT</span>    
        <span class="nf">DEC</span>        <span class="nb">CX</span>           <span class="c1">;外层循环次数</span>
<span class="nl">OLP:</span>    <span class="nf">MOV</span>        <span class="nb">DX</span><span class="p">,</span><span class="nb">CX</span>        <span class="c1">;暂存外层循环</span>
        <span class="nf">CMP</span>        <span class="nv">FLAG</span><span class="p">,</span><span class="mi">0</span>       <span class="c1">;如果上一轮没有进行交换</span>
        <span class="nf">JE</span>         <span class="nv">OVER</span>         <span class="c1">;提前结束[优化]</span>
        <span class="nf">MOV</span>        <span class="nv">FLAG</span><span class="p">,</span><span class="mi">0</span>
        <span class="nf">MOV</span>        <span class="nb">DI</span><span class="p">,</span><span class="mh">3000H</span>
    
<span class="nl">ILP:</span>    <span class="nf">MOV</span>        <span class="nb">AL</span><span class="p">,[</span><span class="nb">DI</span><span class="p">]</span>
        <span class="nf">CMP</span>        <span class="nb">AL</span><span class="p">,[</span><span class="nb">DI</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>    <span class="c1">;ax-[DI+1]</span>
        <span class="nf">JB</span>         <span class="nv">STEP</span>         <span class="c1">;小于则直接比较下一组</span>
        <span class="nf">XCHG</span>       <span class="nb">AL</span><span class="p">,[</span><span class="nb">DI</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>    <span class="c1">;大于则交换</span>
        <span class="nf">MOV</span>        <span class="p">[</span><span class="nb">DI</span><span class="p">],</span><span class="nb">AL</span>
        <span class="nf">MOV</span>        <span class="nv">FLAG</span><span class="p">,</span><span class="mi">1</span>       <span class="c1">;一轮中发生交换将FLAG置1        </span>
<span class="nl">STEP:</span>   <span class="nf">INC</span>        <span class="nb">DI</span>
        <span class="nf">LOOP</span>       <span class="nv">ILP</span>
        <span class="nf">MOV</span>        <span class="nb">CX</span><span class="p">,</span><span class="nb">DX</span>        <span class="c1">;恢复CX继续计数</span>
        <span class="nf">LOOP</span>       <span class="nv">OLP</span>
    
<span class="nl">OVER:</span>   <span class="nf">MOV</span>        <span class="nb">AX</span><span class="p">,</span><span class="mh">4C00H</span>
        <span class="nf">INT</span>        <span class="mi">21</span>
<span class="nf">END</span>     <span class="nv">START</span>
    
</code></pre></div>            </div>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>子程序结构</p>

    <p>格式：</p>

    <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="err">过程名</span>    <span class="nf">PROC</span>    <span class="p">[</span><span class="err">属性</span><span class="p">]</span>
      <span class="err">…</span>         <span class="c1">;子程序主体部分</span>
  <span class="err">过程名</span>    <span class="nf">ENDP</span>
</code></pre></div>    </div>

    <p>属性为NEAR/FAR</p>

    <p>eg. N的阶乘</p>

    <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>          	<span class="c1">;N的阶乘</span>
<span class="nf">STACK</span>   <span class="ow">SEG</span><span class="nv">MENT</span> <span class="nv">STACK</span>
		<span class="kd">DB</span> <span class="mi">200</span> <span class="nv">DUP</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="nf">STACK</span>   <span class="nv">ENDS</span>
<span class="nf">DATA</span>	<span class="ow">SEG</span><span class="nv">MENT</span>
		<span class="nf">N</span>         <span class="nv">DW</span> <span class="mi">7</span>
		<span class="nf">RESULT</span>    <span class="nv">DW</span> <span class="nv">?</span>
<span class="nf">DATA</span>    <span class="nv">ENDS</span>
<span class="nf">CODE</span>    <span class="ow">SEG</span><span class="nv">MENT</span>
  		<span class="nf">ASSUME</span>     <span class="nb">CS</span><span class="p">:</span><span class="nv">CODE</span><span class="p">,</span><span class="nb">SS</span><span class="p">:</span><span class="nv">STACK</span><span class="p">,</span><span class="nb">DS</span><span class="p">:</span><span class="nv">DATA</span>
<span class="nl">START:</span>	<span class="nf">MOV</span>		<span class="nb">AX</span><span class="p">,</span><span class="nv">DATA</span>
        <span class="nf">MOV</span>     <span class="nb">DS</span><span class="p">,</span><span class="nb">AX</span>
        <span class="nf">MOV</span>     <span class="nb">AX</span><span class="p">,</span><span class="nv">N</span>
        <span class="nf">MOV</span>     <span class="nb">DX</span><span class="p">,</span><span class="mi">1</span>
        <span class="nf">CALL</span>    <span class="nv">FACT</span>
        <span class="nf">MOV</span>     <span class="nv">RESULT</span><span class="p">,</span><span class="nb">DX</span>
        <span class="nf">MOV</span>     <span class="nb">AX</span><span class="p">,</span><span class="mh">4C00H</span>
        <span class="nf">INT</span>     <span class="mh">21H</span>
          
<span class="nf">FACT</span>    <span class="nv">PROC</span>
        <span class="nf">CMP</span>     <span class="nb">AX</span><span class="p">,</span><span class="mi">0</span>
        <span class="nf">JNE</span>     <span class="nv">STEP</span>        <span class="c1">;没结束</span>
        <span class="nf">MOV</span>     <span class="nb">DX</span><span class="p">,</span><span class="mi">1</span>
        <span class="nf">RET</span>
  
<span class="nl">STEP:</span>   <span class="nf">PUSH</span>    <span class="nb">AX</span>
        <span class="nf">DEC</span>     <span class="nb">AX</span>
        <span class="nf">CALL</span>    <span class="nv">FACT</span>        <span class="c1">;递归调用</span>
        <span class="nf">POP</span>     <span class="nb">AX</span>
        <span class="nf">MUL</span>     <span class="nb">DX</span>
        <span class="nf">MOV</span>     <span class="nb">DX</span><span class="p">,</span><span class="nb">AX</span>
        <span class="nf">RET</span>
<span class="nf">FACT</span>    <span class="nv">ENDP</span>
  
<span class="nf">CODE</span>    <span class="nv">ENDS</span>
		<span class="nf">END</span>      <span class="nv">START</span>
</code></pre></div>    </div>

    <ul>
      <li>
        <p>子程序的参数传递——寄存器传参<br />
适用于参数较少的时候</p>
      </li>
      <li>
        <p>子程序的参数传递——<strong>地址表传参</strong><br />
适用于参数较多的情况</p>

        <p>eg. 计算数组的累加和</p>

        <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="nf">.model</span> <span class="nv">small</span>
        <span class="nf">.data</span>
<span class="nf">ary</span>     <span class="nv">dw</span>        <span class="mi">10</span> <span class="nv">dup</span><span class="p">(</span><span class="nv">?</span><span class="p">)</span>
<span class="nf">cnt</span>     <span class="nv">dw</span>        <span class="mi">10</span>
<span class="nf">sum</span>     <span class="nv">dw</span>        <span class="nv">?</span>
<span class="nf">tbl</span>     <span class="nv">dw</span>        <span class="mi">3</span> <span class="nv">dup</span><span class="p">(</span><span class="nv">?</span><span class="p">)</span>
        <span class="nf">.code</span>    
<span class="nf">main</span>    <span class="nv">proc</span>    <span class="nv">far</span>
<span class="nl">begin:</span>  <span class="nf">mov</span>     <span class="nb">ax</span><span class="p">,</span> <span class="err">@</span><span class="nv">data</span>
        <span class="nf">mov</span>     <span class="nb">ds</span><span class="p">,</span> <span class="nb">ax</span>
        <span class="nf">mov</span>     <span class="nv">tbl</span><span class="p">,</span> <span class="nv">offset</span> <span class="nv">ary</span>
        <span class="nf">mov</span>     <span class="nv">tbl</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="nv">offset</span> <span class="nv">cnt</span>
        <span class="nf">mov</span>     <span class="nv">tbl</span><span class="o">+</span><span class="mi">4</span><span class="p">,</span> <span class="nv">offset</span> <span class="nv">sum</span>
        <span class="nf">mov</span>     <span class="nb">bx</span><span class="p">,</span> <span class="nv">offset</span> <span class="nv">tbl</span>
        <span class="nf">call</span>    <span class="nv">addtab</span>
        <span class="nf">mov</span>     <span class="nb">ax</span><span class="p">,</span> <span class="mh">4c00h</span>
        <span class="nf">int</span>     <span class="mh">21h</span>
<span class="nf">main</span>    <span class="nv">endp</span>
<span class="nf">addtab</span>  <span class="nv">proc</span>	<span class="nv">near</span>
        <span class="nf">push</span>	<span class="nb">ax</span>
        <span class="nf">push</span>	<span class="nb">cx</span>
        <span class="nf">push</span>	<span class="nb">si</span>
        <span class="nf">push</span>    <span class="nb">di</span>
        <span class="nf">mov</span>    	<span class="nb">si</span><span class="p">,</span> <span class="p">[</span><span class="nb">bx</span><span class="p">]</span>        <span class="c1">;数组首地址</span>
        <span class="nf">mov</span>   	<span class="nb">di</span><span class="p">,</span> <span class="p">[</span><span class="nb">bx</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>      <span class="c1">;数组元素个数</span>
        <span class="nf">mov</span>     <span class="nb">cx</span><span class="p">,</span> <span class="p">[</span><span class="nb">di</span><span class="p">]</span>        <span class="c1">;数组元素个数送CX</span>
        <span class="nf">mov</span>     <span class="nb">di</span><span class="p">,</span> <span class="p">[</span><span class="nb">bx</span><span class="o">+</span><span class="mi">4</span><span class="p">]</span>      <span class="c1">;sum</span>
        <span class="nf">xor</span>     <span class="nb">ax</span><span class="p">,</span> <span class="nb">ax</span>          <span class="c1">;ax存每次相加后的结果</span>
<span class="nl">next:</span>   <span class="nf">add</span>     <span class="nb">ax</span><span class="p">,</span> <span class="p">[</span><span class="nb">si</span><span class="p">]</span>
        <span class="nf">add</span>     <span class="nb">si</span><span class="p">,</span> <span class="mi">2</span>
        <span class="nf">loop</span>    <span class="nv">next</span>
        <span class="nf">mov</span>     <span class="p">[</span><span class="nb">di</span><span class="p">],</span> <span class="nb">ax</span>        <span class="c1">;结果送sum</span>
        <span class="nf">pop</span>     <span class="nb">di</span>
        <span class="nf">pop</span>     <span class="nb">si</span>
        <span class="nf">pop</span>     <span class="nb">cx</span>
        <span class="nf">pop</span>     <span class="nb">ax</span>
        <span class="nf">ret</span>
<span class="nf">addtab</span>  <span class="nv">endp</span>
        <span class="nf">end</span>   	<span class="nv">begin</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>子程序的参数传递——<strong>堆栈传参</strong><br />
适用于子程序有嵌套、递归调用的情况，主程序将参数压栈，子程序将参数弹栈。使用堆栈传参要注意对栈的管理，最好可以画个图。</p>

        <p>eg. 数组累加</p>

        <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="nf">.model</span> <span class="nv">small</span>
        <span class="nf">.data</span>
<span class="nf">ary</span>     <span class="nv">dw</span>        <span class="mi">10</span> <span class="nv">dup</span><span class="p">(</span><span class="nv">?</span><span class="p">)</span>
<span class="nf">cnt</span>     <span class="nv">dw</span>        <span class="mi">10</span>
<span class="nf">sum</span>     <span class="nv">dw</span>        <span class="nv">?</span>
        <span class="nf">.stack</span>
        <span class="kd">dw</span>        <span class="mi">100</span> <span class="nv">dup</span><span class="p">(</span><span class="nv">?</span><span class="p">)</span>
<span class="nf">btm</span>     <span class="nv">dw</span>        <span class="nv">?</span>                <span class="c1">;栈是向下生长的</span>
        <span class="nf">.code</span>    
<span class="nf">main</span>    <span class="nv">proc</span>	<span class="nv">far</span>
<span class="nl">begin:</span>  <span class="nf">mov</span>     <span class="nb">ax</span><span class="p">,</span> <span class="err">@</span><span class="nv">data</span>
        <span class="nf">mov</span>     <span class="nb">ds</span><span class="p">,</span> <span class="nb">ax</span>
        <span class="nf">mov</span>     <span class="nb">sp</span><span class="p">,</span> <span class="nv">offset</span> <span class="nv">btm</span>    <span class="c1">;栈顶指针，当前指向栈底</span>
        <span class="nf">mov</span>     <span class="nb">bx</span><span class="p">,</span> <span class="nv">offset</span> <span class="nv">ary</span>    <span class="c1">;数组首地址</span>
        <span class="nf">push</span>    <span class="nb">bx</span>
        <span class="nf">mov</span>     <span class="nb">bx</span><span class="p">,</span> <span class="nv">offset</span> <span class="nv">cnt</span>    <span class="c1">;数组元素个数</span>
        <span class="nf">push</span>    <span class="nb">bx</span>
        <span class="nf">mov</span>     <span class="nb">bx</span><span class="p">,</span> <span class="nv">offset</span> <span class="nv">sum</span>    <span class="c1">;数组元素和</span>
        <span class="nf">push</span>    <span class="nb">bx</span>
        <span class="nf">call</span>    <span class="nv">addstk</span>
        <span class="nf">mov</span>     <span class="nb">ax</span><span class="p">,</span> <span class="mh">4c00h</span>
        <span class="nf">int</span>     <span class="mh">21h</span>
<span class="nf">main</span>    <span class="nv">endp</span>
<span class="nf">addstk</span>  <span class="nv">proc</span>    <span class="nv">near</span>
        <span class="nf">push</span>    <span class="nb">bp</span>
        <span class="nf">mov</span>        <span class="nb">bp</span><span class="p">,</span> <span class="nb">sp</span>
        <span class="nf">push</span>    <span class="nb">ax</span>
        <span class="nf">push</span>    <span class="nb">cx</span>
        <span class="nf">push</span>    <span class="nb">si</span>
        <span class="nf">push</span>    <span class="nb">di</span>
        <span class="nf">mov</span>     <span class="nb">si</span><span class="p">,</span> <span class="p">[</span><span class="nb">bp</span><span class="o">+</span><span class="mi">8</span><span class="p">]</span>  <span class="c1">;&amp;ary</span>
        <span class="nf">mov</span>     <span class="nb">di</span><span class="p">,</span> <span class="p">[</span><span class="nb">bp</span><span class="o">+</span><span class="mi">6</span><span class="p">]</span>  <span class="c1">;&amp;cnt</span>
        <span class="nf">mov</span>     <span class="nb">cx</span><span class="p">,</span> <span class="p">[</span><span class="nb">di</span><span class="p">]</span>    <span class="c1">;数组元素个数</span>
        <span class="nf">mov</span>     <span class="nb">di</span><span class="p">,</span> <span class="p">[</span><span class="nb">bp</span><span class="o">+</span><span class="mi">4</span><span class="p">]</span>	<span class="c1">;&amp;sum</span>
        <span class="nf">xor</span>     <span class="nb">ax</span><span class="p">,</span> <span class="nb">ax</span>
<span class="nl">next:</span>   <span class="nf">add</span>     <span class="nb">ax</span><span class="p">,</span> <span class="p">[</span><span class="nb">si</span><span class="p">]</span>
        <span class="nf">add</span>     <span class="nb">si</span><span class="p">,</span> <span class="mi">2</span>
        <span class="nf">loop</span>    <span class="nv">next</span>
        <span class="nf">mov</span>     <span class="p">[</span><span class="nb">di</span><span class="p">],</span> <span class="nb">ax</span>
        <span class="nf">pop</span>     <span class="nb">di</span>
        <span class="nf">pop</span>     <span class="nb">si</span>
        <span class="nf">pop</span>     <span class="nb">cx</span>
        <span class="nf">pop</span>     <span class="nb">ax</span>
        <span class="nf">pop</span>     <span class="nb">bp</span>
        <span class="nf">ret</span>     <span class="mi">6</span>        	<span class="c1">;额外弹出3个字（丢弃不再需要的参数）</span>
<span class="nf">addstk</span>  <span class="nv">endp</span>
        <span class="nf">end</span>     <span class="nv">begin</span>
</code></pre></div>        </div>

        <p><img src="/assets/images/md/assembly/s_para1.JPG" style="zoom: 10%;" /></p>

        <p><strong>BP的专门用途正是堆栈传参</strong>，BP寄存器默认与SS段寄存器配合</p>

        <p>递归式累加代码：</p>

        <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">; 元素个数用堆栈传递，累加和用AX传递</span>
        <span class="nf">.model</span>    <span class="nv">small</span>
        <span class="nf">.data</span>
<span class="nf">ary</span>     <span class="nv">dw</span>        <span class="mi">10</span> <span class="nv">dup</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="nf">cnt</span>     <span class="nv">dw</span>        <span class="mi">10</span>
<span class="nf">sum</span>     <span class="nv">dw</span>        <span class="nv">?</span>
        <span class="nf">.stack</span>
        <span class="kd">dw</span>    <span class="mi">100</span> <span class="nv">dup</span><span class="p">(</span><span class="nv">?</span><span class="p">)</span>
<span class="nf">btm</span>     <span class="nv">dw</span>    <span class="nv">?</span>
        <span class="nf">.code</span>
<span class="nf">main</span>    <span class="nv">proc</span>	<span class="nv">far</span>
<span class="nl">begin:</span>  <span class="nf">mov</span>   	<span class="nb">ax</span><span class="p">,</span> <span class="err">@</span><span class="nv">data</span>
        <span class="nf">mov</span> 	<span class="nb">ds</span><span class="p">,</span> <span class="nb">ax</span>
        <span class="nf">mov</span>		<span class="nb">sp</span><span class="p">,</span> <span class="nv">offset</span> <span class="nv">btm</span>        <span class="c1">;栈顶指针，初始指向栈底</span>
        <span class="nf">push</span>    <span class="nv">cnt</span>
        <span class="nf">mov</span>     <span class="nb">bx</span><span class="p">,</span> <span class="nv">offset</span> <span class="nv">ary</span>
        <span class="nf">push</span>    <span class="nb">bx</span>
        <span class="nf">xor</span>     <span class="nb">ax</span><span class="p">,</span> <span class="nb">ax</span>
        <span class="nf">call</span>    <span class="nv">addrec</span>
        <span class="nf">mov</span>		<span class="nv">sum</span><span class="p">,</span> <span class="nb">ax</span>
        <span class="nf">mov</span>     <span class="nb">ax</span><span class="p">,</span> <span class="mh">4c00h</span>
        <span class="nf">int</span>     <span class="mh">21h</span>
<span class="nf">main</span>    <span class="nv">endp</span>
<span class="nf">addrec</span>  <span class="nv">proc</span>    <span class="nv">near</span>
        <span class="nf">push</span>    <span class="nb">bp</span>
        <span class="nf">mov</span>     <span class="nb">bp</span><span class="p">,</span> <span class="nb">sp</span>
        <span class="nf">push</span>    <span class="nb">bx</span>
        <span class="nf">mov</span>     <span class="nb">bx</span><span class="p">,</span> <span class="p">[</span><span class="nb">bp</span><span class="o">+</span><span class="mi">6</span><span class="p">]</span>        <span class="c1">;cnt</span>
        <span class="nf">test</span>    <span class="nb">bx</span><span class="p">,</span> <span class="nb">bx</span>            <span class="c1">;cnt=0?</span>
        <span class="nf">jz</span>      <span class="nv">back</span>
<span class="nl">recur:</span>  <span class="nf">dec</span>     <span class="nb">bx</span>
        <span class="nf">push</span>    <span class="nb">bx</span>
        <span class="nf">mov</span>     <span class="nb">bx</span><span class="p">,</span> <span class="p">[</span><span class="nb">bp</span><span class="o">+</span><span class="mi">4</span><span class="p">]</span>
        <span class="nf">add</span>     <span class="nb">bx</span><span class="p">,</span> <span class="mi">2</span>
        <span class="nf">push</span>    <span class="nb">bx</span>
        <span class="nf">call</span>    <span class="nv">addrec</span>
        <span class="nf">mov</span>     <span class="nb">bx</span><span class="p">,</span> <span class="p">[</span><span class="nb">bp</span><span class="o">+</span><span class="mi">4</span><span class="p">]</span>
        <span class="nf">add</span>     <span class="nb">ax</span><span class="p">,</span> <span class="p">[</span><span class="nb">bx</span><span class="p">]</span>
<span class="nl">back:</span>   <span class="nf">pop</span>     <span class="nb">bx</span>
        <span class="nf">pop</span>     <span class="nb">bp</span>
        <span class="nf">ret</span>     <span class="mi">4</span>
        <span class="nf">end</span>     <span class="nv">begin</span>
</code></pre></div>        </div>

        <p>当CNT=2时堆栈的变化如下图：（借此了解一下栈帧）</p>
      </li>
    </ul>

    <p><img src="/assets/images/md/assembly/s_para2.JPG" style="zoom: 20%;" /></p>

    <ul>
      <li>
        <p>子程序参数传递——<strong>结构化参数</strong></p>

        <p>格式：</p>

        <p>结构名    STRUC<br />
… …<br />
结构名    ENDS</p>

        <p>结构变量名    结构名    &lt;预赋值说明（给出各字段的值，用逗号分隔，不填表示缺省）&gt;</p>

        <p><img src="/assets/images/md/assembly/struct_para.png" style="zoom:80%;" /></p>
      </li>
    </ul>
  </li>
  <li>
    <p>宏定义</p>

    <ul>
      <li>
        <p>格式：<br />
宏名 MACRO [形参列表]<br />
 …     ; 宏定义体<br />
ENDM</p>
      </li>
      <li>
        <p>宏名必须以字母开头，形参可缺省，也可有多个形参（逗号分隔）</p>
      </li>
      <li>
        <p>宏定义中出现标号时，必须用LOCAL伪指令将其声明为局部标号，否则多次宏调用将出现重复标号问题</p>

        <p><strong>注意</strong>：LOCAL伪指令只能用于宏定义体内部，必须是MACRO伪指令后的第一条语句，在MARCO和LOCAL之间不能有注释</p>

        <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="c1">; 将ASCII码转化为真值</span>
        <span class="nf">ASCTOH</span>    <span class="nv">MACRO</span>
                <span class="nf">LOCAL</span>    <span class="nv">ASCTOH1</span><span class="p">,</span> <span class="nv">ASCTOH2</span>
                <span class="nf">CMP</span>        <span class="nb">AL</span><span class="p">,</span> <span class="err">‘</span><span class="mi">9</span><span class="err">’</span>
                <span class="nf">JBE</span>        <span class="nv">ASCTOH1</span>
                <span class="nf">CMP</span>        <span class="nb">AL</span><span class="p">,</span> <span class="err">‘</span><span class="nv">a</span><span class="err">’</span>
                <span class="nf">JB</span>        <span class="nv">ASCTOH2</span>
                <span class="nf">SUB</span>        <span class="nb">AL</span><span class="p">,</span> <span class="mh">20H</span>
        <span class="nl">ASCTOH2:</span>    
                <span class="nf">SUB</span>        <span class="nb">AL</span><span class="p">,</span> <span class="mi">7</span>
        <span class="nl">ASCTOH1:</span>    
                <span class="nf">SUB</span>        <span class="nb">AL</span><span class="p">,</span> <span class="mh">30H</span>
                <span class="nf">ENDM</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>
    <p>宏调用与宏展开</p>

    <ul>
      <li>
        <p>宏调用</p>

        <p>格式：<code class="language-plaintext highlighter-rouge">宏名 [实参列表]</code></p>

        <p>宏调用也称宏指令，对汇编语言源程序进行汇编时，汇编程序将对每一个宏调用作宏展开</p>
      </li>
      <li>
        <p>宏展开</p>

        <p>即以宏定义体替换宏名，并将宏定义提中出现的形参用与之位置相同的实参替换</p>
      </li>
      <li>
        <p>宏指令名可以与指令或伪指令的助记符相同，<strong>宏的优先级最高</strong><br />
可以用PURGE伪指令取消宏定义以恢复指令的原始含义，如 <code class="language-plaintext highlighter-rouge">PURGE ADD</code></p>

        <p>eg. 显示一个字符的宏定义</p>

        <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">DISPCH</span>  <span class="nv">MACRO</span>    <span class="nb">CH</span><span class="nv">AR</span>
        <span class="nf">MOV</span>        <span class="nb">AH</span><span class="p">,</span> <span class="mi">2</span>
        <span class="nf">MOV</span>        <span class="nb">DL</span><span class="p">,</span> <span class="nb">CH</span><span class="nv">AR</span>
        <span class="nf">INT</span>        <span class="mh">21H</span>
        <span class="nf">ENDM</span>
        <span class="c1">; 宏调用</span>
        <span class="nf">DISPCH</span>    <span class="err">‘</span><span class="nv">Y</span><span class="err">’</span>
        <span class="nf">DISPCH</span>    <span class="nb">BL</span>
        <span class="nf">DISPCH</span>    <span class="kt">BYTE</span><span class="nv">_VAR</span>
</code></pre></div>        </div>

        <p>eg. <strong>实参作为指令操作码助记符的一部分</strong></p>

        <blockquote>
          <p>宏展开时，’&amp;’ 前后的符号将合并</p>
        </blockquote>

        <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nf">LEAP</span>     <span class="nv">MACRO</span>    <span class="nv">COND</span><span class="p">,</span> <span class="nv">LAB</span>
    <span class="nf">J</span><span class="o">&amp;</span><span class="nv">COND</span>   <span class="nv">LAB</span>
    <span class="nf">ENDM</span>
    <span class="c1">;宏调用</span>
    <span class="nf">LEAP</span>     <span class="nv">Z</span><span class="p">,</span> <span class="nv">THERE</span>
    <span class="nf">LEAP</span>     <span class="nv">NC</span><span class="p">,</span> <span class="nv">HERE</span>
    <span class="c1">;宏展开</span>
    <span class="nf">JZ</span>       <span class="nv">THERE</span>
    <span class="nf">JNC</span>      <span class="nv">HERE</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>
    <p>重复汇编</p>

    <p>格式：</p>

    <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>          <span class="nf">REPT</span>    <span class="err">表达式</span>
          <span class="nf">...</span>        <span class="c1">;重复块</span>
          <span class="nf">ENDM</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>宏与子程序对比</p>

    <ul>
      <li>宏是文本替换，子程序是流程转移</li>
      <li>宏展开发生在程序执行之前的汇编阶段，程序执行时已经没有宏了；子程序则是在程序执行时才被执行</li>
      <li>宏的速度更快，函数的空间更小</li>
      <li>程序较短且要求执行较快时适合采用宏实现；程序段较长时适合采用子程序</li>
    </ul>
  </li>
  <li>
    <p>条件汇编</p>

    <p>汇编程序根据条件决定是否对某一段源代码进行汇编</p>

    <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>          <span class="nf">IFXX</span>    <span class="err">参数</span>
              <span class="err">…</span>    <span class="c1">;参数满足条件则汇编此块</span>
          <span class="err">[</span><span class="nf">ELSE</span><span class="p">]</span>
              <span class="err">…</span>    <span class="c1">;参数不满足条件则汇编此块</span>
          <span class="nf">ENDIF</span>
</code></pre></div>    </div>

    <ul>
      <li>
        <p>IF 表达式：计算表达式的值，若结果不为零则满足条件</p>
      </li>
      <li>
        <p>IFE 表达式：计算表达式的值，若结果为零则满足条件</p>
      </li>
      <li>
        <p>IFDEF 符号：若符号已在程序中定义，或者已经用EXTERN伪指令声明为外部符号，则满足条件</p>
      </li>
      <li>
        <p>IFNDEF 符号：若符号未在程序中定义且未用EXTERN伪指令声明为外部符号，则满足条件</p>
      </li>
      <li>
        <p>IFB <自变量>：若自变量为空则满足条件</自变量></p>
      </li>
      <li>
        <p>IFNB <自变量>：若自变量非空则满足条件</自变量></p>

        <p>eg. GOTO L, X, REL</p>

        <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">;宏定义</span>
<span class="nf">GOTO</span>    <span class="nv">MACRO</span>    <span class="nv">L</span><span class="p">,</span> <span class="nv">X</span><span class="p">,</span> <span class="nv">REL</span>
    	<span class="nf">IFB</span>    <span class="o">&lt;</span><span class="nv">REL</span><span class="o">&gt;</span>
    	<span class="nf">JMP</span>    <span class="nv">L</span>
    	<span class="nf">ELSE</span>
    	<span class="nf">MOV</span>    <span class="nb">CX</span><span class="p">,</span> <span class="nv">X</span>
<span class="nl">L:</span>      <span class="nf">DEC</span>    <span class="nb">CX</span>
    	<span class="nf">ADD</span>    <span class="nv">X</span><span class="p">,</span> <span class="nb">CX</span>
    	<span class="nf">AND</span>    <span class="nb">CX</span><span class="p">,</span> <span class="nb">CX</span>
    	<span class="nf">J</span><span class="o">&amp;</span><span class="nv">REL</span>    <span class="nv">L</span>
    	<span class="nf">ENDIF</span>
    	<span class="nf">ENDM</span>
    	<span class="c1">;宏调用</span>
    	<span class="err">…</span>
    	<span class="nf">SUM</span>    <span class="nv">DW</span>    <span class="mi">100</span>
   	 	<span class="err">…</span>
    	<span class="nf">GOTO</span>    <span class="nv">NEXT</span><span class="p">,</span> <span class="nv">SUM</span><span class="p">,</span> <span class="nv">NZ</span>
    	<span class="nf">GOTO</span>    <span class="nv">EXIT</span>
   		 <span class="err">…</span>
    	<span class="c1">;宏展开</span>
    	<span class="nf">MOV</span>    <span class="nb">CX</span><span class="p">,</span> <span class="nv">SUM</span>
<span class="nl">NEXT:</span>   <span class="nf">DEC</span>    <span class="nb">CX</span>
    	<span class="nf">ADD</span>    <span class="nv">SUM</span><span class="p">,</span> <span class="nb">CX</span>
    	<span class="nf">AND</span>    <span class="nb">CX</span><span class="p">,</span> <span class="nb">CX</span>
    	<span class="nf">JNZ</span>    <span class="nv">NEXT</span>
    	<span class="nf">JMP</span>    <span class="nv">EXIT</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<hr />

<h2 id="练习">练习</h2>

<ol>
  <li>
    <p>如何将AX寄存器清零</p>
  </li>
  <li>
    <p>比较REP指令与LOOP指令：循环类型、影响标志位？</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">MOV  BX,OFFEST  LIST</code>与<code class="language-plaintext highlighter-rouge">LEA  BX, LIST</code>的区别？</p>

    <p>OFFSET属于运算符，在汇编时完成，属于立即寻址<br />
 LEA则是在程序运行时执行，属于直接寻址</p>
  </li>
  <li>
    <p>下面的代码完成了什么操作？如果直接执行<code class="language-plaintext highlighter-rouge">mov ax, dvar</code>会怎么样？</p>

    <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">.MODEL</span> <span class="nv">SMALL</span>
        <span class="nf">.DATA</span>
<span class="nf">dvar</span>    <span class="nv">dd</span>    <span class="mh">12347777h</span><span class="p">,</span> <span class="mh">87651111h</span><span class="p">,</span> <span class="nv">?</span>
        <span class="nf">.CODE</span>
<span class="nl">START:</span>  <span class="nf">mov</span>        <span class="nb">ax</span><span class="p">,</span><span class="err">@</span><span class="nv">data</span>
        <span class="nf">mov</span>        <span class="nb">ds</span><span class="p">,</span><span class="nb">ax</span>
        <span class="nf">mov</span>        <span class="nb">ax</span><span class="p">,</span> <span class="kt">word</span> <span class="nv">ptr</span> <span class="nv">dvar</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>    <span class="c1">;ax=7777h</span>
        <span class="nf">mov</span>        <span class="nb">dx</span><span class="p">,</span> <span class="kt">word</span> <span class="nv">ptr</span> <span class="nv">dvar</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>    <span class="c1">;dx=1234h</span>
        <span class="nf">add</span>        <span class="nb">ax</span><span class="p">,</span> <span class="kt">word</span> <span class="nv">ptr</span> <span class="nv">dvar</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>    <span class="c1">;ax=8888h</span>
        <span class="nf">adc</span>        <span class="nb">dx</span><span class="p">,</span> <span class="kt">word</span> <span class="nv">ptr</span> <span class="nv">dvar</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>    <span class="c1">;dx=9999h</span>
        <span class="nf">mov</span>        <span class="kt">word</span> <span class="nv">ptr</span> <span class="nv">dvar</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span> <span class="nb">ax</span>    <span class="c1">;dvar[8]=88h dvar[9]=88h</span>
        <span class="nf">mov</span>        <span class="kt">word</span> <span class="nv">ptr</span> <span class="nv">dvar</span><span class="p">[</span><span class="mi">10</span><span class="p">],</span> <span class="nb">dx</span>   <span class="c1">;dvar[10]=99h dvar[11]=99h</span>
        <span class="nf">mov</span>        <span class="nb">ax</span><span class="p">,</span> <span class="nv">dvar</span>                <span class="c1">;ax=7777h(warning)</span>
<span class="nl">OVER:</span>   <span class="nf">MOV</span>        <span class="nb">AX</span><span class="p">,</span> <span class="mh">4C00H</span>
        <span class="nf">INT</span>        <span class="mh">21H</span>
        <span class="nf">END</span>        <span class="nv">START</span>
</code></pre></div>    </div>

    <p>小端存储，它是这样存的：</p>

    <table>
      <thead>
        <tr>
          <th style="text-align: center"> </th>
          <th style="text-align: center"> </th>
          <th style="text-align: center">高地址</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td style="text-align: center"> </td>
          <td style="text-align: center"> </td>
          <td style="text-align: center"> </td>
        </tr>
        <tr>
          <td style="text-align: center"> </td>
          <td style="text-align: center"> </td>
          <td style="text-align: center"> </td>
        </tr>
        <tr>
          <td style="text-align: center"> </td>
          <td style="text-align: center"> </td>
          <td style="text-align: center"> </td>
        </tr>
        <tr>
          <td style="text-align: center">87H</td>
          <td style="text-align: center">dvar[7]</td>
          <td style="text-align: center"> </td>
        </tr>
        <tr>
          <td style="text-align: center">65H</td>
          <td style="text-align: center">dvar[6]</td>
          <td style="text-align: center"> </td>
        </tr>
        <tr>
          <td style="text-align: center">11H</td>
          <td style="text-align: center">dvar[5]</td>
          <td style="text-align: center"> </td>
        </tr>
        <tr>
          <td style="text-align: center">11H</td>
          <td style="text-align: center">dvar[4]</td>
          <td style="text-align: center"> </td>
        </tr>
        <tr>
          <td style="text-align: center">12H</td>
          <td style="text-align: center">dvar[3]</td>
          <td style="text-align: center"> </td>
        </tr>
        <tr>
          <td style="text-align: center">34H</td>
          <td style="text-align: center">dvar[2]</td>
          <td style="text-align: center"> </td>
        </tr>
        <tr>
          <td style="text-align: center">77H</td>
          <td style="text-align: center">dvar[1]</td>
          <td style="text-align: center"> </td>
        </tr>
        <tr>
          <td style="text-align: center">77H</td>
          <td style="text-align: center">dvar[0]</td>
          <td style="text-align: center">低地址</td>
        </tr>
      </tbody>
    </table>
  </li>
</ol>

  </div>

  
  
<script src="https://utteranc.es/client.js"
        repo=""
        issue-term="issue-term"
        label="utteranc"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>


  
</article>

<div class="pagination">
  
    <span class="prev" >
      <a href="/assembly-8086/">
        ← 上一篇
      </a>
    </span>
  
  
    <span class="next" >
      <a href="/assembly-commonly-used/">
        下一篇 →
      </a>
    </span>
  
</div>
      </div>
    </div>

    

  </body>

  
  <script>
    document.getElementById("main").classList.add("withtoc");
  </script>
  

  <div class="wrapper-footer-mobile">
    <footer class="footer">
      <!-- Refer to https://codepen.io/ruandre/pen/howFi -->
<ul class="svg-icon">

  
  
  

  

  
  <li><a href="mailto:hiter_sun@163.com" class="icon-8 email" title="Email"><svg viewBox="0 0 512 512"><path d="M502.3 190.8c3.9-3.1 9.7-.2 9.7 4.7V400c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V195.6c0-5 5.7-7.8 9.7-4.7 22.4 17.4 52.1 39.5 154.1 113.6 21.1 15.4 56.7 47.8 92.2 47.6 35.7.3 72-32.8 92.3-47.6 102-74.1 131.6-96.3 154-113.7zM256 320c23.2.4 56.6-29.2 73.4-41.4 132.7-96.3 142.8-104.7 173.4-128.7 5.8-4.5 9.2-11.5 9.2-18.9v-19c0-26.5-21.5-48-48-48H48C21.5 64 0 85.5 0 112v19c0 7.4 3.4 14.3 9.2 18.9 30.6 23.9 40.7 32.4 173.4 128.7 16.8 12.2 50.2 41.8 73.4 41.4z"/></svg><!--[if lt IE 9]><em>Email</em><![endif]--></a></li>
  

  

  

  
  <li><a href="https://github.com/suniven" class="icon-13 github" title="GitHub"><svg viewBox="0 0 512 512"><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg><!--[if lt IE 9]><em>GitHub</em><![endif]--></a></li>
  

  

  

  

  
  <li><a href="/feed.xml" class="icon-21 rss" title="RSS"><svg viewBox="0 0 512 512"><path d="M400 32H48C21.49 32 0 53.49 0 80v352c0 26.51 21.49 48 48 48h352c26.51 0 48-21.49 48-48V80c0-26.51-21.49-48-48-48zM112 416c-26.51 0-48-21.49-48-48s21.49-48 48-48 48 21.49 48 48-21.49 48-48 48zm157.533 0h-34.335c-6.011 0-11.051-4.636-11.442-10.634-5.214-80.05-69.243-143.92-149.123-149.123-5.997-.39-10.633-5.431-10.633-11.441v-34.335c0-6.535 5.468-11.777 11.994-11.425 110.546 5.974 198.997 94.536 204.964 204.964.352 6.526-4.89 11.994-11.425 11.994zm103.027 0h-34.334c-6.161 0-11.175-4.882-11.427-11.038-5.598-136.535-115.204-246.161-251.76-251.76C68.882 152.949 64 147.935 64 141.774V107.44c0-6.454 5.338-11.664 11.787-11.432 167.83 6.025 302.21 141.191 308.205 308.205.232 6.449-4.978 11.787-11.432 11.787z"/></svg><!--[if lt IE 9]><em>RSS</em><![endif]--></a></li>
  

  

  

  

  

</ul>



<p>Copyright (c) 2019-2021 From Gotei13 12th Div.</p>

    </footer>


</html>
